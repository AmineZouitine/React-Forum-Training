{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Ignore = require('@hapi/hoek/lib/ignore');\n\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\n\nconst Errors = require('./errors');\n\nconst State = require('./state');\n\nconst internals = {\n  result: Symbol('result')\n};\n\nexports.entry = function (value, schema, prefs) {\n  let settings = Common.defaults;\n\n  if (prefs) {\n    Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');\n    settings = Common.preferences(Common.defaults, prefs);\n  }\n\n  const result = internals.entry(value, schema, settings);\n  Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');\n  const outcome = {\n    value: result.value\n  };\n\n  if (result.error) {\n    outcome.error = result.error;\n  }\n\n  if (result.mainstay.warnings.length) {\n    outcome.warning = Errors.details(result.mainstay.warnings);\n  }\n\n  if (result.mainstay.debug) {\n    outcome.debug = result.mainstay.debug;\n  }\n\n  return outcome;\n};\n\nexports.entryAsync = async function (value, schema, prefs) {\n  let settings = Common.defaults;\n\n  if (prefs) {\n    settings = Common.preferences(Common.defaults, prefs);\n  }\n\n  const result = internals.entry(value, schema, settings);\n  const mainstay = result.mainstay;\n\n  if (result.error) {\n    if (mainstay.debug) {\n      result.error.debug = mainstay.debug;\n    }\n\n    throw result.error;\n  }\n\n  if (mainstay.externals.length) {\n    let root = result.value;\n\n    for (const {\n      method,\n      path,\n      label\n    } of mainstay.externals) {\n      let node = root;\n      let key;\n      let parent;\n\n      if (path.length) {\n        key = path[path.length - 1];\n        parent = Reach(root, path.slice(0, -1));\n        node = parent[key];\n      }\n\n      try {\n        const output = await method(node);\n\n        if (output === undefined || output === node) {\n          continue;\n        }\n\n        if (parent) {\n          parent[key] = output;\n        } else {\n          root = output;\n        }\n      } catch (err) {\n        err.message += ` (${label})`; // Change message to include path\n\n        throw err;\n      }\n    }\n\n    result.value = root;\n  }\n\n  if (!settings.warnings && !settings.debug) {\n    return result.value;\n  }\n\n  const outcome = {\n    value: result.value\n  };\n\n  if (mainstay.warnings.length) {\n    outcome.warning = Errors.details(mainstay.warnings);\n  }\n\n  if (mainstay.debug) {\n    outcome.debug = mainstay.debug;\n  }\n\n  return outcome;\n};\n\ninternals.entry = function (value, schema, prefs) {\n  // Prepare state\n  const {\n    tracer,\n    cleanup\n  } = internals.tracer(schema, prefs);\n  const debug = prefs.debug ? [] : null;\n  const links = schema._ids._schemaChain ? new Map() : null;\n  const mainstay = {\n    externals: [],\n    warnings: [],\n    tracer,\n    debug,\n    links\n  };\n  const schemas = schema._ids._schemaChain ? [{\n    schema\n  }] : null;\n  const state = new State([], [], {\n    mainstay,\n    schemas\n  }); // Validate value\n\n  const result = exports.validate(value, schema, state, prefs); // Process value and errors\n\n  if (cleanup) {\n    schema.$_root.untrace();\n  }\n\n  const error = Errors.process(result.errors, value, prefs);\n  return {\n    value: result.value,\n    error,\n    mainstay\n  };\n};\n\ninternals.tracer = function (schema, prefs) {\n  if (schema.$_root._tracer) {\n    return {\n      tracer: schema.$_root._tracer._register(schema)\n    };\n  }\n\n  if (prefs.debug) {\n    Assert(schema.$_root.trace, 'Debug mode not supported');\n    return {\n      tracer: schema.$_root.trace()._register(schema),\n      cleanup: true\n    };\n  }\n\n  return {\n    tracer: internals.ignore\n  };\n};\n\nexports.validate = function (value, schema, state, prefs) {\n  let overrides = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  if (schema.$_terms.whens) {\n    schema = schema._generate(value, state, prefs).schema;\n  } // Setup state and settings\n\n\n  if (schema._preferences) {\n    prefs = internals.prefs(schema, prefs);\n  } // Cache\n\n\n  if (schema._cache && prefs.cache) {\n    const result = schema._cache.get(value);\n\n    state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);\n\n    if (result) {\n      return result;\n    }\n  } // Helpers\n\n\n  const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);\n\n  const helpers = {\n    original: value,\n    prefs,\n    schema,\n    state,\n    error: createError,\n    warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),\n    message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, {\n      messages\n    })\n  }; // Prepare\n\n  state.mainstay.tracer.entry(schema, state);\n  const def = schema._definition;\n\n  if (def.prepare && value !== undefined && prefs.convert) {\n    const prepared = def.prepare(value, helpers);\n\n    if (prepared) {\n      state.mainstay.tracer.value(state, 'prepare', value, prepared.value);\n\n      if (prepared.errors) {\n        return internals.finalize(prepared.value, [].concat(prepared.errors), helpers); // Prepare error always aborts early\n      }\n\n      value = prepared.value;\n    }\n  } // Type coercion\n\n\n  if (def.coerce && value !== undefined && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {\n    const coerced = def.coerce.method(value, helpers);\n\n    if (coerced) {\n      state.mainstay.tracer.value(state, 'coerced', value, coerced.value);\n\n      if (coerced.errors) {\n        return internals.finalize(coerced.value, [].concat(coerced.errors), helpers); // Coerce error always aborts early\n      }\n\n      value = coerced.value;\n    }\n  } // Empty value\n\n\n  const empty = schema._flags.empty;\n\n  if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {\n    state.mainstay.tracer.value(state, 'empty', value, undefined);\n    value = undefined;\n  } // Presence requirements (required, optional, forbidden)\n\n\n  const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? 'ignore' : prefs.presence);\n\n  if (value === undefined) {\n    if (presence === 'forbidden') {\n      return internals.finalize(value, null, helpers);\n    }\n\n    if (presence === 'required') {\n      return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);\n    }\n\n    if (presence === 'optional') {\n      if (schema._flags.default !== Common.symbols.deepDefault) {\n        return internals.finalize(value, null, helpers);\n      }\n\n      state.mainstay.tracer.value(state, 'default', value, {});\n      value = {};\n    }\n  } else if (presence === 'forbidden') {\n    return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);\n  } // Allowed values\n\n\n  const errors = [];\n\n  if (schema._valids) {\n    const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);\n\n    if (match) {\n      if (prefs.convert) {\n        state.mainstay.tracer.value(state, 'valids', value, match.value);\n        value = match.value;\n      }\n\n      state.mainstay.tracer.filter(schema, state, 'valid', match);\n      return internals.finalize(value, null, helpers);\n    }\n\n    if (schema._flags.only) {\n      const report = schema.$_createError('any.only', value, {\n        valids: schema._valids.values({\n          display: true\n        })\n      }, state, prefs);\n\n      if (prefs.abortEarly) {\n        return internals.finalize(value, [report], helpers);\n      }\n\n      errors.push(report);\n    }\n  } // Denied values\n\n\n  if (schema._invalids) {\n    const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);\n\n    if (match) {\n      state.mainstay.tracer.filter(schema, state, 'invalid', match);\n      const report = schema.$_createError('any.invalid', value, {\n        invalids: schema._invalids.values({\n          display: true\n        })\n      }, state, prefs);\n\n      if (prefs.abortEarly) {\n        return internals.finalize(value, [report], helpers);\n      }\n\n      errors.push(report);\n    }\n  } // Base type\n\n\n  if (def.validate) {\n    const base = def.validate(value, helpers);\n\n    if (base) {\n      state.mainstay.tracer.value(state, 'base', value, base.value);\n      value = base.value;\n\n      if (base.errors) {\n        if (!Array.isArray(base.errors)) {\n          errors.push(base.errors);\n          return internals.finalize(value, errors, helpers); // Base error always aborts early\n        }\n\n        if (base.errors.length) {\n          errors.push(...base.errors);\n          return internals.finalize(value, errors, helpers); // Base error always aborts early\n        }\n      }\n    }\n  } // Validate tests\n\n\n  if (!schema._rules.length) {\n    return internals.finalize(value, errors, helpers);\n  }\n\n  return internals.rules(value, errors, helpers);\n};\n\ninternals.rules = function (value, errors, helpers) {\n  const {\n    schema,\n    state,\n    prefs\n  } = helpers;\n\n  for (const rule of schema._rules) {\n    const definition = schema._definition.rules[rule.method]; // Skip rules that are also applied in coerce step\n\n    if (definition.convert && prefs.convert) {\n      state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');\n      continue;\n    } // Resolve references\n\n\n    let ret;\n    let args = rule.args;\n\n    if (rule._resolve.length) {\n      args = Object.assign({}, args); // Shallow copy\n\n      for (const key of rule._resolve) {\n        const resolver = definition.argsByName.get(key);\n        const resolved = args[key].resolve(value, state, prefs);\n        const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;\n        const invalid = Common.validateArg(normalized, null, resolver);\n\n        if (invalid) {\n          ret = schema.$_createError('any.ref', resolved, {\n            arg: key,\n            ref: args[key],\n            reason: invalid\n          }, state, prefs);\n          break;\n        }\n\n        args[key] = normalized;\n      }\n    } // Test rule\n\n\n    ret = ret || definition.validate(value, helpers, args, rule); // Use ret if already set to reference error\n\n    const result = internals.rule(ret, rule);\n\n    if (result.errors) {\n      state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');\n\n      if (rule.warn) {\n        state.mainstay.warnings.push(...result.errors);\n        continue;\n      }\n\n      if (prefs.abortEarly) {\n        return internals.finalize(value, result.errors, helpers);\n      }\n\n      errors.push(...result.errors);\n    } else {\n      state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');\n      state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);\n      value = result.value;\n    }\n  }\n\n  return internals.finalize(value, errors, helpers);\n};\n\ninternals.rule = function (ret, rule) {\n  if (ret instanceof Errors.Report) {\n    internals.error(ret, rule);\n    return {\n      errors: [ret],\n      value: null\n    };\n  }\n\n  if (Array.isArray(ret) && (ret[0] instanceof Errors.Report || ret[0] instanceof Error)) {\n    ret.forEach(report => internals.error(report, rule));\n    return {\n      errors: ret,\n      value: null\n    };\n  }\n\n  return {\n    errors: null,\n    value: ret\n  };\n};\n\ninternals.error = function (report, rule) {\n  if (rule.message) {\n    report._setTemplate(rule.message);\n  }\n\n  return report;\n};\n\ninternals.finalize = function (value, errors, helpers) {\n  errors = errors || [];\n  const {\n    schema,\n    state,\n    prefs\n  } = helpers; // Failover value\n\n  if (errors.length) {\n    const failover = internals.default('failover', undefined, errors, helpers);\n\n    if (failover !== undefined) {\n      state.mainstay.tracer.value(state, 'failover', value, failover);\n      value = failover;\n      errors = [];\n    }\n  } // Error override\n\n\n  if (errors.length && schema._flags.error) {\n    if (typeof schema._flags.error === 'function') {\n      errors = schema._flags.error(errors);\n\n      if (!Array.isArray(errors)) {\n        errors = [errors];\n      }\n\n      for (const error of errors) {\n        Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');\n      }\n    } else {\n      errors = [schema._flags.error];\n    }\n  } // Default\n\n\n  if (value === undefined) {\n    const defaulted = internals.default('default', value, errors, helpers);\n    state.mainstay.tracer.value(state, 'default', value, defaulted);\n    value = defaulted;\n  } // Cast\n\n\n  if (schema._flags.cast && value !== undefined) {\n    const caster = schema._definition.cast[schema._flags.cast];\n\n    if (caster.from(value)) {\n      const casted = caster.to(value, helpers);\n      state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);\n      value = casted;\n    }\n  } // Externals\n\n\n  if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {\n    // Disabled for matching\n    for (const {\n      method\n    } of schema.$_terms.externals) {\n      state.mainstay.externals.push({\n        method,\n        path: state.path,\n        label: Errors.label(schema._flags, state, prefs)\n      });\n    }\n  } // Result\n\n\n  const result = {\n    value,\n    errors: errors.length ? errors : null\n  };\n\n  if (schema._flags.result) {\n    result.value = schema._flags.result === 'strip' ? undefined :\n    /* raw */\n    helpers.original;\n    state.mainstay.tracer.value(state, schema._flags.result, value, result.value);\n    state.shadow(value, schema._flags.result);\n  } // Cache\n\n\n  if (schema._cache && prefs.cache !== false && !schema._refs.length) {\n    schema._cache.set(helpers.original, result);\n  }\n\n  return result;\n};\n\ninternals.prefs = function (schema, prefs) {\n  const isDefaultOptions = prefs === Common.defaults;\n\n  if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {\n    return schema._preferences[Common.symbols.prefs];\n  }\n\n  prefs = Common.preferences(prefs, schema._preferences);\n\n  if (isDefaultOptions) {\n    schema._preferences[Common.symbols.prefs] = prefs;\n  }\n\n  return prefs;\n};\n\ninternals.default = function (flag, value, errors, helpers) {\n  const {\n    schema,\n    state,\n    prefs\n  } = helpers;\n  const source = schema._flags[flag];\n\n  if (prefs.noDefaults || source === undefined) {\n    return value;\n  }\n\n  state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');\n\n  if (!source) {\n    return source;\n  }\n\n  if (typeof source === 'function') {\n    const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];\n\n    try {\n      return source(...args);\n    } catch (err) {\n      errors.push(schema.$_createError(`any.${flag}`, null, {\n        error: err\n      }, state, prefs));\n      return;\n    }\n  }\n\n  if (typeof source !== 'object') {\n    return source;\n  }\n\n  if (source[Common.symbols.literal]) {\n    return source.literal;\n  }\n\n  if (Common.isResolvable(source)) {\n    return source.resolve(value, state, prefs);\n  }\n\n  return Clone(source);\n};\n\ninternals.trim = function (value, schema) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  const trim = schema.$_getRule('trim');\n\n  if (!trim || !trim.args.enabled) {\n    return value;\n  }\n\n  return value.trim();\n};\n\ninternals.ignore = {\n  active: false,\n  debug: Ignore,\n  entry: Ignore,\n  filter: Ignore,\n  log: Ignore,\n  resolve: Ignore,\n  value: Ignore\n};","map":{"version":3,"names":["Assert","require","Clone","Ignore","Reach","Common","Errors","State","internals","result","Symbol","exports","entry","value","schema","prefs","settings","defaults","warnings","undefined","preferences","mainstay","externals","length","outcome","error","warning","details","debug","entryAsync","root","method","path","label","node","key","parent","slice","output","err","message","tracer","cleanup","links","_ids","_schemaChain","Map","schemas","state","validate","$_root","untrace","process","errors","_tracer","_register","trace","ignore","overrides","$_terms","whens","_generate","_preferences","_cache","cache","get","createError","code","local","localState","$_createError","helpers","original","warn","push","messages","def","_definition","prepare","convert","prepared","finalize","concat","coerce","from","includes","coerced","empty","_flags","$_match","trim","nest","presence","_endedSwitch","default","symbols","deepDefault","_valids","match","insensitive","filter","only","report","valids","values","display","abortEarly","_invalids","invalids","base","Array","isArray","_rules","rules","rule","definition","log","name","ret","args","_resolve","Object","assign","resolver","argsByName","resolved","resolve","normalized","normalize","invalid","validateArg","arg","ref","reason","Report","Error","forEach","_setTemplate","failover","defaulted","cast","caster","casted","to","_externals","shadow","_refs","set","isDefaultOptions","flag","source","noDefaults","ancestors","literal","isResolvable","$_getRule","enabled","active"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/validator.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst Ignore = require('@hapi/hoek/lib/ignore');\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\nconst Errors = require('./errors');\nconst State = require('./state');\n\n\nconst internals = {\n    result: Symbol('result')\n};\n\n\nexports.entry = function (value, schema, prefs) {\n\n    let settings = Common.defaults;\n    if (prefs) {\n        Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n\n    const result = internals.entry(value, schema, settings);\n    Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');\n    const outcome = { value: result.value };\n\n    if (result.error) {\n        outcome.error = result.error;\n    }\n\n    if (result.mainstay.warnings.length) {\n        outcome.warning = Errors.details(result.mainstay.warnings);\n    }\n\n    if (result.mainstay.debug) {\n        outcome.debug = result.mainstay.debug;\n    }\n\n    return outcome;\n};\n\n\nexports.entryAsync = async function (value, schema, prefs) {\n\n    let settings = Common.defaults;\n    if (prefs) {\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n\n    const result = internals.entry(value, schema, settings);\n    const mainstay = result.mainstay;\n    if (result.error) {\n        if (mainstay.debug) {\n            result.error.debug = mainstay.debug;\n        }\n\n        throw result.error;\n    }\n\n    if (mainstay.externals.length) {\n        let root = result.value;\n        for (const { method, path, label } of mainstay.externals) {\n            let node = root;\n            let key;\n            let parent;\n\n            if (path.length) {\n                key = path[path.length - 1];\n                parent = Reach(root, path.slice(0, -1));\n                node = parent[key];\n            }\n\n            try {\n                const output = await method(node);\n                if (output === undefined ||\n                    output === node) {\n\n                    continue;\n                }\n\n                if (parent) {\n                    parent[key] = output;\n                }\n                else {\n                    root = output;\n                }\n            }\n            catch (err) {\n                err.message += ` (${label})`;       // Change message to include path\n                throw err;\n            }\n        }\n\n        result.value = root;\n    }\n\n    if (!settings.warnings &&\n        !settings.debug) {\n\n        return result.value;\n    }\n\n    const outcome = { value: result.value };\n    if (mainstay.warnings.length) {\n        outcome.warning = Errors.details(mainstay.warnings);\n    }\n\n    if (mainstay.debug) {\n        outcome.debug = mainstay.debug;\n    }\n\n    return outcome;\n};\n\n\ninternals.entry = function (value, schema, prefs) {\n\n    // Prepare state\n\n    const { tracer, cleanup } = internals.tracer(schema, prefs);\n    const debug = prefs.debug ? [] : null;\n    const links = schema._ids._schemaChain ? new Map() : null;\n    const mainstay = { externals: [], warnings: [], tracer, debug, links };\n    const schemas = schema._ids._schemaChain ? [{ schema }] : null;\n    const state = new State([], [], { mainstay, schemas });\n\n    // Validate value\n\n    const result = exports.validate(value, schema, state, prefs);\n\n    // Process value and errors\n\n    if (cleanup) {\n        schema.$_root.untrace();\n    }\n\n    const error = Errors.process(result.errors, value, prefs);\n    return { value: result.value, error, mainstay };\n};\n\n\ninternals.tracer = function (schema, prefs) {\n\n    if (schema.$_root._tracer) {\n        return { tracer: schema.$_root._tracer._register(schema) };\n    }\n\n    if (prefs.debug) {\n        Assert(schema.$_root.trace, 'Debug mode not supported');\n        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };\n    }\n\n    return { tracer: internals.ignore };\n};\n\n\nexports.validate = function (value, schema, state, prefs, overrides = {}) {\n\n    if (schema.$_terms.whens) {\n        schema = schema._generate(value, state, prefs).schema;\n    }\n\n    // Setup state and settings\n\n    if (schema._preferences) {\n        prefs = internals.prefs(schema, prefs);\n    }\n\n    // Cache\n\n    if (schema._cache &&\n        prefs.cache) {\n\n        const result = schema._cache.get(value);\n        state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);\n        if (result) {\n            return result;\n        }\n    }\n\n    // Helpers\n\n    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);\n    const helpers = {\n        original: value,\n        prefs,\n        schema,\n        state,\n        error: createError,\n        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),\n        message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, { messages })\n    };\n\n    // Prepare\n\n    state.mainstay.tracer.entry(schema, state);\n\n    const def = schema._definition;\n    if (def.prepare &&\n        value !== undefined &&\n        prefs.convert) {\n\n        const prepared = def.prepare(value, helpers);\n        if (prepared) {\n            state.mainstay.tracer.value(state, 'prepare', value, prepared.value);\n            if (prepared.errors) {\n                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);         // Prepare error always aborts early\n            }\n\n            value = prepared.value;\n        }\n    }\n\n    // Type coercion\n\n    if (def.coerce &&\n        value !== undefined &&\n        prefs.convert &&\n        (!def.coerce.from || def.coerce.from.includes(typeof value))) {\n\n        const coerced = def.coerce.method(value, helpers);\n        if (coerced) {\n            state.mainstay.tracer.value(state, 'coerced', value, coerced.value);\n            if (coerced.errors) {\n                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);           // Coerce error always aborts early\n            }\n\n            value = coerced.value;\n        }\n    }\n\n    // Empty value\n\n    const empty = schema._flags.empty;\n    if (empty &&\n        empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {\n\n        state.mainstay.tracer.value(state, 'empty', value, undefined);\n        value = undefined;\n    }\n\n    // Presence requirements (required, optional, forbidden)\n\n    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? 'ignore' : prefs.presence);\n    if (value === undefined) {\n        if (presence === 'forbidden') {\n            return internals.finalize(value, null, helpers);\n        }\n\n        if (presence === 'required') {\n            return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);\n        }\n\n        if (presence === 'optional') {\n            if (schema._flags.default !== Common.symbols.deepDefault) {\n                return internals.finalize(value, null, helpers);\n            }\n\n            state.mainstay.tracer.value(state, 'default', value, {});\n            value = {};\n        }\n    }\n    else if (presence === 'forbidden') {\n        return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);\n    }\n\n    // Allowed values\n\n    const errors = [];\n\n    if (schema._valids) {\n        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            if (prefs.convert) {\n                state.mainstay.tracer.value(state, 'valids', value, match.value);\n                value = match.value;\n            }\n\n            state.mainstay.tracer.filter(schema, state, 'valid', match);\n            return internals.finalize(value, null, helpers);\n        }\n\n        if (schema._flags.only) {\n            const report = schema.$_createError('any.only', value, { valids: schema._valids.values({ display: true }) }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [report], helpers);\n            }\n\n            errors.push(report);\n        }\n    }\n\n    // Denied values\n\n    if (schema._invalids) {\n        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            state.mainstay.tracer.filter(schema, state, 'invalid', match);\n            const report = schema.$_createError('any.invalid', value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [report], helpers);\n            }\n\n            errors.push(report);\n        }\n    }\n\n    // Base type\n\n    if (def.validate) {\n        const base = def.validate(value, helpers);\n        if (base) {\n            state.mainstay.tracer.value(state, 'base', value, base.value);\n            value = base.value;\n\n            if (base.errors) {\n                if (!Array.isArray(base.errors)) {\n                    errors.push(base.errors);\n                    return internals.finalize(value, errors, helpers);          // Base error always aborts early\n                }\n\n                if (base.errors.length) {\n                    errors.push(...base.errors);\n                    return internals.finalize(value, errors, helpers);          // Base error always aborts early\n                }\n            }\n        }\n    }\n\n    // Validate tests\n\n    if (!schema._rules.length) {\n        return internals.finalize(value, errors, helpers);\n    }\n\n    return internals.rules(value, errors, helpers);\n};\n\n\ninternals.rules = function (value, errors, helpers) {\n\n    const { schema, state, prefs } = helpers;\n\n    for (const rule of schema._rules) {\n        const definition = schema._definition.rules[rule.method];\n\n        // Skip rules that are also applied in coerce step\n\n        if (definition.convert &&\n            prefs.convert) {\n\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');\n            continue;\n        }\n\n        // Resolve references\n\n        let ret;\n        let args = rule.args;\n        if (rule._resolve.length) {\n            args = Object.assign({}, args);                                     // Shallow copy\n            for (const key of rule._resolve) {\n                const resolver = definition.argsByName.get(key);\n\n                const resolved = args[key].resolve(value, state, prefs);\n                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;\n\n                const invalid = Common.validateArg(normalized, null, resolver);\n                if (invalid) {\n                    ret = schema.$_createError('any.ref', resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);\n                    break;\n                }\n\n                args[key] = normalized;\n            }\n        }\n\n        // Test rule\n\n        ret = ret || definition.validate(value, helpers, args, rule);           // Use ret if already set to reference error\n\n        const result = internals.rule(ret, rule);\n        if (result.errors) {\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');\n\n            if (rule.warn) {\n                state.mainstay.warnings.push(...result.errors);\n                continue;\n            }\n\n            if (prefs.abortEarly) {\n                return internals.finalize(value, result.errors, helpers);\n            }\n\n            errors.push(...result.errors);\n        }\n        else {\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');\n            state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);\n            value = result.value;\n        }\n    }\n\n    return internals.finalize(value, errors, helpers);\n};\n\n\ninternals.rule = function (ret, rule) {\n\n    if (ret instanceof Errors.Report) {\n        internals.error(ret, rule);\n        return { errors: [ret], value: null };\n    }\n\n    if (Array.isArray(ret) &&\n        (ret[0] instanceof Errors.Report || ret[0] instanceof Error)) {\n\n        ret.forEach((report) => internals.error(report, rule));\n        return { errors: ret, value: null };\n    }\n\n    return { errors: null, value: ret };\n};\n\n\ninternals.error = function (report, rule) {\n\n    if (rule.message) {\n        report._setTemplate(rule.message);\n    }\n\n    return report;\n};\n\n\ninternals.finalize = function (value, errors, helpers) {\n\n    errors = errors || [];\n    const { schema, state, prefs } = helpers;\n\n    // Failover value\n\n    if (errors.length) {\n        const failover = internals.default('failover', undefined, errors, helpers);\n        if (failover !== undefined) {\n            state.mainstay.tracer.value(state, 'failover', value, failover);\n            value = failover;\n            errors = [];\n        }\n    }\n\n    // Error override\n\n    if (errors.length &&\n        schema._flags.error) {\n\n        if (typeof schema._flags.error === 'function') {\n            errors = schema._flags.error(errors);\n            if (!Array.isArray(errors)) {\n                errors = [errors];\n            }\n\n            for (const error of errors) {\n                Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');\n            }\n        }\n        else {\n            errors = [schema._flags.error];\n        }\n    }\n\n    // Default\n\n    if (value === undefined) {\n        const defaulted = internals.default('default', value, errors, helpers);\n        state.mainstay.tracer.value(state, 'default', value, defaulted);\n        value = defaulted;\n    }\n\n    // Cast\n\n    if (schema._flags.cast &&\n        value !== undefined) {\n\n        const caster = schema._definition.cast[schema._flags.cast];\n        if (caster.from(value)) {\n            const casted = caster.to(value, helpers);\n            state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);\n            value = casted;\n        }\n    }\n\n    // Externals\n\n    if (schema.$_terms.externals &&\n        prefs.externals &&\n        prefs._externals !== false) {                       // Disabled for matching\n\n        for (const { method } of schema.$_terms.externals) {\n            state.mainstay.externals.push({ method, path: state.path, label: Errors.label(schema._flags, state, prefs) });\n        }\n    }\n\n    // Result\n\n    const result = { value, errors: errors.length ? errors : null };\n\n    if (schema._flags.result) {\n        result.value = schema._flags.result === 'strip' ? undefined : /* raw */ helpers.original;\n        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);\n        state.shadow(value, schema._flags.result);\n    }\n\n    // Cache\n\n    if (schema._cache &&\n        prefs.cache !== false &&\n        !schema._refs.length) {\n\n        schema._cache.set(helpers.original, result);\n    }\n\n    return result;\n};\n\n\ninternals.prefs = function (schema, prefs) {\n\n    const isDefaultOptions = prefs === Common.defaults;\n    if (isDefaultOptions &&\n        schema._preferences[Common.symbols.prefs]) {\n\n        return schema._preferences[Common.symbols.prefs];\n    }\n\n    prefs = Common.preferences(prefs, schema._preferences);\n    if (isDefaultOptions) {\n        schema._preferences[Common.symbols.prefs] = prefs;\n    }\n\n    return prefs;\n};\n\n\ninternals.default = function (flag, value, errors, helpers) {\n\n    const { schema, state, prefs } = helpers;\n    const source = schema._flags[flag];\n    if (prefs.noDefaults ||\n        source === undefined) {\n\n        return value;\n    }\n\n    state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');\n\n    if (!source) {\n        return source;\n    }\n\n    if (typeof source === 'function') {\n        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];\n\n        try {\n            return source(...args);\n        }\n        catch (err) {\n            errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));\n            return;\n        }\n    }\n\n    if (typeof source !== 'object') {\n        return source;\n    }\n\n    if (source[Common.symbols.literal]) {\n        return source.literal;\n    }\n\n    if (Common.isResolvable(source)) {\n        return source.resolve(value, state, prefs);\n    }\n\n    return Clone(source);\n};\n\n\ninternals.trim = function (value, schema) {\n\n    if (typeof value !== 'string') {\n        return value;\n    }\n\n    const trim = schema.$_getRule('trim');\n    if (!trim ||\n        !trim.args.enabled) {\n\n        return value;\n    }\n\n    return value.trim();\n};\n\n\ninternals.ignore = {\n    active: false,\n    debug: Ignore,\n    entry: Ignore,\n    filter: Ignore,\n    log: Ignore,\n    resolve: Ignore,\n    value: Ignore\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}