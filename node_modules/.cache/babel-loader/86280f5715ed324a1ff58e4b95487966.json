{"ast":null,"code":"'use strict';\n\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\n\nconst Pinpoint = require('@hapi/pinpoint');\n\nconst Errors = require('./errors');\n\nconst internals = {\n  codes: {\n    error: 1,\n    pass: 2,\n    full: 3\n  },\n  labels: {\n    0: 'never used',\n    1: 'always error',\n    2: 'always pass'\n  }\n};\n\nexports.setup = function (root) {\n  const trace = function () {\n    root._tracer = root._tracer || new internals.Tracer();\n    return root._tracer;\n  };\n\n  root.trace = trace;\n  root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;\n\n  root.untrace = () => {\n    root._tracer = null;\n  };\n};\n\nexports.location = function (schema) {\n  return schema.$_setFlag('_tracerLocation', Pinpoint.location(2)); // base.tracer(), caller\n};\n\ninternals.Tracer = class {\n  constructor() {\n    this.name = 'Joi';\n    this._schemas = new Map();\n  }\n\n  _register(schema) {\n    const existing = this._schemas.get(schema);\n\n    if (existing) {\n      return existing.store;\n    }\n\n    const store = new internals.Store(schema);\n    const {\n      filename,\n      line\n    } = schema._flags._tracerLocation || Pinpoint.location(5); // internals.tracer(), internals.entry(), exports.entry(), validate(), caller\n\n    this._schemas.set(schema, {\n      filename,\n      line,\n      store\n    });\n\n    return store;\n  }\n\n  _combine(merged, sources) {\n    for (const {\n      store\n    } of this._schemas.values()) {\n      store._combine(merged, sources);\n    }\n  }\n\n  report(file) {\n    const coverage = []; // Process each registered schema\n\n    for (const {\n      filename,\n      line,\n      store\n    } of this._schemas.values()) {\n      if (file && file !== filename) {\n        continue;\n      } // Process sub schemas of the registered root\n\n\n      const missing = [];\n      const skipped = [];\n\n      for (const [schema, log] of store._sources.entries()) {\n        // Check if sub schema parent skipped\n        if (internals.sub(log.paths, skipped)) {\n          continue;\n        } // Check if sub schema reached\n\n\n        if (!log.entry) {\n          missing.push({\n            status: 'never reached',\n            paths: [...log.paths]\n          });\n          skipped.push(...log.paths);\n          continue;\n        } // Check values\n\n\n        for (const type of ['valid', 'invalid']) {\n          const set = schema[`_${type}s`];\n\n          if (!set) {\n            continue;\n          }\n\n          const values = new Set(set._values);\n          const refs = new Set(set._refs);\n\n          for (const {\n            value,\n            ref\n          } of log[type]) {\n            values.delete(value);\n            refs.delete(ref);\n          }\n\n          if (values.size || refs.size) {\n            missing.push({\n              status: [...values, ...[...refs].map(ref => ref.display)],\n              rule: `${type}s`\n            });\n          }\n        } // Check rules status\n\n\n        const rules = schema._rules.map(rule => rule.name);\n\n        for (const type of ['default', 'failover']) {\n          if (schema._flags[type] !== undefined) {\n            rules.push(type);\n          }\n        }\n\n        for (const name of rules) {\n          const status = internals.labels[log.rule[name] || 0];\n\n          if (status) {\n            const report = {\n              rule: name,\n              status\n            };\n\n            if (log.paths.size) {\n              report.paths = [...log.paths];\n            }\n\n            missing.push(report);\n          }\n        }\n      }\n\n      if (missing.length) {\n        coverage.push({\n          filename,\n          line,\n          missing,\n          severity: 'error',\n          message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`\n        });\n      }\n    }\n\n    return coverage.length ? coverage : null;\n  }\n\n};\ninternals.Store = class {\n  constructor(schema) {\n    this.active = true;\n    this._sources = new Map(); // schema -> { paths, entry, rule, valid, invalid }\n\n    this._combos = new Map(); // merged -> [sources]\n\n    this._scan(schema);\n  }\n\n  debug(state, source, name, result) {\n    state.mainstay.debug && state.mainstay.debug.push({\n      type: source,\n      name,\n      result,\n      path: state.path\n    });\n  }\n\n  entry(schema, state) {\n    internals.debug(state, {\n      type: 'entry'\n    });\n\n    this._record(schema, log => {\n      log.entry = true;\n    });\n  }\n\n  filter(schema, state, source, value) {\n    internals.debug(state, {\n      type: source,\n      ...value\n    });\n\n    this._record(schema, log => {\n      log[source].add(value);\n    });\n  }\n\n  log(schema, state, source, name, result) {\n    internals.debug(state, {\n      type: source,\n      name,\n      result: result === 'full' ? 'pass' : result\n    });\n\n    this._record(schema, log => {\n      log[source][name] = log[source][name] || 0;\n      log[source][name] |= internals.codes[result];\n    });\n  }\n\n  resolve(state, ref, to) {\n    if (!state.mainstay.debug) {\n      return;\n    }\n\n    const log = {\n      type: 'resolve',\n      ref: ref.display,\n      to,\n      path: state.path\n    };\n    state.mainstay.debug.push(log);\n  }\n\n  value(state, by, from, to, name) {\n    if (!state.mainstay.debug || DeepEqual(from, to)) {\n      return;\n    }\n\n    const log = {\n      type: 'value',\n      by,\n      from,\n      to,\n      path: state.path\n    };\n\n    if (name) {\n      log.name = name;\n    }\n\n    state.mainstay.debug.push(log);\n  }\n\n  _record(schema, each) {\n    const log = this._sources.get(schema);\n\n    if (log) {\n      each(log);\n      return;\n    }\n\n    const sources = this._combos.get(schema);\n\n    for (const source of sources) {\n      this._record(source, each);\n    }\n  }\n\n  _scan(schema, _path) {\n    const path = _path || [];\n\n    let log = this._sources.get(schema);\n\n    if (!log) {\n      log = {\n        paths: new Set(),\n        entry: false,\n        rule: {},\n        valid: new Set(),\n        invalid: new Set()\n      };\n\n      this._sources.set(schema, log);\n    }\n\n    if (path.length) {\n      log.paths.add(path);\n    }\n\n    const each = (sub, source) => {\n      const subId = internals.id(sub, source);\n\n      this._scan(sub, path.concat(subId));\n    };\n\n    schema.$_modify({\n      each,\n      ref: false\n    });\n  }\n\n  _combine(merged, sources) {\n    this._combos.set(merged, sources);\n  }\n\n};\n\ninternals.message = function (item) {\n  const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';\n  return `${path}${item.rule || ''} (${item.status})`;\n};\n\ninternals.id = function (schema, _ref) {\n  let {\n    source,\n    name,\n    path,\n    key\n  } = _ref;\n\n  if (schema._flags.id) {\n    return schema._flags.id;\n  }\n\n  if (key) {\n    return key;\n  }\n\n  name = `@${name}`;\n\n  if (source === 'terms') {\n    return [name, path[Math.min(path.length - 1, 1)]];\n  }\n\n  return name;\n};\n\ninternals.sub = function (paths, skipped) {\n  for (const path of paths) {\n    for (const skip of skipped) {\n      if (DeepEqual(path.slice(0, skip.length), skip)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\ninternals.debug = function (state, event) {\n  if (state.mainstay.debug) {\n    event.path = state.debug ? [...state.path, state.debug] : state.path;\n    state.mainstay.debug.push(event);\n  }\n};","map":{"version":3,"names":["DeepEqual","require","Pinpoint","Errors","internals","codes","error","pass","full","labels","exports","setup","root","trace","_tracer","Tracer","Symbol","for","untrace","location","schema","$_setFlag","constructor","name","_schemas","Map","_register","existing","get","store","Store","filename","line","_flags","_tracerLocation","set","_combine","merged","sources","values","report","file","coverage","missing","skipped","log","_sources","entries","sub","paths","entry","push","status","type","Set","_values","refs","_refs","value","ref","delete","size","map","display","rule","rules","_rules","undefined","length","severity","message","join","active","_combos","_scan","debug","state","source","result","mainstay","path","_record","filter","add","resolve","to","by","from","each","_path","valid","invalid","subId","id","concat","$_modify","item","key","Math","min","skip","slice","event"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/trace.js"],"sourcesContent":["'use strict';\n\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\nconst Pinpoint = require('@hapi/pinpoint');\n\nconst Errors = require('./errors');\n\n\nconst internals = {\n    codes: {\n        error: 1,\n        pass: 2,\n        full: 3\n    },\n    labels: {\n        0: 'never used',\n        1: 'always error',\n        2: 'always pass'\n    }\n};\n\n\nexports.setup = function (root) {\n\n    const trace = function () {\n\n        root._tracer = root._tracer || new internals.Tracer();\n        return root._tracer;\n    };\n\n    root.trace = trace;\n    root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;\n\n    root.untrace = () => {\n\n        root._tracer = null;\n    };\n};\n\n\nexports.location = function (schema) {\n\n    return schema.$_setFlag('_tracerLocation', Pinpoint.location(2));                       // base.tracer(), caller\n};\n\n\ninternals.Tracer = class {\n\n    constructor() {\n\n        this.name = 'Joi';\n        this._schemas = new Map();\n    }\n\n    _register(schema) {\n\n        const existing = this._schemas.get(schema);\n        if (existing) {\n            return existing.store;\n        }\n\n        const store = new internals.Store(schema);\n        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);   // internals.tracer(), internals.entry(), exports.entry(), validate(), caller\n        this._schemas.set(schema, { filename, line, store });\n        return store;\n    }\n\n    _combine(merged, sources) {\n\n        for (const { store } of this._schemas.values()) {\n            store._combine(merged, sources);\n        }\n    }\n\n    report(file) {\n\n        const coverage = [];\n\n        // Process each registered schema\n\n        for (const { filename, line, store } of this._schemas.values()) {\n            if (file &&\n                file !== filename) {\n\n                continue;\n            }\n\n            // Process sub schemas of the registered root\n\n            const missing = [];\n            const skipped = [];\n\n            for (const [schema, log] of store._sources.entries()) {\n\n                // Check if sub schema parent skipped\n\n                if (internals.sub(log.paths, skipped)) {\n                    continue;\n                }\n\n                // Check if sub schema reached\n\n                if (!log.entry) {\n                    missing.push({\n                        status: 'never reached',\n                        paths: [...log.paths]\n                    });\n\n                    skipped.push(...log.paths);\n                    continue;\n                }\n\n                // Check values\n\n                for (const type of ['valid', 'invalid']) {\n                    const set = schema[`_${type}s`];\n                    if (!set) {\n                        continue;\n                    }\n\n                    const values = new Set(set._values);\n                    const refs = new Set(set._refs);\n                    for (const { value, ref } of log[type]) {\n                        values.delete(value);\n                        refs.delete(ref);\n                    }\n\n                    if (values.size ||\n                        refs.size) {\n\n                        missing.push({\n                            status: [...values, ...[...refs].map((ref) => ref.display)],\n                            rule: `${type}s`\n                        });\n                    }\n                }\n\n                // Check rules status\n\n                const rules = schema._rules.map((rule) => rule.name);\n                for (const type of ['default', 'failover']) {\n                    if (schema._flags[type] !== undefined) {\n                        rules.push(type);\n                    }\n                }\n\n                for (const name of rules) {\n                    const status = internals.labels[log.rule[name] || 0];\n                    if (status) {\n                        const report = { rule: name, status };\n                        if (log.paths.size) {\n                            report.paths = [...log.paths];\n                        }\n\n                        missing.push(report);\n                    }\n                }\n            }\n\n            if (missing.length) {\n                coverage.push({\n                    filename,\n                    line,\n                    missing,\n                    severity: 'error',\n                    message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`\n                });\n            }\n        }\n\n        return coverage.length ? coverage : null;\n    }\n};\n\n\ninternals.Store = class {\n\n    constructor(schema) {\n\n        this.active = true;\n        this._sources = new Map();          // schema -> { paths, entry, rule, valid, invalid }\n        this._combos = new Map();           // merged -> [sources]\n        this._scan(schema);\n    }\n\n    debug(state, source, name, result) {\n\n        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });\n    }\n\n    entry(schema, state) {\n\n        internals.debug(state, { type: 'entry' });\n\n        this._record(schema, (log) => {\n\n            log.entry = true;\n        });\n    }\n\n    filter(schema, state, source, value) {\n\n        internals.debug(state, { type: source, ...value });\n\n        this._record(schema, (log) => {\n\n            log[source].add(value);\n        });\n    }\n\n    log(schema, state, source, name, result) {\n\n        internals.debug(state, { type: source, name, result: result === 'full' ? 'pass' : result });\n\n        this._record(schema, (log) => {\n\n            log[source][name] = log[source][name] || 0;\n            log[source][name] |= internals.codes[result];\n        });\n    }\n\n    resolve(state, ref, to) {\n\n        if (!state.mainstay.debug) {\n            return;\n        }\n\n        const log = { type: 'resolve', ref: ref.display, to, path: state.path };\n        state.mainstay.debug.push(log);\n    }\n\n    value(state, by, from, to, name) {\n\n        if (!state.mainstay.debug ||\n            DeepEqual(from, to)) {\n\n            return;\n        }\n\n        const log = { type: 'value', by, from, to, path: state.path };\n        if (name) {\n            log.name = name;\n        }\n\n        state.mainstay.debug.push(log);\n    }\n\n    _record(schema, each) {\n\n        const log = this._sources.get(schema);\n        if (log) {\n            each(log);\n            return;\n        }\n\n        const sources = this._combos.get(schema);\n        for (const source of sources) {\n            this._record(source, each);\n        }\n    }\n\n    _scan(schema, _path) {\n\n        const path = _path || [];\n\n        let log = this._sources.get(schema);\n        if (!log) {\n            log = {\n                paths: new Set(),\n                entry: false,\n                rule: {},\n                valid: new Set(),\n                invalid: new Set()\n            };\n\n            this._sources.set(schema, log);\n        }\n\n        if (path.length) {\n            log.paths.add(path);\n        }\n\n        const each = (sub, source) => {\n\n            const subId = internals.id(sub, source);\n            this._scan(sub, path.concat(subId));\n        };\n\n        schema.$_modify({ each, ref: false });\n    }\n\n    _combine(merged, sources) {\n\n        this._combos.set(merged, sources);\n    }\n};\n\n\ninternals.message = function (item) {\n\n    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';\n    return `${path}${item.rule || ''} (${item.status})`;\n};\n\n\ninternals.id = function (schema, { source, name, path, key }) {\n\n    if (schema._flags.id) {\n        return schema._flags.id;\n    }\n\n    if (key) {\n        return key;\n    }\n\n    name = `@${name}`;\n\n    if (source === 'terms') {\n        return [name, path[Math.min(path.length - 1, 1)]];\n    }\n\n    return name;\n};\n\n\ninternals.sub = function (paths, skipped) {\n\n    for (const path of paths) {\n        for (const skip of skipped) {\n            if (DeepEqual(path.slice(0, skip.length), skip)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n\ninternals.debug = function (state, event) {\n\n    if (state.mainstay.debug) {\n        event.path = state.debug ? [...state.path, state.debug] : state.path;\n        state.mainstay.debug.push(event);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}