{"ast":null,"code":"'use strict';\n\nconst ApplyToDefaults = require('@hapi/hoek/lib/applyToDefaults');\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Topo = require('@hapi/topo');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Compile = require('../compile');\n\nconst Errors = require('../errors');\n\nconst Ref = require('../ref');\n\nconst Template = require('../template');\n\nconst internals = {\n  renameDefaults: {\n    alias: false,\n    // Keep old value in place\n    multiple: false,\n    // Allow renaming multiple keys into the same target\n    override: false // Overrides an existing key\n\n  }\n};\nmodule.exports = Any.extend({\n  type: '_keys',\n  properties: {\n    typeof: 'object'\n  },\n  flags: {\n    unknown: {\n      default: false\n    }\n  },\n  terms: {\n    dependencies: {\n      init: null\n    },\n    keys: {\n      init: null,\n      manifest: {\n        mapped: {\n          from: 'schema',\n          to: 'key'\n        }\n      }\n    },\n    patterns: {\n      init: null\n    },\n    renames: {\n      init: null\n    }\n  },\n\n  args(schema, keys) {\n    return schema.keys(keys);\n  },\n\n  validate(value, _ref) {\n    let {\n      schema,\n      error,\n      state,\n      prefs\n    } = _ref;\n\n    if (!value || typeof value !== schema.$_property('typeof') || Array.isArray(value)) {\n      return {\n        value,\n        errors: error('object.base', {\n          type: schema.$_property('typeof')\n        })\n      };\n    } // Skip if there are no other rules to test\n\n\n    if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys\n    !schema.$_terms.patterns && !schema.$_terms.externals) {\n      return;\n    } // Shallow clone value\n\n\n    value = internals.clone(value, prefs);\n    const errors = []; // Rename keys\n\n    if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {\n      return {\n        value,\n        errors\n      };\n    } // Anything allowed\n\n\n    if (!schema.$_terms.keys && // null allows any keys\n    !schema.$_terms.patterns && !schema.$_terms.dependencies) {\n      return {\n        value,\n        errors\n      };\n    } // Defined keys\n\n\n    const unprocessed = new Set(Object.keys(value));\n\n    if (schema.$_terms.keys) {\n      const ancestors = [value, ...state.ancestors];\n\n      for (const child of schema.$_terms.keys) {\n        const key = child.key;\n        const item = value[key];\n        unprocessed.delete(key);\n        const localState = state.localize([...state.path, key], ancestors, child);\n        const result = child.schema.$_validate(item, localState, prefs);\n\n        if (result.errors) {\n          if (prefs.abortEarly) {\n            return {\n              value,\n              errors: result.errors\n            };\n          }\n\n          errors.push(...result.errors);\n        } else if (child.schema._flags.result === 'strip' || result.value === undefined && item !== undefined) {\n          delete value[key];\n        } else if (result.value !== undefined) {\n          value[key] = result.value;\n        }\n      }\n    } // Unknown keys\n\n\n    if (unprocessed.size || schema._flags._hasPatternMatch) {\n      const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);\n\n      if (early) {\n        return early;\n      }\n    } // Validate dependencies\n\n\n    if (schema.$_terms.dependencies) {\n      for (const dep of schema.$_terms.dependencies) {\n        if (dep.key && dep.key.resolve(value, state, prefs, null, {\n          shadow: false\n        }) === undefined) {\n          continue;\n        }\n\n        const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);\n\n        if (failed) {\n          const report = schema.$_createError(failed.code, value, failed.context, state, prefs);\n\n          if (prefs.abortEarly) {\n            return {\n              value,\n              errors: report\n            };\n          }\n\n          errors.push(report);\n        }\n      }\n    }\n\n    return {\n      value,\n      errors\n    };\n  },\n\n  rules: {\n    and: {\n      method() {\n        for (var _len = arguments.length, peers = new Array(_len), _key = 0; _key < _len; _key++) {\n          peers[_key] = arguments[_key];\n        }\n\n        Common.verifyFlat(peers, 'and');\n        return internals.dependency(this, 'and', null, peers);\n      }\n\n    },\n    append: {\n      method(schema) {\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n          return this;\n        }\n\n        return this.keys(schema);\n      }\n\n    },\n    assert: {\n      method(subject, schema, message) {\n        if (!Template.isTemplate(subject)) {\n          subject = Compile.ref(subject);\n        }\n\n        Assert(message === undefined || typeof message === 'string', 'Message must be a string');\n        schema = this.$_compile(schema, {\n          appendPath: true\n        });\n        const obj = this.$_addRule({\n          name: 'assert',\n          args: {\n            subject,\n            schema,\n            message\n          }\n        });\n        obj.$_mutateRegister(subject);\n        obj.$_mutateRegister(schema);\n        return obj;\n      },\n\n      validate(value, _ref2, _ref3) {\n        let {\n          error,\n          prefs,\n          state\n        } = _ref2;\n        let {\n          subject,\n          schema,\n          message\n        } = _ref3;\n        const about = subject.resolve(value, state, prefs);\n        const path = Ref.isRef(subject) ? subject.absolute(state) : [];\n\n        if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {\n          return value;\n        }\n\n        return error('object.assert', {\n          subject,\n          message\n        });\n      },\n\n      args: ['subject', 'schema', 'message'],\n      multi: true\n    },\n    instance: {\n      method(constructor, name) {\n        Assert(typeof constructor === 'function', 'constructor must be a function');\n        name = name || constructor.name;\n        return this.$_addRule({\n          name: 'instance',\n          args: {\n            constructor,\n            name\n          }\n        });\n      },\n\n      validate(value, helpers, _ref4) {\n        let {\n          constructor,\n          name\n        } = _ref4;\n\n        if (value instanceof constructor) {\n          return value;\n        }\n\n        return helpers.error('object.instance', {\n          type: name,\n          value\n        });\n      },\n\n      args: ['constructor', 'name']\n    },\n    keys: {\n      method(schema) {\n        Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');\n        const obj = this.clone();\n\n        if (!schema) {\n          // Allow all\n          obj.$_terms.keys = null;\n        } else if (!Object.keys(schema).length) {\n          // Allow none\n          obj.$_terms.keys = new internals.Keys();\n        } else {\n          obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter(child => !schema.hasOwnProperty(child.key)) : new internals.Keys();\n\n          for (const key in schema) {\n            Common.tryWithPath(() => obj.$_terms.keys.push({\n              key,\n              schema: this.$_compile(schema[key])\n            }), key);\n          }\n        }\n\n        return obj.$_mutateRebuild();\n      }\n\n    },\n    length: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'length',\n          args: {\n            limit\n          },\n          operator: '='\n        });\n      },\n\n      validate(value, helpers, _ref5, _ref6) {\n        let {\n          limit\n        } = _ref5;\n        let {\n          name,\n          operator,\n          args\n        } = _ref6;\n\n        if (Common.compare(Object.keys(value).length, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('object.' + name, {\n          limit: args.limit,\n          value\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.limit,\n        message: 'must be a positive integer'\n      }]\n    },\n    max: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'max',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '<='\n        });\n      }\n\n    },\n    min: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'min',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '>='\n        });\n      }\n\n    },\n    nand: {\n      method() {\n        for (var _len2 = arguments.length, peers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          peers[_key2] = arguments[_key2];\n        }\n\n        Common.verifyFlat(peers, 'nand');\n        return internals.dependency(this, 'nand', null, peers);\n      }\n\n    },\n    or: {\n      method() {\n        for (var _len3 = arguments.length, peers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          peers[_key3] = arguments[_key3];\n        }\n\n        Common.verifyFlat(peers, 'or');\n        return internals.dependency(this, 'or', null, peers);\n      }\n\n    },\n    oxor: {\n      method() {\n        for (var _len4 = arguments.length, peers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          peers[_key4] = arguments[_key4];\n        }\n\n        return internals.dependency(this, 'oxor', null, peers);\n      }\n\n    },\n    pattern: {\n      method(pattern, schema) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        const isRegExp = pattern instanceof RegExp;\n\n        if (!isRegExp) {\n          pattern = this.$_compile(pattern, {\n            appendPath: true\n          });\n        }\n\n        Assert(schema !== undefined, 'Invalid rule');\n        Common.assertOptions(options, ['fallthrough', 'matches']);\n\n        if (isRegExp) {\n          Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n        }\n\n        schema = this.$_compile(schema, {\n          appendPath: true\n        });\n        const obj = this.clone();\n        obj.$_terms.patterns = obj.$_terms.patterns || [];\n        const config = {\n          [isRegExp ? 'regex' : 'schema']: pattern,\n          rule: schema\n        };\n\n        if (options.matches) {\n          config.matches = this.$_compile(options.matches);\n\n          if (config.matches.type !== 'array') {\n            config.matches = config.matches.$_root.array().items(config.matches);\n          }\n\n          obj.$_mutateRegister(config.matches);\n          obj.$_setFlag('_hasPatternMatch', true, {\n            clone: false\n          });\n        }\n\n        if (options.fallthrough) {\n          config.fallthrough = true;\n        }\n\n        obj.$_terms.patterns.push(config);\n        obj.$_mutateRegister(schema);\n        return obj;\n      }\n\n    },\n    ref: {\n      method() {\n        return this.$_addRule('ref');\n      },\n\n      validate(value, helpers) {\n        if (Ref.isRef(value)) {\n          return value;\n        }\n\n        return helpers.error('object.refType', {\n          value\n        });\n      }\n\n    },\n    regex: {\n      method() {\n        return this.$_addRule('regex');\n      },\n\n      validate(value, helpers) {\n        if (value instanceof RegExp) {\n          return value;\n        }\n\n        return helpers.error('object.regex', {\n          value\n        });\n      }\n\n    },\n    rename: {\n      method(from, to) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n        Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');\n        Assert(to !== from, 'Cannot rename key to same name:', from);\n        Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);\n        const obj = this.clone();\n        obj.$_terms.renames = obj.$_terms.renames || [];\n\n        for (const rename of obj.$_terms.renames) {\n          Assert(rename.from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        if (to instanceof Template) {\n          obj.$_mutateRegister(to);\n        }\n\n        obj.$_terms.renames.push({\n          from,\n          to,\n          options: ApplyToDefaults(internals.renameDefaults, options)\n        });\n        return obj;\n      }\n\n    },\n    schema: {\n      method() {\n        let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'any';\n        return this.$_addRule({\n          name: 'schema',\n          args: {\n            type\n          }\n        });\n      },\n\n      validate(value, helpers, _ref7) {\n        let {\n          type\n        } = _ref7;\n\n        if (Common.isSchema(value) && (type === 'any' || value.type === type)) {\n          return value;\n        }\n\n        return helpers.error('object.schema', {\n          type\n        });\n      }\n\n    },\n    unknown: {\n      method(allow) {\n        return this.$_setFlag('unknown', allow !== false);\n      }\n\n    },\n    with: {\n      method(key, peers) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return internals.dependency(this, 'with', key, peers, options);\n      }\n\n    },\n    without: {\n      method(key, peers) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return internals.dependency(this, 'without', key, peers, options);\n      }\n\n    },\n    xor: {\n      method() {\n        for (var _len5 = arguments.length, peers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          peers[_key5] = arguments[_key5];\n        }\n\n        Common.verifyFlat(peers, 'xor');\n        return internals.dependency(this, 'xor', null, peers);\n      }\n\n    }\n  },\n  overrides: {\n    default(value, options) {\n      if (value === undefined) {\n        value = Common.symbols.deepDefault;\n      }\n\n      return this.$_super.default(value, options);\n    }\n\n  },\n\n  rebuild(schema) {\n    if (schema.$_terms.keys) {\n      const topo = new Topo.Sorter();\n\n      for (const child of schema.$_terms.keys) {\n        Common.tryWithPath(() => topo.add(child, {\n          after: child.schema.$_rootReferences(),\n          group: child.key\n        }), child.key);\n      }\n\n      schema.$_terms.keys = new internals.Keys(...topo.nodes);\n    }\n  },\n\n  manifest: {\n    build(obj, desc) {\n      if (desc.keys) {\n        obj = obj.keys(desc.keys);\n      }\n\n      if (desc.dependencies) {\n        for (const {\n          rel,\n          key = null,\n          peers,\n          options\n        } of desc.dependencies) {\n          obj = internals.dependency(obj, rel, key, peers, options);\n        }\n      }\n\n      if (desc.patterns) {\n        for (const {\n          regex,\n          schema,\n          rule,\n          fallthrough,\n          matches\n        } of desc.patterns) {\n          obj = obj.pattern(regex || schema, rule, {\n            fallthrough,\n            matches\n          });\n        }\n      }\n\n      if (desc.renames) {\n        for (const {\n          from,\n          to,\n          options\n        } of desc.renames) {\n          obj = obj.rename(from, to, options);\n        }\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'object.and': '{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',\n    'object.assert': '{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}',\n    'object.base': '{{#label}} must be of type {{#type}}',\n    'object.instance': '{{#label}} must be an instance of \"{{#type}}\"',\n    'object.length': '{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n    'object.max': '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n    'object.min': '{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n    'object.missing': '{{#label}} must contain at least one of {{#peersWithLabels}}',\n    'object.nand': '\"{{#mainWithLabel}}\" must not exist simultaneously with {{#peersWithLabels}}',\n    'object.oxor': '{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}',\n    'object.pattern.match': '{{#label}} keys failed to match pattern requirements',\n    'object.refType': '{{#label}} must be a Joi reference',\n    'object.regex': '{{#label}} must be a RegExp object',\n    'object.rename.multiple': '{{#label}} cannot rename \"{{#from}}\" because multiple renames are disabled and another key was already renamed to \"{{#to}}\"',\n    'object.rename.override': '{{#label}} cannot rename \"{{#from}}\" because override is disabled and target \"{{#to}}\" exists',\n    'object.schema': '{{#label}} must be a Joi schema of {{#type}} type',\n    'object.unknown': '{{#label}} is not allowed',\n    'object.with': '\"{{#mainWithLabel}}\" missing required peer \"{{#peerWithLabel}}\"',\n    'object.without': '\"{{#mainWithLabel}}\" conflict with forbidden peer \"{{#peerWithLabel}}\"',\n    'object.xor': '{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}'\n  }\n}); // Helpers\n\ninternals.clone = function (value, prefs) {\n  // Object\n  if (typeof value === 'object') {\n    if (prefs.nonEnumerables) {\n      return Clone(value, {\n        shallow: true\n      });\n    }\n\n    const clone = Object.create(Object.getPrototypeOf(value));\n    Object.assign(clone, value);\n    return clone;\n  } // Function\n\n\n  const clone = function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    return value.apply(this, args);\n  };\n\n  clone.prototype = Clone(value.prototype);\n  Object.defineProperty(clone, 'name', {\n    value: value.name,\n    writable: false\n  });\n  Object.defineProperty(clone, 'length', {\n    value: value.length,\n    writable: false\n  });\n  Object.assign(clone, value);\n  return clone;\n};\n\ninternals.dependency = function (schema, rel, key, peers, options) {\n  Assert(key === null || typeof key === 'string', rel, 'key must be a strings'); // Extract options from peers array\n\n  if (!options) {\n    options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};\n  }\n\n  Common.assertOptions(options, ['separator']);\n  peers = [].concat(peers); // Cast peer paths\n\n  const separator = Common.default(options.separator, '.');\n  const paths = [];\n\n  for (const peer of peers) {\n    Assert(typeof peer === 'string', rel, 'peers must be a string or a reference');\n    paths.push(Compile.ref(peer, {\n      separator,\n      ancestor: 0,\n      prefix: false\n    }));\n  } // Cast key\n\n\n  if (key !== null) {\n    key = Compile.ref(key, {\n      separator,\n      ancestor: 0,\n      prefix: false\n    });\n  } // Add rule\n\n\n  const obj = schema.clone();\n  obj.$_terms.dependencies = obj.$_terms.dependencies || [];\n  obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));\n  return obj;\n};\n\ninternals.dependencies = {\n  and(schema, dep, value, state, prefs) {\n    const missing = [];\n    const present = [];\n    const count = dep.peers.length;\n\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) === undefined) {\n        missing.push(peer.key);\n      } else {\n        present.push(peer.key);\n      }\n    }\n\n    if (missing.length !== count && present.length !== count) {\n      return {\n        code: 'object.and',\n        context: {\n          present,\n          presentWithLabels: internals.keysToLabels(schema, present),\n          missing,\n          missingWithLabels: internals.keysToLabels(schema, missing)\n        }\n      };\n    }\n  },\n\n  nand(schema, dep, value, state, prefs) {\n    const present = [];\n\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        present.push(peer.key);\n      }\n    }\n\n    if (present.length !== dep.peers.length) {\n      return;\n    }\n\n    const main = dep.paths[0];\n    const values = dep.paths.slice(1);\n    return {\n      code: 'object.nand',\n      context: {\n        main,\n        mainWithLabel: internals.keysToLabels(schema, main),\n        peers: values,\n        peersWithLabels: internals.keysToLabels(schema, values)\n      }\n    };\n  },\n\n  or(schema, dep, value, state, prefs) {\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        return;\n      }\n    }\n\n    return {\n      code: 'object.missing',\n      context: {\n        peers: dep.paths,\n        peersWithLabels: internals.keysToLabels(schema, dep.paths)\n      }\n    };\n  },\n\n  oxor(schema, dep, value, state, prefs) {\n    const present = [];\n\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        present.push(peer.key);\n      }\n    }\n\n    if (!present.length || present.length === 1) {\n      return;\n    }\n\n    const context = {\n      peers: dep.paths,\n      peersWithLabels: internals.keysToLabels(schema, dep.paths)\n    };\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(schema, present);\n    return {\n      code: 'object.oxor',\n      context\n    };\n  },\n\n  with(schema, dep, value, state, prefs) {\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) === undefined) {\n        return {\n          code: 'object.with',\n          context: {\n            main: dep.key.key,\n            mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n            peer: peer.key,\n            peerWithLabel: internals.keysToLabels(schema, peer.key)\n          }\n        };\n      }\n    }\n  },\n\n  without(schema, dep, value, state, prefs) {\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        return {\n          code: 'object.without',\n          context: {\n            main: dep.key.key,\n            mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n            peer: peer.key,\n            peerWithLabel: internals.keysToLabels(schema, peer.key)\n          }\n        };\n      }\n    }\n  },\n\n  xor(schema, dep, value, state, prefs) {\n    const present = [];\n\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        present.push(peer.key);\n      }\n    }\n\n    if (present.length === 1) {\n      return;\n    }\n\n    const context = {\n      peers: dep.paths,\n      peersWithLabels: internals.keysToLabels(schema, dep.paths)\n    };\n\n    if (present.length === 0) {\n      return {\n        code: 'object.missing',\n        context\n      };\n    }\n\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(schema, present);\n    return {\n      code: 'object.xor',\n      context\n    };\n  }\n\n};\n\ninternals.keysToLabels = function (schema, keys) {\n  if (Array.isArray(keys)) {\n    return keys.map(key => schema.$_mapLabels(key));\n  }\n\n  return schema.$_mapLabels(keys);\n};\n\ninternals.rename = function (schema, value, state, prefs, errors) {\n  const renamed = {};\n\n  for (const rename of schema.$_terms.renames) {\n    const matches = [];\n    const pattern = typeof rename.from !== 'string';\n\n    if (!pattern) {\n      if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {\n        matches.push(rename);\n      }\n    } else {\n      for (const from in value) {\n        if (value[from] === undefined && rename.options.ignoreUndefined) {\n          continue;\n        }\n\n        if (from === rename.to) {\n          continue;\n        }\n\n        const match = rename.from.exec(from);\n\n        if (!match) {\n          continue;\n        }\n\n        matches.push({\n          from,\n          to: rename.to,\n          match\n        });\n      }\n    }\n\n    for (const match of matches) {\n      const from = match.from;\n      let to = match.to;\n\n      if (to instanceof Template) {\n        to = to.render(value, state, prefs, match.match);\n      }\n\n      if (from === to) {\n        continue;\n      }\n\n      if (!rename.options.multiple && renamed[to]) {\n        errors.push(schema.$_createError('object.rename.multiple', value, {\n          from,\n          to,\n          pattern\n        }, state, prefs));\n\n        if (prefs.abortEarly) {\n          return false;\n        }\n      }\n\n      if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {\n        errors.push(schema.$_createError('object.rename.override', value, {\n          from,\n          to,\n          pattern\n        }, state, prefs));\n\n        if (prefs.abortEarly) {\n          return false;\n        }\n      }\n\n      if (value[from] === undefined) {\n        delete value[to];\n      } else {\n        value[to] = value[from];\n      }\n\n      renamed[to] = true;\n\n      if (!rename.options.alias) {\n        delete value[from];\n      }\n    }\n  }\n\n  return true;\n};\n\ninternals.unknown = function (schema, value, unprocessed, errors, state, prefs) {\n  if (schema.$_terms.patterns) {\n    let hasMatches = false;\n    const matches = schema.$_terms.patterns.map(pattern => {\n      if (pattern.matches) {\n        hasMatches = true;\n        return [];\n      }\n    });\n    const ancestors = [value, ...state.ancestors];\n\n    for (const key of unprocessed) {\n      const item = value[key];\n      const path = [...state.path, key];\n\n      for (let i = 0; i < schema.$_terms.patterns.length; ++i) {\n        const pattern = schema.$_terms.patterns[i];\n\n        if (pattern.regex) {\n          const match = pattern.regex.test(key);\n          state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');\n\n          if (!match) {\n            continue;\n          }\n        } else {\n          if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {\n            continue;\n          }\n        }\n\n        unprocessed.delete(key);\n        const localState = state.localize(path, ancestors, {\n          schema: pattern.rule,\n          key\n        });\n        const result = pattern.rule.$_validate(item, localState, prefs);\n\n        if (result.errors) {\n          if (prefs.abortEarly) {\n            return {\n              value,\n              errors: result.errors\n            };\n          }\n\n          errors.push(...result.errors);\n        }\n\n        if (pattern.matches) {\n          matches[i].push(key);\n        }\n\n        value[key] = result.value;\n\n        if (!pattern.fallthrough) {\n          break;\n        }\n      }\n    } // Validate pattern matches rules\n\n\n    if (hasMatches) {\n      for (let i = 0; i < matches.length; ++i) {\n        const match = matches[i];\n\n        if (!match) {\n          continue;\n        }\n\n        const stpm = schema.$_terms.patterns[i].matches;\n        const localState = state.localize(state.path, ancestors, stpm);\n        const result = stpm.$_validate(match, localState, prefs);\n\n        if (result.errors) {\n          const details = Errors.details(result.errors, {\n            override: false\n          });\n          details.matches = match;\n          const report = schema.$_createError('object.pattern.match', value, details, state, prefs);\n\n          if (prefs.abortEarly) {\n            return {\n              value,\n              errors: report\n            };\n          }\n\n          errors.push(report);\n        }\n      }\n    }\n  }\n\n  if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {\n    // If no keys or patterns specified, unknown keys allowed\n    return;\n  }\n\n  if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {\n    const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;\n\n    for (const key of unprocessed) {\n      if (stripUnknown) {\n        delete value[key];\n        unprocessed.delete(key);\n      } else if (typeof value[key] === 'function') {\n        unprocessed.delete(key);\n      }\n    }\n  }\n\n  const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);\n\n  if (forbidUnknown) {\n    for (const unprocessedKey of unprocessed) {\n      const localState = state.localize([...state.path, unprocessedKey], []);\n      const report = schema.$_createError('object.unknown', value[unprocessedKey], {\n        child: unprocessedKey\n      }, localState, prefs, {\n        flags: false\n      });\n\n      if (prefs.abortEarly) {\n        return {\n          value,\n          errors: report\n        };\n      }\n\n      errors.push(report);\n    }\n  }\n};\n\ninternals.Dependency = class {\n  constructor(rel, key, peers, paths) {\n    this.rel = rel;\n    this.key = key;\n    this.peers = peers;\n    this.paths = paths;\n  }\n\n  describe() {\n    const desc = {\n      rel: this.rel,\n      peers: this.paths\n    };\n\n    if (this.key !== null) {\n      desc.key = this.key.key;\n    }\n\n    if (this.peers[0].separator !== '.') {\n      desc.options = {\n        separator: this.peers[0].separator\n      };\n    }\n\n    return desc;\n  }\n\n};\ninternals.Keys = class extends Array {\n  concat(source) {\n    const result = this.slice();\n    const keys = new Map();\n\n    for (let i = 0; i < result.length; ++i) {\n      keys.set(result[i].key, i);\n    }\n\n    for (const item of source) {\n      const key = item.key;\n      const pos = keys.get(key);\n\n      if (pos !== undefined) {\n        result[pos] = {\n          key,\n          schema: result[pos].schema.concat(item.schema)\n        };\n      } else {\n        result.push(item);\n      }\n    }\n\n    return result;\n  }\n\n};","map":{"version":3,"names":["ApplyToDefaults","require","Assert","Clone","Topo","Any","Common","Compile","Errors","Ref","Template","internals","renameDefaults","alias","multiple","override","module","exports","extend","type","properties","typeof","flags","unknown","default","terms","dependencies","init","keys","manifest","mapped","from","to","patterns","renames","args","schema","validate","value","error","state","prefs","$_property","Array","isArray","errors","$_terms","externals","clone","rename","unprocessed","Set","Object","ancestors","child","key","item","delete","localState","localize","path","result","$_validate","abortEarly","push","_flags","undefined","size","_hasPatternMatch","early","dep","resolve","shadow","failed","rel","report","$_createError","code","context","rules","and","method","peers","verifyFlat","dependency","append","length","assert","subject","message","isTemplate","ref","$_compile","appendPath","obj","$_addRule","name","$_mutateRegister","about","isRef","absolute","$_match","multi","instance","constructor","helpers","isSchema","Keys","filter","hasOwnProperty","tryWithPath","$_mutateRebuild","limit","operator","compare","max","min","nand","or","oxor","pattern","options","isRegExp","RegExp","assertOptions","includes","config","rule","matches","$_root","array","items","$_setFlag","fallthrough","regex","allow","with","without","xor","overrides","symbols","deepDefault","$_super","rebuild","topo","Sorter","add","after","$_rootReferences","group","nodes","build","desc","messages","nonEnumerables","shallow","create","getPrototypeOf","assign","apply","prototype","defineProperty","writable","pop","concat","separator","paths","peer","ancestor","prefix","Dependency","missing","present","count","presentWithLabels","keysToLabels","missingWithLabels","main","values","slice","mainWithLabel","peersWithLabels","peerWithLabel","map","$_mapLabels","renamed","call","ignoreUndefined","match","exec","render","hasMatches","i","test","mainstay","tracer","debug","nest","stpm","details","stripUnknown","skipFunctions","objects","forbidUnknown","allowUnknown","unprocessedKey","describe","source","Map","set","pos","get"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/types/keys.js"],"sourcesContent":["'use strict';\n\nconst ApplyToDefaults = require('@hapi/hoek/lib/applyToDefaults');\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst Topo = require('@hapi/topo');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Compile = require('../compile');\nconst Errors = require('../errors');\nconst Ref = require('../ref');\nconst Template = require('../template');\n\n\nconst internals = {\n    renameDefaults: {\n        alias: false,                   // Keep old value in place\n        multiple: false,                // Allow renaming multiple keys into the same target\n        override: false                 // Overrides an existing key\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: '_keys',\n\n    properties: {\n        typeof: 'object'\n    },\n\n    flags: {\n\n        unknown: { default: false }\n    },\n\n    terms: {\n\n        dependencies: { init: null },\n        keys: { init: null, manifest: { mapped: { from: 'schema', to: 'key' } } },\n        patterns: { init: null },\n        renames: { init: null }\n    },\n\n    args(schema, keys) {\n\n        return schema.keys(keys);\n    },\n\n    validate(value, { schema, error, state, prefs }) {\n\n        if (!value ||\n            typeof value !== schema.$_property('typeof') ||\n            Array.isArray(value)) {\n\n            return { value, errors: error('object.base', { type: schema.$_property('typeof') }) };\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!schema.$_terms.renames &&\n            !schema.$_terms.dependencies &&\n            !schema.$_terms.keys &&                       // null allows any keys\n            !schema.$_terms.patterns &&\n            !schema.$_terms.externals) {\n\n            return;\n        }\n\n        // Shallow clone value\n\n        value = internals.clone(value, prefs);\n        const errors = [];\n\n        // Rename keys\n\n        if (schema.$_terms.renames &&\n            !internals.rename(schema, value, state, prefs, errors)) {\n\n            return { value, errors };\n        }\n\n        // Anything allowed\n\n        if (!schema.$_terms.keys &&                       // null allows any keys\n            !schema.$_terms.patterns &&\n            !schema.$_terms.dependencies) {\n\n            return { value, errors };\n        }\n\n        // Defined keys\n\n        const unprocessed = new Set(Object.keys(value));\n\n        if (schema.$_terms.keys) {\n            const ancestors = [value, ...state.ancestors];\n\n            for (const child of schema.$_terms.keys) {\n                const key = child.key;\n                const item = value[key];\n\n                unprocessed.delete(key);\n\n                const localState = state.localize([...state.path, key], ancestors, child);\n                const result = child.schema.$_validate(item, localState, prefs);\n\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return { value, errors: result.errors };\n                    }\n\n                    errors.push(...result.errors);\n                }\n                else if (child.schema._flags.result === 'strip' ||\n                    result.value === undefined && item !== undefined) {\n\n                    delete value[key];\n                }\n                else if (result.value !== undefined) {\n                    value[key] = result.value;\n                }\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size ||\n            schema._flags._hasPatternMatch) {\n\n            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);\n            if (early) {\n                return early;\n            }\n        }\n\n        // Validate dependencies\n\n        if (schema.$_terms.dependencies) {\n            for (const dep of schema.$_terms.dependencies) {\n                if (dep.key &&\n                    dep.key.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n\n                    continue;\n                }\n\n                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);\n                if (failed) {\n                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);\n                    if (prefs.abortEarly) {\n                        return { value, errors: report };\n                    }\n\n                    errors.push(report);\n                }\n            }\n        }\n\n        return { value, errors };\n    },\n\n    rules: {\n\n        and: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'and');\n\n                return internals.dependency(this, 'and', null, peers);\n            }\n        },\n\n        append: {\n            method(schema) {\n\n                if (schema === null ||\n                    schema === undefined ||\n                    Object.keys(schema).length === 0) {\n\n                    return this;\n                }\n\n                return this.keys(schema);\n            }\n        },\n\n        assert: {\n            method(subject, schema, message) {\n\n                if (!Template.isTemplate(subject)) {\n                    subject = Compile.ref(subject);\n                }\n\n                Assert(message === undefined || typeof message === 'string', 'Message must be a string');\n\n                schema = this.$_compile(schema, { appendPath: true });\n\n                const obj = this.$_addRule({ name: 'assert', args: { subject, schema, message } });\n                obj.$_mutateRegister(subject);\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate(value, { error, prefs, state }, { subject, schema, message }) {\n\n                const about = subject.resolve(value, state, prefs);\n                const path = Ref.isRef(subject) ? subject.absolute(state) : [];\n                if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {\n                    return value;\n                }\n\n                return error('object.assert', { subject, message });\n            },\n            args: ['subject', 'schema', 'message'],\n            multi: true\n        },\n\n        instance: {\n            method(constructor, name) {\n\n                Assert(typeof constructor === 'function', 'constructor must be a function');\n\n                name = name || constructor.name;\n\n                return this.$_addRule({ name: 'instance', args: { constructor, name } });\n            },\n            validate(value, helpers, { constructor, name }) {\n\n                if (value instanceof constructor) {\n                    return value;\n                }\n\n                return helpers.error('object.instance', { type: name, value });\n            },\n            args: ['constructor', 'name']\n        },\n\n        keys: {\n            method(schema) {\n\n                Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n                Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');\n\n                const obj = this.clone();\n\n                if (!schema) {                                      // Allow all\n                    obj.$_terms.keys = null;\n                }\n                else if (!Object.keys(schema).length) {             // Allow none\n                    obj.$_terms.keys = new internals.Keys();\n                }\n                else {\n                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();\n                    for (const key in schema) {\n                        Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);\n                    }\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(Object.keys(value).length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('object.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        },\n\n        nand: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'nand');\n\n                return internals.dependency(this, 'nand', null, peers);\n            }\n        },\n\n        or: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'or');\n\n                return internals.dependency(this, 'or', null, peers);\n            }\n        },\n\n        oxor: {\n            method(...peers /*, [options] */) {\n\n                return internals.dependency(this, 'oxor', null, peers);\n            }\n        },\n\n        pattern: {\n            method(pattern, schema, options = {}) {\n\n                const isRegExp = pattern instanceof RegExp;\n                if (!isRegExp) {\n                    pattern = this.$_compile(pattern, { appendPath: true });\n                }\n\n                Assert(schema !== undefined, 'Invalid rule');\n                Common.assertOptions(options, ['fallthrough', 'matches']);\n\n                if (isRegExp) {\n                    Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n                }\n\n                schema = this.$_compile(schema, { appendPath: true });\n\n                const obj = this.clone();\n                obj.$_terms.patterns = obj.$_terms.patterns || [];\n                const config = { [isRegExp ? 'regex' : 'schema']: pattern, rule: schema };\n                if (options.matches) {\n                    config.matches = this.$_compile(options.matches);\n                    if (config.matches.type !== 'array') {\n                        config.matches = config.matches.$_root.array().items(config.matches);\n                    }\n\n                    obj.$_mutateRegister(config.matches);\n                    obj.$_setFlag('_hasPatternMatch', true, { clone: false });\n                }\n\n                if (options.fallthrough) {\n                    config.fallthrough = true;\n                }\n\n                obj.$_terms.patterns.push(config);\n                obj.$_mutateRegister(schema);\n                return obj;\n            }\n        },\n\n        ref: {\n            method() {\n\n                return this.$_addRule('ref');\n            },\n            validate(value, helpers) {\n\n                if (Ref.isRef(value)) {\n                    return value;\n                }\n\n                return helpers.error('object.refType', { value });\n            }\n        },\n\n        regex: {\n            method() {\n\n                return this.$_addRule('regex');\n            },\n            validate(value, helpers) {\n\n                if (value instanceof RegExp) {\n                    return value;\n                }\n\n                return helpers.error('object.regex', { value });\n            }\n        },\n\n        rename: {\n            method(from, to, options = {}) {\n\n                Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n                Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');\n                Assert(to !== from, 'Cannot rename key to same name:', from);\n\n                Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);\n\n                const obj = this.clone();\n\n                obj.$_terms.renames = obj.$_terms.renames || [];\n                for (const rename of obj.$_terms.renames) {\n                    Assert(rename.from !== from, 'Cannot rename the same key multiple times');\n                }\n\n                if (to instanceof Template) {\n                    obj.$_mutateRegister(to);\n                }\n\n                obj.$_terms.renames.push({\n                    from,\n                    to,\n                    options: ApplyToDefaults(internals.renameDefaults, options)\n                });\n\n                return obj;\n            }\n        },\n\n        schema: {\n            method(type = 'any') {\n\n                return this.$_addRule({ name: 'schema', args: { type } });\n            },\n            validate(value, helpers, { type }) {\n\n                if (Common.isSchema(value) &&\n                    (type === 'any' || value.type === type)) {\n\n                    return value;\n                }\n\n                return helpers.error('object.schema', { type });\n            }\n        },\n\n        unknown: {\n            method(allow) {\n\n                return this.$_setFlag('unknown', allow !== false);\n            }\n        },\n\n        with: {\n            method(key, peers, options = {}) {\n\n                return internals.dependency(this, 'with', key, peers, options);\n            }\n        },\n\n        without: {\n            method(key, peers, options = {}) {\n\n                return internals.dependency(this, 'without', key, peers, options);\n            }\n        },\n\n        xor: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'xor');\n\n                return internals.dependency(this, 'xor', null, peers);\n            }\n        }\n    },\n\n    overrides: {\n\n        default(value, options) {\n\n            if (value === undefined) {\n                value = Common.symbols.deepDefault;\n            }\n\n            return this.$_super.default(value, options);\n        }\n    },\n\n    rebuild(schema) {\n\n        if (schema.$_terms.keys) {\n            const topo = new Topo.Sorter();\n            for (const child of schema.$_terms.keys) {\n                Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);\n            }\n\n            schema.$_terms.keys = new internals.Keys(...topo.nodes);\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.keys) {\n                obj = obj.keys(desc.keys);\n            }\n\n            if (desc.dependencies) {\n                for (const { rel, key = null, peers, options } of desc.dependencies) {\n                    obj = internals.dependency(obj, rel, key, peers, options);\n                }\n            }\n\n            if (desc.patterns) {\n                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {\n                    obj = obj.pattern(regex || schema, rule, { fallthrough, matches });\n                }\n            }\n\n            if (desc.renames) {\n                for (const { from, to, options } of desc.renames) {\n                    obj = obj.rename(from, to, options);\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'object.and': '{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',\n        'object.assert': '{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}',\n        'object.base': '{{#label}} must be of type {{#type}}',\n        'object.instance': '{{#label}} must be an instance of \"{{#type}}\"',\n        'object.length': '{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.max': '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.min': '{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.missing': '{{#label}} must contain at least one of {{#peersWithLabels}}',\n        'object.nand': '\"{{#mainWithLabel}}\" must not exist simultaneously with {{#peersWithLabels}}',\n        'object.oxor': '{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}',\n        'object.pattern.match': '{{#label}} keys failed to match pattern requirements',\n        'object.refType': '{{#label}} must be a Joi reference',\n        'object.regex': '{{#label}} must be a RegExp object',\n        'object.rename.multiple': '{{#label}} cannot rename \"{{#from}}\" because multiple renames are disabled and another key was already renamed to \"{{#to}}\"',\n        'object.rename.override': '{{#label}} cannot rename \"{{#from}}\" because override is disabled and target \"{{#to}}\" exists',\n        'object.schema': '{{#label}} must be a Joi schema of {{#type}} type',\n        'object.unknown': '{{#label}} is not allowed',\n        'object.with': '\"{{#mainWithLabel}}\" missing required peer \"{{#peerWithLabel}}\"',\n        'object.without': '\"{{#mainWithLabel}}\" conflict with forbidden peer \"{{#peerWithLabel}}\"',\n        'object.xor': '{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}'\n    }\n});\n\n\n// Helpers\n\ninternals.clone = function (value, prefs) {\n\n    // Object\n\n    if (typeof value === 'object') {\n        if (prefs.nonEnumerables) {\n            return Clone(value, { shallow: true });\n        }\n\n        const clone = Object.create(Object.getPrototypeOf(value));\n        Object.assign(clone, value);\n        return clone;\n    }\n\n    // Function\n\n    const clone = function (...args) {\n\n        return value.apply(this, args);\n    };\n\n    clone.prototype = Clone(value.prototype);\n    Object.defineProperty(clone, 'name', { value: value.name, writable: false });\n    Object.defineProperty(clone, 'length', { value: value.length, writable: false });\n    Object.assign(clone, value);\n    return clone;\n};\n\n\ninternals.dependency = function (schema, rel, key, peers, options) {\n\n    Assert(key === null || typeof key === 'string', rel, 'key must be a strings');\n\n    // Extract options from peers array\n\n    if (!options) {\n        options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};\n    }\n\n    Common.assertOptions(options, ['separator']);\n\n    peers = [].concat(peers);\n\n    // Cast peer paths\n\n    const separator = Common.default(options.separator, '.');\n    const paths = [];\n    for (const peer of peers) {\n        Assert(typeof peer === 'string', rel, 'peers must be a string or a reference');\n        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));\n    }\n\n    // Cast key\n\n    if (key !== null) {\n        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });\n    }\n\n    // Add rule\n\n    const obj = schema.clone();\n    obj.$_terms.dependencies = obj.$_terms.dependencies || [];\n    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));\n    return obj;\n};\n\n\ninternals.dependencies = {\n\n    and(schema, dep, value, state, prefs) {\n\n        const missing = [];\n        const present = [];\n        const count = dep.peers.length;\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n                missing.push(peer.key);\n            }\n            else {\n                present.push(peer.key);\n            }\n        }\n\n        if (missing.length !== count &&\n            present.length !== count) {\n\n            return {\n                code: 'object.and',\n                context: {\n                    present,\n                    presentWithLabels: internals.keysToLabels(schema, present),\n                    missing,\n                    missingWithLabels: internals.keysToLabels(schema, missing)\n                }\n            };\n        }\n    },\n\n    nand(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (present.length !== dep.peers.length) {\n            return;\n        }\n\n        const main = dep.paths[0];\n        const values = dep.paths.slice(1);\n        return {\n            code: 'object.nand',\n            context: {\n                main,\n                mainWithLabel: internals.keysToLabels(schema, main),\n                peers: values,\n                peersWithLabels: internals.keysToLabels(schema, values)\n            }\n        };\n    },\n\n    or(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                return;\n            }\n        }\n\n        return {\n            code: 'object.missing',\n            context: {\n                peers: dep.paths,\n                peersWithLabels: internals.keysToLabels(schema, dep.paths)\n            }\n        };\n    },\n\n    oxor(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (!present.length ||\n            present.length === 1) {\n\n            return;\n        }\n\n        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return { code: 'object.oxor', context };\n    },\n\n    with(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n                return {\n                    code: 'object.with',\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n\n    without(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                return {\n                    code: 'object.without',\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n\n    xor(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (present.length === 1) {\n            return;\n        }\n\n        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };\n        if (present.length === 0) {\n            return { code: 'object.missing', context };\n        }\n\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return { code: 'object.xor', context };\n    }\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    if (Array.isArray(keys)) {\n        return keys.map((key) => schema.$_mapLabels(key));\n    }\n\n    return schema.$_mapLabels(keys);\n};\n\n\ninternals.rename = function (schema, value, state, prefs, errors) {\n\n    const renamed = {};\n    for (const rename of schema.$_terms.renames) {\n        const matches = [];\n        const pattern = typeof rename.from !== 'string';\n\n        if (!pattern) {\n            if (Object.prototype.hasOwnProperty.call(value, rename.from) &&\n                (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {\n\n                matches.push(rename);\n            }\n        }\n        else {\n            for (const from in value) {\n                if (value[from] === undefined &&\n                    rename.options.ignoreUndefined) {\n\n                    continue;\n                }\n\n                if (from === rename.to) {\n                    continue;\n                }\n\n                const match = rename.from.exec(from);\n                if (!match) {\n                    continue;\n                }\n\n                matches.push({ from, to: rename.to, match });\n            }\n        }\n\n        for (const match of matches) {\n            const from = match.from;\n            let to = match.to;\n            if (to instanceof Template) {\n                to = to.render(value, state, prefs, match.match);\n            }\n\n            if (from === to) {\n                continue;\n            }\n\n            if (!rename.options.multiple &&\n                renamed[to]) {\n\n                errors.push(schema.$_createError('object.rename.multiple', value, { from, to, pattern }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n\n            if (Object.prototype.hasOwnProperty.call(value, to) &&\n                !rename.options.override &&\n                !renamed[to]) {\n\n                errors.push(schema.$_createError('object.rename.override', value, { from, to, pattern }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n\n            if (value[from] === undefined) {\n                delete value[to];\n            }\n            else {\n                value[to] = value[from];\n            }\n\n            renamed[to] = true;\n\n            if (!rename.options.alias) {\n                delete value[from];\n            }\n        }\n    }\n\n    return true;\n};\n\n\ninternals.unknown = function (schema, value, unprocessed, errors, state, prefs) {\n\n    if (schema.$_terms.patterns) {\n        let hasMatches = false;\n        const matches = schema.$_terms.patterns.map((pattern) => {\n\n            if (pattern.matches) {\n                hasMatches = true;\n                return [];\n            }\n        });\n\n        const ancestors = [value, ...state.ancestors];\n\n        for (const key of unprocessed) {\n            const item = value[key];\n            const path = [...state.path, key];\n\n            for (let i = 0; i < schema.$_terms.patterns.length; ++i) {\n                const pattern = schema.$_terms.patterns[i];\n                if (pattern.regex) {\n                    const match = pattern.regex.test(key);\n                    state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');\n                    if (!match) {\n                        continue;\n                    }\n                }\n                else {\n                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {\n                        continue;\n                    }\n                }\n\n                unprocessed.delete(key);\n\n                const localState = state.localize(path, ancestors, { schema: pattern.rule, key });\n                const result = pattern.rule.$_validate(item, localState, prefs);\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return { value, errors: result.errors };\n                    }\n\n                    errors.push(...result.errors);\n                }\n\n                if (pattern.matches) {\n                    matches[i].push(key);\n                }\n\n                value[key] = result.value;\n                if (!pattern.fallthrough) {\n                    break;\n                }\n            }\n        }\n\n        // Validate pattern matches rules\n\n        if (hasMatches) {\n            for (let i = 0; i < matches.length; ++i) {\n                const match = matches[i];\n                if (!match) {\n                    continue;\n                }\n\n                const stpm = schema.$_terms.patterns[i].matches;\n                const localState = state.localize(state.path, ancestors, stpm);\n                const result = stpm.$_validate(match, localState, prefs);\n                if (result.errors) {\n                    const details = Errors.details(result.errors, { override: false });\n                    details.matches = match;\n                    const report = schema.$_createError('object.pattern.match', value, details, state, prefs);\n                    if (prefs.abortEarly) {\n                        return { value, errors: report };\n                    }\n\n                    errors.push(report);\n                }\n            }\n        }\n    }\n\n    if (!unprocessed.size ||\n        !schema.$_terms.keys && !schema.$_terms.patterns) {     // If no keys or patterns specified, unknown keys allowed\n\n        return;\n    }\n\n    if (prefs.stripUnknown && !schema._flags.unknown ||\n        prefs.skipFunctions) {\n\n        const stripUnknown = prefs.stripUnknown ? (prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects) : false;\n\n        for (const key of unprocessed) {\n            if (stripUnknown) {\n                delete value[key];\n                unprocessed.delete(key);\n            }\n            else if (typeof value[key] === 'function') {\n                unprocessed.delete(key);\n            }\n        }\n    }\n\n    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);\n    if (forbidUnknown) {\n        for (const unprocessedKey of unprocessed) {\n            const localState = state.localize([...state.path, unprocessedKey], []);\n            const report = schema.$_createError('object.unknown', value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });\n            if (prefs.abortEarly) {\n                return { value, errors: report };\n            }\n\n            errors.push(report);\n        }\n    }\n};\n\n\ninternals.Dependency = class {\n\n    constructor(rel, key, peers, paths) {\n\n        this.rel = rel;\n        this.key = key;\n        this.peers = peers;\n        this.paths = paths;\n    }\n\n    describe() {\n\n        const desc = {\n            rel: this.rel,\n            peers: this.paths\n        };\n\n        if (this.key !== null) {\n            desc.key = this.key.key;\n        }\n\n        if (this.peers[0].separator !== '.') {\n            desc.options = { separator: this.peers[0].separator };\n        }\n\n        return desc;\n    }\n};\n\n\ninternals.Keys = class extends Array {\n\n    concat(source) {\n\n        const result = this.slice();\n\n        const keys = new Map();\n        for (let i = 0; i < result.length; ++i) {\n            keys.set(result[i].key, i);\n        }\n\n        for (const item of source) {\n            const key = item.key;\n            const pos = keys.get(key);\n            if (pos !== undefined) {\n                result[pos] = { key, schema: result[pos].schema.concat(item.schema) };\n            }\n            else {\n                result.push(item);\n            }\n        }\n\n        return result;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}