{"ast":null,"code":"'use strict';\n\nconst internals = {\n  operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],\n  operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],\n  operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],\n  operatorsPrefix: ['!', 'n'],\n  literals: {\n    '\"': '\"',\n    '`': '`',\n    '\\'': '\\'',\n    '[': ']'\n  },\n  numberRx: /^(?:[0-9]*\\.?[0-9]*){1}$/,\n  tokenRx: /^[\\w\\$\\#\\.\\@\\:\\{\\}]+$/,\n  symbol: Symbol('formula'),\n  settings: Symbol('settings')\n};\nexports.Parser = class {\n  constructor(string) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!options[internals.settings] && options.constants) {\n      for (const constant in options.constants) {\n        const value = options.constants[constant];\n\n        if (value !== null && !['boolean', 'number', 'string'].includes(typeof value)) {\n          throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);\n        }\n      }\n    }\n\n    this.settings = options[internals.settings] ? options : Object.assign({\n      [internals.settings]: true,\n      constants: {},\n      functions: {}\n    }, options);\n    this.single = null;\n    this._parts = null;\n\n    this._parse(string);\n  }\n\n  _parse(string) {\n    let parts = [];\n    let current = '';\n    let parenthesis = 0;\n    let literal = false;\n\n    const flush = inner => {\n      if (parenthesis) {\n        throw new Error('Formula missing closing parenthesis');\n      }\n\n      const last = parts.length ? parts[parts.length - 1] : null;\n\n      if (!literal && !current && !inner) {\n        return;\n      }\n\n      if (last && last.type === 'reference' && inner === ')') {\n        // Function\n        last.type = 'function';\n        last.value = this._subFormula(current, last.value);\n        current = '';\n        return;\n      }\n\n      if (inner === ')') {\n        // Segment\n        const sub = new exports.Parser(current, this.settings);\n        parts.push({\n          type: 'segment',\n          value: sub\n        });\n      } else if (literal) {\n        if (literal === ']') {\n          // Reference\n          parts.push({\n            type: 'reference',\n            value: current\n          });\n          current = '';\n          return;\n        }\n\n        parts.push({\n          type: 'literal',\n          value: current\n        }); // Literal\n      } else if (internals.operatorCharacters.includes(current)) {\n        // Operator\n        if (last && last.type === 'operator' && internals.operators.includes(last.value + current)) {\n          // 2 characters operator\n          last.value += current;\n        } else {\n          parts.push({\n            type: 'operator',\n            value: current\n          });\n        }\n      } else if (current.match(internals.numberRx)) {\n        // Number\n        parts.push({\n          type: 'constant',\n          value: parseFloat(current)\n        });\n      } else if (this.settings.constants[current] !== undefined) {\n        // Constant\n        parts.push({\n          type: 'constant',\n          value: this.settings.constants[current]\n        });\n      } else {\n        // Reference\n        if (!current.match(internals.tokenRx)) {\n          throw new Error(`Formula contains invalid token: ${current}`);\n        }\n\n        parts.push({\n          type: 'reference',\n          value: current\n        });\n      }\n\n      current = '';\n    };\n\n    for (const c of string) {\n      if (literal) {\n        if (c === literal) {\n          flush();\n          literal = false;\n        } else {\n          current += c;\n        }\n      } else if (parenthesis) {\n        if (c === '(') {\n          current += c;\n          ++parenthesis;\n        } else if (c === ')') {\n          --parenthesis;\n\n          if (!parenthesis) {\n            flush(c);\n          } else {\n            current += c;\n          }\n        } else {\n          current += c;\n        }\n      } else if (c in internals.literals) {\n        literal = internals.literals[c];\n      } else if (c === '(') {\n        flush();\n        ++parenthesis;\n      } else if (internals.operatorCharacters.includes(c)) {\n        flush();\n        current = c;\n        flush();\n      } else if (c !== ' ') {\n        current += c;\n      } else {\n        flush();\n      }\n    }\n\n    flush(); // Replace prefix - to internal negative operator\n\n    parts = parts.map((part, i) => {\n      if (part.type !== 'operator' || part.value !== '-' || i && parts[i - 1].type !== 'operator') {\n        return part;\n      }\n\n      return {\n        type: 'operator',\n        value: 'n'\n      };\n    }); // Validate tokens order\n\n    let operator = false;\n\n    for (const part of parts) {\n      if (part.type === 'operator') {\n        if (internals.operatorsPrefix.includes(part.value)) {\n          continue;\n        }\n\n        if (!operator) {\n          throw new Error('Formula contains an operator in invalid position');\n        }\n\n        if (!internals.operators.includes(part.value)) {\n          throw new Error(`Formula contains an unknown operator ${part.value}`);\n        }\n      } else if (operator) {\n        throw new Error('Formula missing expected operator');\n      }\n\n      operator = !operator;\n    }\n\n    if (!operator) {\n      throw new Error('Formula contains invalid trailing operator');\n    } // Identify single part\n\n\n    if (parts.length === 1 && ['reference', 'literal', 'constant'].includes(parts[0].type)) {\n      this.single = {\n        type: parts[0].type === 'reference' ? 'reference' : 'value',\n        value: parts[0].value\n      };\n    } // Process parts\n\n\n    this._parts = parts.map(part => {\n      // Operators\n      if (part.type === 'operator') {\n        return internals.operatorsPrefix.includes(part.value) ? part : part.value;\n      } // Literals, constants, segments\n\n\n      if (part.type !== 'reference') {\n        return part.value;\n      } // References\n\n\n      if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {\n        throw new Error(`Formula contains invalid reference ${part.value}`);\n      }\n\n      if (this.settings.reference) {\n        return this.settings.reference(part.value);\n      }\n\n      return internals.reference(part.value);\n    });\n  }\n\n  _subFormula(string, name) {\n    const method = this.settings.functions[name];\n\n    if (typeof method !== 'function') {\n      throw new Error(`Formula contains unknown function ${name}`);\n    }\n\n    let args = [];\n\n    if (string) {\n      let current = '';\n      let parenthesis = 0;\n      let literal = false;\n\n      const flush = () => {\n        if (!current) {\n          throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);\n        }\n\n        args.push(current);\n        current = '';\n      };\n\n      for (let i = 0; i < string.length; ++i) {\n        const c = string[i];\n\n        if (literal) {\n          current += c;\n\n          if (c === literal) {\n            literal = false;\n          }\n        } else if (c in internals.literals && !parenthesis) {\n          current += c;\n          literal = internals.literals[c];\n        } else if (c === ',' && !parenthesis) {\n          flush();\n        } else {\n          current += c;\n\n          if (c === '(') {\n            ++parenthesis;\n          } else if (c === ')') {\n            --parenthesis;\n          }\n        }\n      }\n\n      flush();\n    }\n\n    args = args.map(arg => new exports.Parser(arg, this.settings));\n    return function (context) {\n      const innerValues = [];\n\n      for (const arg of args) {\n        innerValues.push(arg.evaluate(context));\n      }\n\n      return method.call(context, ...innerValues);\n    };\n  }\n\n  evaluate(context) {\n    const parts = this._parts.slice(); // Prefix operators\n\n\n    for (let i = parts.length - 2; i >= 0; --i) {\n      const part = parts[i];\n\n      if (part && part.type === 'operator') {\n        const current = parts[i + 1];\n        parts.splice(i + 1, 1);\n        const value = internals.evaluate(current, context);\n        parts[i] = internals.single(part.value, value);\n      }\n    } // Left-right operators\n\n\n    internals.operatorsOrder.forEach(set => {\n      for (let i = 1; i < parts.length - 1;) {\n        if (set.includes(parts[i])) {\n          const operator = parts[i];\n          const left = internals.evaluate(parts[i - 1], context);\n          const right = internals.evaluate(parts[i + 1], context);\n          parts.splice(i, 2);\n          const result = internals.calculate(operator, left, right);\n          parts[i - 1] = result === 0 ? 0 : result; // Convert -0\n        } else {\n          i += 2;\n        }\n      }\n    });\n    return internals.evaluate(parts[0], context);\n  }\n\n};\nexports.Parser.prototype[internals.symbol] = true;\n\ninternals.reference = function (name) {\n  return function (context) {\n    return context && context[name] !== undefined ? context[name] : null;\n  };\n};\n\ninternals.evaluate = function (part, context) {\n  if (part === null) {\n    return null;\n  }\n\n  if (typeof part === 'function') {\n    return part(context);\n  }\n\n  if (part[internals.symbol]) {\n    return part.evaluate(context);\n  }\n\n  return part;\n};\n\ninternals.single = function (operator, value) {\n  if (operator === '!') {\n    return value ? false : true;\n  } // operator === 'n'\n\n\n  const negative = -value;\n\n  if (negative === 0) {\n    // Override -0\n    return 0;\n  }\n\n  return negative;\n};\n\ninternals.calculate = function (operator, left, right) {\n  if (operator === '??') {\n    return internals.exists(left) ? left : right;\n  }\n\n  if (typeof left === 'string' || typeof right === 'string') {\n    if (operator === '+') {\n      left = internals.exists(left) ? left : '';\n      right = internals.exists(right) ? right : '';\n      return left + right;\n    }\n  } else {\n    switch (operator) {\n      case '^':\n        return Math.pow(left, right);\n\n      case '*':\n        return left * right;\n\n      case '/':\n        return left / right;\n\n      case '%':\n        return left % right;\n\n      case '+':\n        return left + right;\n\n      case '-':\n        return left - right;\n    }\n  }\n\n  switch (operator) {\n    case '<':\n      return left < right;\n\n    case '<=':\n      return left <= right;\n\n    case '>':\n      return left > right;\n\n    case '>=':\n      return left >= right;\n\n    case '==':\n      return left === right;\n\n    case '!=':\n      return left !== right;\n\n    case '&&':\n      return left && right;\n\n    case '||':\n      return left || right;\n  }\n\n  return null;\n};\n\ninternals.exists = function (value) {\n  return value !== null && value !== undefined;\n};","map":{"version":3,"names":["internals","operators","operatorCharacters","operatorsOrder","operatorsPrefix","literals","numberRx","tokenRx","symbol","Symbol","settings","exports","Parser","constructor","string","options","constants","constant","value","includes","Error","Object","assign","functions","single","_parts","_parse","parts","current","parenthesis","literal","flush","inner","last","length","type","_subFormula","sub","push","match","parseFloat","undefined","c","map","part","i","operator","test","reference","name","method","args","arg","context","innerValues","evaluate","call","slice","splice","forEach","set","left","right","result","calculate","prototype","negative","exists","Math","pow"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/formula/lib/index.js"],"sourcesContent":["'use strict';\n\nconst internals = {\n    operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],\n    operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],\n    operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],\n    operatorsPrefix: ['!', 'n'],\n\n    literals: {\n        '\"': '\"',\n        '`': '`',\n        '\\'': '\\'',\n        '[': ']'\n    },\n\n    numberRx: /^(?:[0-9]*\\.?[0-9]*){1}$/,\n    tokenRx: /^[\\w\\$\\#\\.\\@\\:\\{\\}]+$/,\n\n    symbol: Symbol('formula'),\n    settings: Symbol('settings')\n};\n\n\nexports.Parser = class {\n\n    constructor(string, options = {}) {\n\n        if (!options[internals.settings] &&\n            options.constants) {\n\n            for (const constant in options.constants) {\n                const value = options.constants[constant];\n                if (value !== null &&\n                    !['boolean', 'number', 'string'].includes(typeof value)) {\n\n                    throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);\n                }\n            }\n        }\n\n        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);\n        this.single = null;\n\n        this._parts = null;\n        this._parse(string);\n    }\n\n    _parse(string) {\n\n        let parts = [];\n        let current = '';\n        let parenthesis = 0;\n        let literal = false;\n\n        const flush = (inner) => {\n\n            if (parenthesis) {\n                throw new Error('Formula missing closing parenthesis');\n            }\n\n            const last = parts.length ? parts[parts.length - 1] : null;\n\n            if (!literal &&\n                !current &&\n                !inner) {\n\n                return;\n            }\n\n            if (last &&\n                last.type === 'reference' &&\n                inner === ')') {                                                                // Function\n\n                last.type = 'function';\n                last.value = this._subFormula(current, last.value);\n                current = '';\n                return;\n            }\n\n            if (inner === ')') {                                                                // Segment\n                const sub = new exports.Parser(current, this.settings);\n                parts.push({ type: 'segment', value: sub });\n            }\n            else if (literal) {\n                if (literal === ']') {                                                          // Reference\n                    parts.push({ type: 'reference', value: current });\n                    current = '';\n                    return;\n                }\n\n                parts.push({ type: 'literal', value: current });                                // Literal\n            }\n            else if (internals.operatorCharacters.includes(current)) {                          // Operator\n                if (last &&\n                    last.type === 'operator' &&\n                    internals.operators.includes(last.value + current)) {                       // 2 characters operator\n\n                    last.value += current;\n                }\n                else {\n                    parts.push({ type: 'operator', value: current });\n                }\n            }\n            else if (current.match(internals.numberRx)) {                                       // Number\n                parts.push({ type: 'constant', value: parseFloat(current) });\n            }\n            else if (this.settings.constants[current] !== undefined) {                          // Constant\n                parts.push({ type: 'constant', value: this.settings.constants[current] });\n            }\n            else {                                                                              // Reference\n                if (!current.match(internals.tokenRx)) {\n                    throw new Error(`Formula contains invalid token: ${current}`);\n                }\n\n                parts.push({ type: 'reference', value: current });\n            }\n\n            current = '';\n        };\n\n        for (const c of string) {\n            if (literal) {\n                if (c === literal) {\n                    flush();\n                    literal = false;\n                }\n                else {\n                    current += c;\n                }\n            }\n            else if (parenthesis) {\n                if (c === '(') {\n                    current += c;\n                    ++parenthesis;\n                }\n                else if (c === ')') {\n                    --parenthesis;\n                    if (!parenthesis) {\n                        flush(c);\n                    }\n                    else {\n                        current += c;\n                    }\n                }\n                else {\n                    current += c;\n                }\n            }\n            else if (c in internals.literals) {\n                literal = internals.literals[c];\n            }\n            else if (c === '(') {\n                flush();\n                ++parenthesis;\n            }\n            else if (internals.operatorCharacters.includes(c)) {\n                flush();\n                current = c;\n                flush();\n            }\n            else if (c !== ' ') {\n                current += c;\n            }\n            else {\n                flush();\n            }\n        }\n\n        flush();\n\n        // Replace prefix - to internal negative operator\n\n        parts = parts.map((part, i) => {\n\n            if (part.type !== 'operator' ||\n                part.value !== '-' ||\n                i && parts[i - 1].type !== 'operator') {\n\n                return part;\n            }\n\n            return { type: 'operator', value: 'n' };\n        });\n\n        // Validate tokens order\n\n        let operator = false;\n        for (const part of parts) {\n            if (part.type === 'operator') {\n                if (internals.operatorsPrefix.includes(part.value)) {\n                    continue;\n                }\n\n                if (!operator) {\n                    throw new Error('Formula contains an operator in invalid position');\n                }\n\n                if (!internals.operators.includes(part.value)) {\n                    throw new Error(`Formula contains an unknown operator ${part.value}`);\n                }\n            }\n            else if (operator) {\n                throw new Error('Formula missing expected operator');\n            }\n\n            operator = !operator;\n        }\n\n        if (!operator) {\n            throw new Error('Formula contains invalid trailing operator');\n        }\n\n        // Identify single part\n\n        if (parts.length === 1 &&\n            ['reference', 'literal', 'constant'].includes(parts[0].type)) {\n\n            this.single = { type: parts[0].type === 'reference' ? 'reference' : 'value', value: parts[0].value };\n        }\n\n        // Process parts\n\n        this._parts = parts.map((part) => {\n\n            // Operators\n\n            if (part.type === 'operator') {\n                return internals.operatorsPrefix.includes(part.value) ? part : part.value;\n            }\n\n            // Literals, constants, segments\n\n            if (part.type !== 'reference') {\n                return part.value;\n            }\n\n            // References\n\n            if (this.settings.tokenRx &&\n                !this.settings.tokenRx.test(part.value)) {\n\n                throw new Error(`Formula contains invalid reference ${part.value}`);\n            }\n\n            if (this.settings.reference) {\n                return this.settings.reference(part.value);\n            }\n\n            return internals.reference(part.value);\n        });\n    }\n\n    _subFormula(string, name) {\n\n        const method = this.settings.functions[name];\n        if (typeof method !== 'function') {\n            throw new Error(`Formula contains unknown function ${name}`);\n        }\n\n        let args = [];\n        if (string) {\n            let current = '';\n            let parenthesis = 0;\n            let literal = false;\n\n            const flush = () => {\n\n                if (!current) {\n                    throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);\n                }\n\n                args.push(current);\n                current = '';\n            };\n\n            for (let i = 0; i < string.length; ++i) {\n                const c = string[i];\n                if (literal) {\n                    current += c;\n                    if (c === literal) {\n                        literal = false;\n                    }\n                }\n                else if (c in internals.literals &&\n                    !parenthesis) {\n\n                    current += c;\n                    literal = internals.literals[c];\n                }\n                else if (c === ',' &&\n                    !parenthesis) {\n\n                    flush();\n                }\n                else {\n                    current += c;\n                    if (c === '(') {\n                        ++parenthesis;\n                    }\n                    else if (c === ')') {\n                        --parenthesis;\n                    }\n                }\n            }\n\n            flush();\n        }\n\n        args = args.map((arg) => new exports.Parser(arg, this.settings));\n\n        return function (context) {\n\n            const innerValues = [];\n            for (const arg of args) {\n                innerValues.push(arg.evaluate(context));\n            }\n\n            return method.call(context, ...innerValues);\n        };\n    }\n\n    evaluate(context) {\n\n        const parts = this._parts.slice();\n\n        // Prefix operators\n\n        for (let i = parts.length - 2; i >= 0; --i) {\n            const part = parts[i];\n            if (part &&\n                part.type === 'operator') {\n\n                const current = parts[i + 1];\n                parts.splice(i + 1, 1);\n                const value = internals.evaluate(current, context);\n                parts[i] = internals.single(part.value, value);\n            }\n        }\n\n        // Left-right operators\n\n        internals.operatorsOrder.forEach((set) => {\n\n            for (let i = 1; i < parts.length - 1;) {\n                if (set.includes(parts[i])) {\n                    const operator = parts[i];\n                    const left = internals.evaluate(parts[i - 1], context);\n                    const right = internals.evaluate(parts[i + 1], context);\n\n                    parts.splice(i, 2);\n                    const result = internals.calculate(operator, left, right);\n                    parts[i - 1] = result === 0 ? 0 : result;                               // Convert -0\n                }\n                else {\n                    i += 2;\n                }\n            }\n        });\n\n        return internals.evaluate(parts[0], context);\n    }\n};\n\n\nexports.Parser.prototype[internals.symbol] = true;\n\n\ninternals.reference = function (name) {\n\n    return function (context) {\n\n        return context && context[name] !== undefined ? context[name] : null;\n    };\n};\n\n\ninternals.evaluate = function (part, context) {\n\n    if (part === null) {\n        return null;\n    }\n\n    if (typeof part === 'function') {\n        return part(context);\n    }\n\n    if (part[internals.symbol]) {\n        return part.evaluate(context);\n    }\n\n    return part;\n};\n\n\ninternals.single = function (operator, value) {\n\n    if (operator === '!') {\n        return value ? false : true;\n    }\n\n    // operator === 'n'\n\n    const negative = -value;\n    if (negative === 0) {       // Override -0\n        return 0;\n    }\n\n    return negative;\n};\n\n\ninternals.calculate = function (operator, left, right) {\n\n    if (operator === '??') {\n        return internals.exists(left) ? left : right;\n    }\n\n    if (typeof left === 'string' ||\n        typeof right === 'string') {\n\n        if (operator === '+') {\n            left = internals.exists(left) ? left : '';\n            right = internals.exists(right) ? right : '';\n            return left + right;\n        }\n    }\n    else {\n        switch (operator) {\n            case '^': return Math.pow(left, right);\n            case '*': return left * right;\n            case '/': return left / right;\n            case '%': return left % right;\n            case '+': return left + right;\n            case '-': return left - right;\n        }\n    }\n\n    switch (operator) {\n        case '<': return left < right;\n        case '<=': return left <= right;\n        case '>': return left > right;\n        case '>=': return left >= right;\n        case '==': return left === right;\n        case '!=': return left !== right;\n        case '&&': return left && right;\n        case '||': return left || right;\n    }\n\n    return null;\n};\n\n\ninternals.exists = function (value) {\n\n    return value !== null && value !== undefined;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}