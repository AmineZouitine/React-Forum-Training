{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Common = require('./common');\n\nconst Ref = require('./ref');\n\nconst internals = {};\nexports.Ids = internals.Ids = class {\n  constructor() {\n    this._byId = new Map();\n    this._byKey = new Map();\n    this._schemaChain = false;\n  }\n\n  clone() {\n    const clone = new internals.Ids();\n    clone._byId = new Map(this._byId);\n    clone._byKey = new Map(this._byKey);\n    clone._schemaChain = this._schemaChain;\n    return clone;\n  }\n\n  concat(source) {\n    if (source._schemaChain) {\n      this._schemaChain = true;\n    }\n\n    for (const [id, value] of source._byId.entries()) {\n      Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n\n      this._byId.set(id, value);\n    }\n\n    for (const [key, value] of source._byKey.entries()) {\n      Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n\n      this._byKey.set(key, value);\n    }\n  }\n\n  fork(path, adjuster, root) {\n    const chain = this._collect(path);\n\n    chain.push({\n      schema: root\n    });\n    const tail = chain.shift();\n    let adjusted = {\n      id: tail.id,\n      schema: adjuster(tail.schema)\n    };\n    Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');\n\n    for (const node of chain) {\n      adjusted = {\n        id: node.id,\n        schema: internals.fork(node.schema, adjusted.id, adjusted.schema)\n      };\n    }\n\n    return adjusted.schema;\n  }\n\n  labels(path) {\n    let behind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const current = path[0];\n\n    const node = this._get(current);\n\n    if (!node) {\n      return [...behind, ...path].join('.');\n    }\n\n    const forward = path.slice(1);\n    behind = [...behind, node.schema._flags.label || current];\n\n    if (!forward.length) {\n      return behind.join('.');\n    }\n\n    return node.schema._ids.labels(forward, behind);\n  }\n\n  reach(path) {\n    let behind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const current = path[0];\n\n    const node = this._get(current);\n\n    Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n    const forward = path.slice(1);\n\n    if (!forward.length) {\n      return node.schema;\n    }\n\n    return node.schema._ids.reach(forward, [...behind, current]);\n  }\n\n  register(schema) {\n    let {\n      key\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!schema || !Common.isSchema(schema)) {\n      return;\n    }\n\n    if (schema.$_property('schemaChain') || schema._ids._schemaChain) {\n      this._schemaChain = true;\n    }\n\n    const id = schema._flags.id;\n\n    if (id) {\n      const existing = this._byId.get(id);\n\n      Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);\n      Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n\n      this._byId.set(id, {\n        schema,\n        id\n      });\n    }\n\n    if (key) {\n      Assert(!this._byKey.has(key), 'Schema already contains key:', key);\n      Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n\n      this._byKey.set(key, {\n        schema,\n        id: key\n      });\n    }\n  }\n\n  reset() {\n    this._byId = new Map();\n    this._byKey = new Map();\n    this._schemaChain = false;\n  }\n\n  _collect(path) {\n    let behind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let nodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const current = path[0];\n\n    const node = this._get(current);\n\n    Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n    nodes = [node, ...nodes];\n    const forward = path.slice(1);\n\n    if (!forward.length) {\n      return nodes;\n    }\n\n    return node.schema._ids._collect(forward, [...behind, current], nodes);\n  }\n\n  _get(id) {\n    return this._byId.get(id) || this._byKey.get(id);\n  }\n\n};\n\ninternals.fork = function (schema, id, replacement) {\n  const each = (item, _ref) => {\n    let {\n      key\n    } = _ref;\n\n    if (id === (item._flags.id || key)) {\n      return replacement;\n    }\n  };\n\n  const obj = exports.schema(schema, {\n    each,\n    ref: false\n  });\n  return obj ? obj.$_mutateRebuild() : schema;\n};\n\nexports.schema = function (schema, options) {\n  let obj;\n\n  for (const name in schema._flags) {\n    if (name[0] === '_') {\n      continue;\n    }\n\n    const result = internals.scan(schema._flags[name], {\n      source: 'flags',\n      name\n    }, options);\n\n    if (result !== undefined) {\n      obj = obj || schema.clone();\n      obj._flags[name] = result;\n    }\n  }\n\n  for (let i = 0; i < schema._rules.length; ++i) {\n    const rule = schema._rules[i];\n    const result = internals.scan(rule.args, {\n      source: 'rules',\n      name: rule.name\n    }, options);\n\n    if (result !== undefined) {\n      obj = obj || schema.clone();\n      const clone = Object.assign({}, rule);\n      clone.args = result;\n      obj._rules[i] = clone;\n\n      const existingUnique = obj._singleRules.get(rule.name);\n\n      if (existingUnique === rule) {\n        obj._singleRules.set(rule.name, clone);\n      }\n    }\n  }\n\n  for (const name in schema.$_terms) {\n    if (name[0] === '_') {\n      continue;\n    }\n\n    const result = internals.scan(schema.$_terms[name], {\n      source: 'terms',\n      name\n    }, options);\n\n    if (result !== undefined) {\n      obj = obj || schema.clone();\n      obj.$_terms[name] = result;\n    }\n  }\n\n  return obj;\n};\n\ninternals.scan = function (item, source, options, _path, _key) {\n  const path = _path || [];\n\n  if (item === null || typeof item !== 'object') {\n    return;\n  }\n\n  let clone;\n\n  if (Array.isArray(item)) {\n    for (let i = 0; i < item.length; ++i) {\n      const key = source.source === 'terms' && source.name === 'keys' && item[i].key;\n      const result = internals.scan(item[i], source, options, [i, ...path], key);\n\n      if (result !== undefined) {\n        clone = clone || item.slice();\n        clone[i] = result;\n      }\n    }\n\n    return clone;\n  }\n\n  if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {\n    const result = options.each(item, { ...source,\n      path,\n      key: _key\n    });\n\n    if (result === item) {\n      return;\n    }\n\n    return result;\n  }\n\n  for (const key in item) {\n    if (key[0] === '_') {\n      continue;\n    }\n\n    const result = internals.scan(item[key], source, options, [key, ...path], _key);\n\n    if (result !== undefined) {\n      clone = clone || Object.assign({}, item);\n      clone[key] = result;\n    }\n  }\n\n  return clone;\n};","map":{"version":3,"names":["Assert","require","Common","Ref","internals","exports","Ids","constructor","_byId","Map","_byKey","_schemaChain","clone","concat","source","id","value","entries","has","set","key","fork","path","adjuster","root","chain","_collect","push","schema","tail","shift","adjusted","isSchema","node","labels","behind","current","_get","join","forward","slice","_flags","label","length","_ids","reach","register","$_property","existing","get","reset","nodes","replacement","each","item","obj","ref","$_mutateRebuild","options","name","result","scan","undefined","i","_rules","rule","args","Object","assign","existingUnique","_singleRules","$_terms","_path","_key","Array","isArray","isRef"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/modify.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Common = require('./common');\nconst Ref = require('./ref');\n\n\nconst internals = {};\n\n\n\nexports.Ids = internals.Ids = class {\n\n    constructor() {\n\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n\n    clone() {\n\n        const clone = new internals.Ids();\n        clone._byId = new Map(this._byId);\n        clone._byKey = new Map(this._byKey);\n        clone._schemaChain = this._schemaChain;\n        return clone;\n    }\n\n    concat(source) {\n\n        if (source._schemaChain) {\n            this._schemaChain = true;\n        }\n\n        for (const [id, value] of source._byId.entries()) {\n            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n            this._byId.set(id, value);\n        }\n\n        for (const [key, value] of source._byKey.entries()) {\n            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n            this._byKey.set(key, value);\n        }\n    }\n\n    fork(path, adjuster, root) {\n\n        const chain = this._collect(path);\n        chain.push({ schema: root });\n        const tail = chain.shift();\n        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };\n\n        Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');\n\n        for (const node of chain) {\n            adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };\n        }\n\n        return adjusted.schema;\n    }\n\n    labels(path, behind = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        if (!node) {\n            return [...behind, ...path].join('.');\n        }\n\n        const forward = path.slice(1);\n        behind = [...behind, node.schema._flags.label || current];\n        if (!forward.length) {\n            return behind.join('.');\n        }\n\n        return node.schema._ids.labels(forward, behind);\n    }\n\n    reach(path, behind = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return node.schema;\n        }\n\n        return node.schema._ids.reach(forward, [...behind, current]);\n    }\n\n    register(schema, { key } = {}) {\n\n        if (!schema ||\n            !Common.isSchema(schema)) {\n\n            return;\n        }\n\n        if (schema.$_property('schemaChain') ||\n            schema._ids._schemaChain) {\n\n            this._schemaChain = true;\n        }\n\n        const id = schema._flags.id;\n        if (id) {\n            const existing = this._byId.get(id);\n            Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);\n            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n\n            this._byId.set(id, { schema, id });\n        }\n\n        if (key) {\n            Assert(!this._byKey.has(key), 'Schema already contains key:', key);\n            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n\n            this._byKey.set(key, { schema, id: key });\n        }\n    }\n\n    reset() {\n\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n\n    _collect(path, behind = [], nodes = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n\n        nodes = [node, ...nodes];\n\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return nodes;\n        }\n\n        return node.schema._ids._collect(forward, [...behind, current], nodes);\n    }\n\n    _get(id) {\n\n        return this._byId.get(id) || this._byKey.get(id);\n    }\n};\n\n\ninternals.fork = function (schema, id, replacement) {\n\n    const each = (item, { key }) => {\n\n        if (id === (item._flags.id || key)) {\n            return replacement;\n        }\n    };\n\n    const obj = exports.schema(schema, { each, ref: false });\n    return obj ? obj.$_mutateRebuild() : schema;\n};\n\n\nexports.schema = function (schema, options) {\n\n    let obj;\n\n    for (const name in schema._flags) {\n        if (name[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(schema._flags[name], { source: 'flags', name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj._flags[name] = result;\n        }\n    }\n\n    for (let i = 0; i < schema._rules.length; ++i) {\n        const rule = schema._rules[i];\n        const result = internals.scan(rule.args, { source: 'rules', name: rule.name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            const clone = Object.assign({}, rule);\n            clone.args = result;\n            obj._rules[i] = clone;\n\n            const existingUnique = obj._singleRules.get(rule.name);\n            if (existingUnique === rule) {\n                obj._singleRules.set(rule.name, clone);\n            }\n        }\n    }\n\n    for (const name in schema.$_terms) {\n        if (name[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(schema.$_terms[name], { source: 'terms', name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj.$_terms[name] = result;\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.scan = function (item, source, options, _path, _key) {\n\n    const path = _path || [];\n\n    if (item === null ||\n        typeof item !== 'object') {\n\n        return;\n    }\n\n    let clone;\n\n    if (Array.isArray(item)) {\n        for (let i = 0; i < item.length; ++i) {\n            const key = source.source === 'terms' && source.name === 'keys' && item[i].key;\n            const result = internals.scan(item[i], source, options, [i, ...path], key);\n            if (result !== undefined) {\n                clone = clone || item.slice();\n                clone[i] = result;\n            }\n        }\n\n        return clone;\n    }\n\n    if (options.schema !== false && Common.isSchema(item) ||\n        options.ref !== false && Ref.isRef(item)) {\n\n        const result = options.each(item, { ...source, path, key: _key });\n        if (result === item) {\n            return;\n        }\n\n        return result;\n    }\n\n    for (const key in item) {\n        if (key[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(item[key], source, options, [key, ...path], _key);\n        if (result !== undefined) {\n            clone = clone || Object.assign({}, item);\n            clone[key] = result;\n        }\n    }\n\n    return clone;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}