{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\n\nconst Merge = require('@hapi/hoek/lib/merge');\n\nconst Cache = require('./cache');\n\nconst Common = require('./common');\n\nconst Compile = require('./compile');\n\nconst Errors = require('./errors');\n\nconst Extend = require('./extend');\n\nconst Manifest = require('./manifest');\n\nconst Messages = require('./messages');\n\nconst Modify = require('./modify');\n\nconst Ref = require('./ref');\n\nconst Trace = require('./trace');\n\nconst Validator = require('./validator');\n\nconst Values = require('./values');\n\nconst internals = {};\ninternals.Base = class {\n  constructor(type) {\n    // Naming: public, _private, $_extension, $_mutate{action}\n    this.type = type;\n    this.$_root = null;\n    this._definition = {};\n    this._ids = new Modify.Ids();\n    this._preferences = null;\n    this._refs = new Ref.Manager();\n    this._cache = null;\n    this._valids = null;\n    this._invalids = null;\n    this._flags = {};\n    this._rules = [];\n    this._singleRules = new Map(); // The rule options passed for non-multi rules\n\n    this.$_terms = {}; // Hash of arrays of immutable objects (extended by other types)\n\n    this.$_temp = {\n      // Runtime state (not cloned)\n      ruleset: null,\n      // null: use last, false: error, number: start position\n      whens: {} // Runtime cache of generated whens\n\n    };\n  } // Manifest\n\n\n  describe() {\n    Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');\n    return Manifest.describe(this);\n  } // Rules\n\n\n  allow() {\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n\n    Common.verifyFlat(values, 'allow');\n    return this._values(values, '_valids');\n  }\n\n  alter(targets) {\n    Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');\n    Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');\n    const obj = this.clone();\n    obj.$_terms.alterations = obj.$_terms.alterations || [];\n\n    for (const target in targets) {\n      const adjuster = targets[target];\n      Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');\n      obj.$_terms.alterations.push({\n        target,\n        adjuster\n      });\n    }\n\n    obj.$_temp.ruleset = false;\n    return obj;\n  }\n\n  cast(to) {\n    Assert(to === false || typeof to === 'string', 'Invalid to value');\n    Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);\n    return this.$_setFlag('cast', to === false ? undefined : to);\n  }\n\n  default(value, options) {\n    return this._default('default', value, options);\n  }\n\n  description(desc) {\n    Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n    return this.$_setFlag('description', desc);\n  }\n\n  empty(schema) {\n    const obj = this.clone();\n\n    if (schema !== undefined) {\n      schema = obj.$_compile(schema, {\n        override: false\n      });\n    }\n\n    return obj.$_setFlag('empty', schema, {\n      clone: false\n    });\n  }\n\n  error(err) {\n    Assert(err, 'Missing error');\n    Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');\n    return this.$_setFlag('error', err);\n  }\n\n  example(example) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Assert(example !== undefined, 'Missing example');\n    Common.assertOptions(options, ['override']);\n    return this._inner('examples', example, {\n      single: true,\n      override: options.override\n    });\n  }\n\n  external(method, description) {\n    if (typeof method === 'object') {\n      Assert(!description, 'Cannot combine options with description');\n      description = method.description;\n      method = method.method;\n    }\n\n    Assert(typeof method === 'function', 'Method must be a function');\n    Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');\n    return this._inner('externals', {\n      method,\n      description\n    }, {\n      single: true\n    });\n  }\n\n  failover(value, options) {\n    return this._default('failover', value, options);\n  }\n\n  forbidden() {\n    return this.presence('forbidden');\n  }\n\n  id(id) {\n    if (!id) {\n      return this.$_setFlag('id', undefined);\n    }\n\n    Assert(typeof id === 'string', 'id must be a non-empty string');\n    Assert(/^[^\\.]+$/.test(id), 'id cannot contain period character');\n    return this.$_setFlag('id', id);\n  }\n\n  invalid() {\n    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      values[_key2] = arguments[_key2];\n    }\n\n    return this._values(values, '_invalids');\n  }\n\n  label(name) {\n    Assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n    return this.$_setFlag('label', name);\n  }\n\n  meta(meta) {\n    Assert(meta !== undefined, 'Meta cannot be undefined');\n    return this._inner('metas', meta, {\n      single: true\n    });\n  }\n\n  note() {\n    for (var _len3 = arguments.length, notes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      notes[_key3] = arguments[_key3];\n    }\n\n    Assert(notes.length, 'Missing notes');\n\n    for (const note of notes) {\n      Assert(note && typeof note === 'string', 'Notes must be non-empty strings');\n    }\n\n    return this._inner('notes', notes);\n  }\n\n  only() {\n    let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    Assert(typeof mode === 'boolean', 'Invalid mode:', mode);\n    return this.$_setFlag('only', mode);\n  }\n\n  optional() {\n    return this.presence('optional');\n  }\n\n  prefs(prefs) {\n    Assert(prefs, 'Missing preferences');\n    Assert(prefs.context === undefined, 'Cannot override context');\n    Assert(prefs.externals === undefined, 'Cannot override externals');\n    Assert(prefs.warnings === undefined, 'Cannot override warnings');\n    Assert(prefs.debug === undefined, 'Cannot override debug');\n    Common.checkPreferences(prefs);\n    const obj = this.clone();\n    obj._preferences = Common.preferences(obj._preferences, prefs);\n    return obj;\n  }\n\n  presence(mode) {\n    Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);\n    return this.$_setFlag('presence', mode);\n  }\n\n  raw() {\n    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.$_setFlag('result', enabled ? 'raw' : undefined);\n  }\n\n  result(mode) {\n    Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);\n    return this.$_setFlag('result', mode);\n  }\n\n  required() {\n    return this.presence('required');\n  }\n\n  strict(enabled) {\n    const obj = this.clone();\n    const convert = enabled === undefined ? false : !enabled;\n    obj._preferences = Common.preferences(obj._preferences, {\n      convert\n    });\n    return obj;\n  }\n\n  strip() {\n    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.$_setFlag('result', enabled ? 'strip' : undefined);\n  }\n\n  tag() {\n    for (var _len4 = arguments.length, tags = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      tags[_key4] = arguments[_key4];\n    }\n\n    Assert(tags.length, 'Missing tags');\n\n    for (const tag of tags) {\n      Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');\n    }\n\n    return this._inner('tags', tags);\n  }\n\n  unit(name) {\n    Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n    return this.$_setFlag('unit', name);\n  }\n\n  valid() {\n    for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      values[_key5] = arguments[_key5];\n    }\n\n    Common.verifyFlat(values, 'valid');\n    const obj = this.allow(...values);\n    obj.$_setFlag('only', !!obj._valids, {\n      clone: false\n    });\n    return obj;\n  }\n\n  when(condition, options) {\n    const obj = this.clone();\n\n    if (!obj.$_terms.whens) {\n      obj.$_terms.whens = [];\n    }\n\n    const when = Compile.when(obj, condition, options);\n\n    if (!['any', 'link'].includes(obj.type)) {\n      const conditions = when.is ? [when] : when.switch;\n\n      for (const item of conditions) {\n        Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);\n        Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);\n      }\n    }\n\n    obj.$_terms.whens.push(when);\n    return obj.$_mutateRebuild();\n  } // Helpers\n\n\n  cache(cache) {\n    Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');\n    Assert(!this._cache, 'Cannot override schema cache');\n    const obj = this.clone();\n    obj._cache = cache || Cache.provider.provision();\n    obj.$_temp.ruleset = false;\n    return obj;\n  }\n\n  clone() {\n    const obj = Object.create(Object.getPrototypeOf(this));\n    return this._assign(obj);\n  }\n\n  concat(source) {\n    Assert(Common.isSchema(source), 'Invalid schema object');\n    Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);\n    Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');\n    Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');\n    let obj = this.clone();\n\n    if (this.type === 'any' && source.type !== 'any') {\n      // Change obj to match source type\n      const tmpObj = source.clone();\n\n      for (const key of Object.keys(obj)) {\n        if (key !== 'type') {\n          tmpObj[key] = obj[key];\n        }\n      }\n\n      obj = tmpObj;\n    }\n\n    obj._ids.concat(source._ids);\n\n    obj._refs.register(source, Ref.toSibling);\n\n    obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;\n    obj._valids = Values.merge(obj._valids, source._valids, source._invalids);\n    obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids); // Remove unique rules present in source\n\n    for (const name of source._singleRules.keys()) {\n      if (obj._singleRules.has(name)) {\n        obj._rules = obj._rules.filter(target => target.keep || target.name !== name);\n\n        obj._singleRules.delete(name);\n      }\n    } // Rules\n\n\n    for (const test of source._rules) {\n      if (!source._definition.rules[test.method].multi) {\n        obj._singleRules.set(test.name, test);\n      }\n\n      obj._rules.push(test);\n    } // Flags\n\n\n    if (obj._flags.empty && source._flags.empty) {\n      obj._flags.empty = obj._flags.empty.concat(source._flags.empty);\n      const flags = Object.assign({}, source._flags);\n      delete flags.empty;\n      Merge(obj._flags, flags);\n    } else if (source._flags.empty) {\n      obj._flags.empty = source._flags.empty;\n      const flags = Object.assign({}, source._flags);\n      delete flags.empty;\n      Merge(obj._flags, flags);\n    } else {\n      Merge(obj._flags, source._flags);\n    } // Terms\n\n\n    for (const key in source.$_terms) {\n      const terms = source.$_terms[key];\n\n      if (!terms) {\n        if (!obj.$_terms[key]) {\n          obj.$_terms[key] = terms;\n        }\n\n        continue;\n      }\n\n      if (!obj.$_terms[key]) {\n        obj.$_terms[key] = terms.slice();\n        continue;\n      }\n\n      obj.$_terms[key] = obj.$_terms[key].concat(terms);\n    } // Tracing\n\n\n    if (this.$_root._tracer) {\n      this.$_root._tracer._combine(obj, [this, source]);\n    } // Rebuild\n\n\n    return obj.$_mutateRebuild();\n  }\n\n  extend(options) {\n    Assert(!options.base, 'Cannot extend type with another base');\n    return Extend.type(this, options);\n  }\n\n  extract(path) {\n    path = Array.isArray(path) ? path : path.split('.');\n    return this._ids.reach(path);\n  }\n\n  fork(paths, adjuster) {\n    Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');\n    let obj = this; // eslint-disable-line consistent-this\n\n    for (let path of [].concat(paths)) {\n      path = Array.isArray(path) ? path : path.split('.');\n      obj = obj._ids.fork(path, adjuster, obj);\n    }\n\n    obj.$_temp.ruleset = false;\n    return obj;\n  }\n\n  rule(options) {\n    const def = this._definition;\n    Common.assertOptions(options, Object.keys(def.modifiers));\n    Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');\n    const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;\n    Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');\n    const obj = this.clone();\n\n    for (let i = start; i < obj._rules.length; ++i) {\n      const original = obj._rules[i];\n      const rule = Clone(original);\n\n      for (const name in options) {\n        def.modifiers[name](rule, options[name]);\n        Assert(rule.name === original.name, 'Cannot change rule name');\n      }\n\n      obj._rules[i] = rule;\n\n      if (obj._singleRules.get(rule.name) === original) {\n        obj._singleRules.set(rule.name, rule);\n      }\n    }\n\n    obj.$_temp.ruleset = false;\n    return obj.$_mutateRebuild();\n  }\n\n  get ruleset() {\n    Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');\n    const obj = this.clone();\n    obj.$_temp.ruleset = obj._rules.length;\n    return obj;\n  }\n\n  get $() {\n    return this.ruleset;\n  }\n\n  tailor(targets) {\n    targets = [].concat(targets);\n    Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');\n    let obj = this; // eslint-disable-line consistent-this\n\n    if (this.$_terms.alterations) {\n      for (const {\n        target,\n        adjuster\n      } of this.$_terms.alterations) {\n        if (targets.includes(target)) {\n          obj = adjuster(obj);\n          Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');\n        }\n      }\n    }\n\n    obj = obj.$_modify({\n      each: item => item.tailor(targets),\n      ref: false\n    });\n    obj.$_temp.ruleset = false;\n    return obj.$_mutateRebuild();\n  }\n\n  tracer() {\n    return Trace.location ? Trace.location(this) : this; // $lab:coverage:ignore$\n  }\n\n  validate(value, options) {\n    return Validator.entry(value, this, options);\n  }\n\n  validateAsync(value, options) {\n    return Validator.entryAsync(value, this, options);\n  } // Extensions\n\n\n  $_addRule(options) {\n    // Normalize rule\n    if (typeof options === 'string') {\n      options = {\n        name: options\n      };\n    }\n\n    Assert(options && typeof options === 'object', 'Invalid options');\n    Assert(options.name && typeof options.name === 'string', 'Invalid rule name');\n\n    for (const key in options) {\n      Assert(key[0] !== '_', 'Cannot set private rule properties');\n    }\n\n    const rule = Object.assign({}, options); // Shallow cloned\n\n    rule._resolve = [];\n    rule.method = rule.method || rule.name;\n    const definition = this._definition.rules[rule.method];\n    const args = rule.args;\n    Assert(definition, 'Unknown rule', rule.method); // Args\n\n    const obj = this.clone();\n\n    if (args) {\n      Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);\n\n      for (const key in args) {\n        let arg = args[key];\n\n        if (arg === undefined) {\n          delete args[key];\n          continue;\n        }\n\n        if (definition.argsByName) {\n          const resolver = definition.argsByName.get(key);\n\n          if (resolver.ref && Common.isResolvable(arg)) {\n            rule._resolve.push(key);\n\n            obj.$_mutateRegister(arg);\n          } else {\n            if (resolver.normalize) {\n              arg = resolver.normalize(arg);\n              args[key] = arg;\n            }\n\n            if (resolver.assert) {\n              const error = Common.validateArg(arg, key, resolver);\n              Assert(!error, error, 'or reference');\n            }\n          }\n        }\n\n        args[key] = arg;\n      }\n    } // Unique rules\n\n\n    if (!definition.multi) {\n      obj._ruleRemove(rule.name, {\n        clone: false\n      });\n\n      obj._singleRules.set(rule.name, rule);\n    }\n\n    if (obj.$_temp.ruleset === false) {\n      obj.$_temp.ruleset = null;\n    }\n\n    if (definition.priority) {\n      obj._rules.unshift(rule);\n    } else {\n      obj._rules.push(rule);\n    }\n\n    return obj;\n  }\n\n  $_compile(schema, options) {\n    return Compile.schema(this.$_root, schema, options);\n  }\n\n  $_createError(code, value, local, state, prefs) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    const flags = options.flags !== false ? this._flags : {};\n    const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;\n    return new Errors.Report(code, value, local, flags, messages, state, prefs);\n  }\n\n  $_getFlag(name) {\n    return this._flags[name];\n  }\n\n  $_getRule(name) {\n    return this._singleRules.get(name);\n  }\n\n  $_mapLabels(path) {\n    path = Array.isArray(path) ? path : path.split('.');\n    return this._ids.labels(path);\n  }\n\n  $_match(value, state, prefs, overrides) {\n    prefs = Object.assign({}, prefs); // Shallow cloned\n\n    prefs.abortEarly = true;\n    prefs._externals = false;\n    state.snapshot();\n    const result = !Validator.validate(value, this, state, prefs, overrides).errors;\n    state.restore();\n    return result;\n  }\n\n  $_modify(options) {\n    Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);\n    return Modify.schema(this, options) || this;\n  }\n\n  $_mutateRebuild() {\n    Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');\n\n    this._refs.reset();\n\n    this._ids.reset();\n\n    const each = (item, _ref) => {\n      let {\n        source,\n        name,\n        path,\n        key\n      } = _ref;\n      const family = this._definition[source][name] && this._definition[source][name].register;\n\n      if (family !== false) {\n        this.$_mutateRegister(item, {\n          family,\n          key\n        });\n      }\n    };\n\n    this.$_modify({\n      each\n    });\n\n    if (this._definition.rebuild) {\n      this._definition.rebuild(this);\n    }\n\n    this.$_temp.ruleset = false;\n    return this;\n  }\n\n  $_mutateRegister(schema) {\n    let {\n      family,\n      key\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._refs.register(schema, family);\n\n    this._ids.register(schema, {\n      key\n    });\n  }\n\n  $_property(name) {\n    return this._definition.properties[name];\n  }\n\n  $_reach(path) {\n    return this._ids.reach(path);\n  }\n\n  $_rootReferences() {\n    return this._refs.roots();\n  }\n\n  $_setFlag(name, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');\n    const flag = this._definition.flags[name] || {};\n\n    if (DeepEqual(value, flag.default)) {\n      value = undefined;\n    }\n\n    if (DeepEqual(value, this._flags[name])) {\n      return this;\n    }\n\n    const obj = options.clone !== false ? this.clone() : this;\n\n    if (value !== undefined) {\n      obj._flags[name] = value;\n      obj.$_mutateRegister(value);\n    } else {\n      delete obj._flags[name];\n    }\n\n    if (name[0] !== '_') {\n      obj.$_temp.ruleset = false;\n    }\n\n    return obj;\n  }\n\n  $_validate(value, state, prefs) {\n    return Validator.validate(value, this, state, prefs);\n  } // Internals\n\n\n  _assign(target) {\n    target.type = this.type;\n    target.$_root = this.$_root;\n    target.$_temp = Object.assign({}, this.$_temp);\n    target.$_temp.whens = {};\n    target._ids = this._ids.clone();\n    target._preferences = this._preferences;\n    target._valids = this._valids && this._valids.clone();\n    target._invalids = this._invalids && this._invalids.clone();\n    target._rules = this._rules.slice();\n    target._singleRules = Clone(this._singleRules, {\n      shallow: true\n    });\n    target._refs = this._refs.clone();\n    target._flags = Object.assign({}, this._flags);\n    target._cache = null;\n    target.$_terms = {};\n\n    for (const key in this.$_terms) {\n      target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;\n    }\n\n    target.$_super = {};\n\n    for (const override in this.$_super) {\n      target.$_super[override] = this._super[override].bind(target);\n    }\n\n    return target;\n  }\n\n  _default(flag, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Common.assertOptions(options, 'literal');\n    Assert(value !== undefined, 'Missing', flag, 'value');\n    Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');\n\n    if (typeof value === 'function' && options.literal) {\n      value = {\n        [Common.symbols.literal]: true,\n        literal: value\n      };\n    }\n\n    const obj = this.$_setFlag(flag, value);\n    return obj;\n  }\n\n  _generate(value, state, prefs) {\n    if (!this.$_terms.whens) {\n      return {\n        schema: this\n      };\n    } // Collect matching whens\n\n\n    const whens = [];\n    const ids = [];\n\n    for (let i = 0; i < this.$_terms.whens.length; ++i) {\n      const when = this.$_terms.whens[i];\n\n      if (when.concat) {\n        whens.push(when.concat);\n        ids.push(`${i}.concat`);\n        continue;\n      }\n\n      const input = when.ref ? when.ref.resolve(value, state, prefs) : value;\n      const tests = when.is ? [when] : when.switch;\n      const before = ids.length;\n\n      for (let j = 0; j < tests.length; ++j) {\n        const {\n          is,\n          then,\n          otherwise\n        } = tests[j];\n        const baseId = `${i}${when.switch ? '.' + j : ''}`;\n\n        if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {\n          if (then) {\n            const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);\n\n            const {\n              schema: generated,\n              id\n            } = then._generate(value, localState, prefs);\n\n            whens.push(generated);\n            ids.push(`${baseId}.then${id ? `(${id})` : ''}`);\n            break;\n          }\n        } else if (otherwise) {\n          const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);\n\n          const {\n            schema: generated,\n            id\n          } = otherwise._generate(value, localState, prefs);\n\n          whens.push(generated);\n          ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);\n          break;\n        }\n      }\n\n      if (when.break && ids.length > before) {\n        // Something matched\n        break;\n      }\n    } // Check cache\n\n\n    const id = ids.join(', ');\n    state.mainstay.tracer.debug(state, 'rule', 'when', id);\n\n    if (!id) {\n      return {\n        schema: this\n      };\n    }\n\n    if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {\n      return {\n        schema: this.$_temp.whens[id],\n        id\n      };\n    } // Generate dynamic schema\n\n\n    let obj = this; // eslint-disable-line consistent-this\n\n    if (this._definition.generate) {\n      obj = this._definition.generate(this, value, state, prefs);\n    } // Apply whens\n\n\n    for (const when of whens) {\n      obj = obj.concat(when);\n    } // Tracing\n\n\n    if (this.$_root._tracer) {\n      this.$_root._tracer._combine(obj, [this, ...whens]);\n    } // Cache result\n\n\n    this.$_temp.whens[id] = obj;\n    return {\n      schema: obj,\n      id\n    };\n  }\n\n  _inner(type, values) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);\n    const obj = this.clone();\n\n    if (!obj.$_terms[type] || options.override) {\n      obj.$_terms[type] = [];\n    }\n\n    if (options.single) {\n      obj.$_terms[type].push(values);\n    } else {\n      obj.$_terms[type].push(...values);\n    }\n\n    obj.$_temp.ruleset = false;\n    return obj;\n  }\n\n  _inRuleset() {\n    return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;\n  }\n\n  _ruleRemove(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this._singleRules.has(name)) {\n      return this;\n    }\n\n    const obj = options.clone !== false ? this.clone() : this;\n\n    obj._singleRules.delete(name);\n\n    const filtered = [];\n\n    for (let i = 0; i < obj._rules.length; ++i) {\n      const test = obj._rules[i];\n\n      if (test.name === name && !test.keep) {\n        if (obj._inRuleset() && i < obj.$_temp.ruleset) {\n          --obj.$_temp.ruleset;\n        }\n\n        continue;\n      }\n\n      filtered.push(test);\n    }\n\n    obj._rules = filtered;\n    return obj;\n  }\n\n  _values(values, key) {\n    Common.verifyFlat(values, key.slice(1, -1));\n    const obj = this.clone();\n    const override = values[0] === Common.symbols.override;\n\n    if (override) {\n      values = values.slice(1);\n    }\n\n    if (!obj[key] && values.length) {\n      obj[key] = new Values();\n    } else if (override) {\n      obj[key] = values.length ? new Values() : null;\n      obj.$_mutateRebuild();\n    }\n\n    if (!obj[key]) {\n      return obj;\n    }\n\n    if (override) {\n      obj[key].override();\n    }\n\n    for (const value of values) {\n      Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n      Assert(value !== Common.symbols.override, 'Override must be the first value');\n      const other = key === '_invalids' ? '_valids' : '_invalids';\n\n      if (obj[other]) {\n        obj[other].remove(value);\n\n        if (!obj[other].length) {\n          Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');\n          obj[other] = null;\n        }\n      }\n\n      obj[key].add(value, obj._refs);\n    }\n\n    return obj;\n  }\n\n};\ninternals.Base.prototype[Common.symbols.any] = {\n  version: Common.version,\n  compile: Compile.compile,\n  root: '$_root'\n};\ninternals.Base.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects (must be on prototype)\n// Aliases\n\ninternals.Base.prototype.deny = internals.Base.prototype.invalid;\ninternals.Base.prototype.disallow = internals.Base.prototype.invalid;\ninternals.Base.prototype.equal = internals.Base.prototype.valid;\ninternals.Base.prototype.exist = internals.Base.prototype.required;\ninternals.Base.prototype.not = internals.Base.prototype.invalid;\ninternals.Base.prototype.options = internals.Base.prototype.prefs;\ninternals.Base.prototype.preferences = internals.Base.prototype.prefs;\nmodule.exports = new internals.Base();","map":{"version":3,"names":["Assert","require","Clone","DeepEqual","Merge","Cache","Common","Compile","Errors","Extend","Manifest","Messages","Modify","Ref","Trace","Validator","Values","internals","Base","constructor","type","$_root","_definition","_ids","Ids","_preferences","_refs","Manager","_cache","_valids","_invalids","_flags","_rules","_singleRules","Map","$_terms","$_temp","ruleset","whens","describe","allow","values","verifyFlat","_values","alter","targets","Array","isArray","_inRuleset","obj","clone","alterations","target","adjuster","push","cast","to","$_setFlag","undefined","default","value","options","_default","description","desc","empty","schema","$_compile","override","error","err","Error","example","assertOptions","_inner","single","external","method","failover","forbidden","presence","id","test","invalid","label","name","meta","note","notes","length","only","mode","optional","prefs","context","externals","warnings","debug","checkPreferences","preferences","includes","raw","enabled","result","required","strict","convert","strip","tag","tags","unit","valid","when","condition","conditions","is","switch","item","then","otherwise","$_mutateRebuild","cache","provider","provision","Object","create","getPrototypeOf","_assign","concat","source","isSchema","tmpObj","key","keys","register","toSibling","merge","has","filter","keep","delete","rules","multi","set","flags","assign","terms","slice","_tracer","_combine","extend","base","extract","path","split","reach","fork","paths","rule","def","modifiers","start","i","original","get","$","tailor","$_modify","each","ref","tracer","location","validate","entry","validateAsync","entryAsync","$_addRule","_resolve","definition","args","arg","argsByName","resolver","isResolvable","$_mutateRegister","normalize","assert","validateArg","_ruleRemove","priority","unshift","$_createError","code","local","state","messages","Report","$_getFlag","$_getRule","$_mapLabels","labels","$_match","overrides","abortEarly","_externals","snapshot","errors","restore","reset","family","rebuild","$_property","properties","$_reach","$_rootReferences","roots","flag","$_validate","shallow","$_super","_super","bind","literal","symbols","_generate","ids","input","resolve","tests","before","j","baseId","nest","localState","localize","ancestors","schemas","generated","break","join","mainstay","active","generate","filtered","other","remove","add","prototype","any","version","compile","root","isImmutable","deny","disallow","equal","exist","not","module","exports"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/base.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\nconst Merge = require('@hapi/hoek/lib/merge');\n\nconst Cache = require('./cache');\nconst Common = require('./common');\nconst Compile = require('./compile');\nconst Errors = require('./errors');\nconst Extend = require('./extend');\nconst Manifest = require('./manifest');\nconst Messages = require('./messages');\nconst Modify = require('./modify');\nconst Ref = require('./ref');\nconst Trace = require('./trace');\nconst Validator = require('./validator');\nconst Values = require('./values');\n\n\nconst internals = {};\n\n\ninternals.Base = class {\n\n    constructor(type) {\n\n        // Naming: public, _private, $_extension, $_mutate{action}\n\n        this.type = type;\n\n        this.$_root = null;\n        this._definition = {};\n        this._ids = new Modify.Ids();\n        this._preferences = null;\n        this._refs = new Ref.Manager();\n        this._cache = null;\n\n        this._valids = null;\n        this._invalids = null;\n\n        this._flags = {};\n        this._rules = [];\n        this._singleRules = new Map();              // The rule options passed for non-multi rules\n\n        this.$_terms = {};                          // Hash of arrays of immutable objects (extended by other types)\n\n        this.$_temp = {                             // Runtime state (not cloned)\n            ruleset: null,                          // null: use last, false: error, number: start position\n            whens: {}                               // Runtime cache of generated whens\n        };\n    }\n\n    // Manifest\n\n    describe() {\n\n        Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');\n        return Manifest.describe(this);\n    }\n\n    // Rules\n\n    allow(...values) {\n\n        Common.verifyFlat(values, 'allow');\n        return this._values(values, '_valids');\n    }\n\n    alter(targets) {\n\n        Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');\n        Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');\n\n        const obj = this.clone();\n        obj.$_terms.alterations = obj.$_terms.alterations || [];\n        for (const target in targets) {\n            const adjuster = targets[target];\n            Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');\n            obj.$_terms.alterations.push({ target, adjuster });\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    cast(to) {\n\n        Assert(to === false || typeof to === 'string', 'Invalid to value');\n        Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);\n\n        return this.$_setFlag('cast', to === false ? undefined : to);\n    }\n\n    default(value, options) {\n\n        return this._default('default', value, options);\n    }\n\n    description(desc) {\n\n        Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n        return this.$_setFlag('description', desc);\n    }\n\n    empty(schema) {\n\n        const obj = this.clone();\n\n        if (schema !== undefined) {\n            schema = obj.$_compile(schema, { override: false });\n        }\n\n        return obj.$_setFlag('empty', schema, { clone: false });\n    }\n\n    error(err) {\n\n        Assert(err, 'Missing error');\n        Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');\n\n        return this.$_setFlag('error', err);\n    }\n\n    example(example, options = {}) {\n\n        Assert(example !== undefined, 'Missing example');\n        Common.assertOptions(options, ['override']);\n\n        return this._inner('examples', example, { single: true, override: options.override });\n    }\n\n    external(method, description) {\n\n        if (typeof method === 'object') {\n            Assert(!description, 'Cannot combine options with description');\n            description = method.description;\n            method = method.method;\n        }\n\n        Assert(typeof method === 'function', 'Method must be a function');\n        Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');\n\n        return this._inner('externals', { method, description }, { single: true });\n    }\n\n    failover(value, options) {\n\n        return this._default('failover', value, options);\n    }\n\n    forbidden() {\n\n        return this.presence('forbidden');\n    }\n\n    id(id) {\n\n        if (!id) {\n            return this.$_setFlag('id', undefined);\n        }\n\n        Assert(typeof id === 'string', 'id must be a non-empty string');\n        Assert(/^[^\\.]+$/.test(id), 'id cannot contain period character');\n\n        return this.$_setFlag('id', id);\n    }\n\n    invalid(...values) {\n\n        return this._values(values, '_invalids');\n    }\n\n    label(name) {\n\n        Assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n        return this.$_setFlag('label', name);\n    }\n\n    meta(meta) {\n\n        Assert(meta !== undefined, 'Meta cannot be undefined');\n\n        return this._inner('metas', meta, { single: true });\n    }\n\n    note(...notes) {\n\n        Assert(notes.length, 'Missing notes');\n        for (const note of notes) {\n            Assert(note && typeof note === 'string', 'Notes must be non-empty strings');\n        }\n\n        return this._inner('notes', notes);\n    }\n\n    only(mode = true) {\n\n        Assert(typeof mode === 'boolean', 'Invalid mode:', mode);\n\n        return this.$_setFlag('only', mode);\n    }\n\n    optional() {\n\n        return this.presence('optional');\n    }\n\n    prefs(prefs) {\n\n        Assert(prefs, 'Missing preferences');\n        Assert(prefs.context === undefined, 'Cannot override context');\n        Assert(prefs.externals === undefined, 'Cannot override externals');\n        Assert(prefs.warnings === undefined, 'Cannot override warnings');\n        Assert(prefs.debug === undefined, 'Cannot override debug');\n\n        Common.checkPreferences(prefs);\n\n        const obj = this.clone();\n        obj._preferences = Common.preferences(obj._preferences, prefs);\n        return obj;\n    }\n\n    presence(mode) {\n\n        Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);\n\n        return this.$_setFlag('presence', mode);\n    }\n\n    raw(enabled = true) {\n\n        return this.$_setFlag('result', enabled ? 'raw' : undefined);\n    }\n\n    result(mode) {\n\n        Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);\n\n        return this.$_setFlag('result', mode);\n    }\n\n    required() {\n\n        return this.presence('required');\n    }\n\n    strict(enabled) {\n\n        const obj = this.clone();\n\n        const convert = enabled === undefined ? false : !enabled;\n        obj._preferences = Common.preferences(obj._preferences, { convert });\n        return obj;\n    }\n\n    strip(enabled = true) {\n\n        return this.$_setFlag('result', enabled ? 'strip' : undefined);\n    }\n\n    tag(...tags) {\n\n        Assert(tags.length, 'Missing tags');\n        for (const tag of tags) {\n            Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');\n        }\n\n        return this._inner('tags', tags);\n    }\n\n    unit(name) {\n\n        Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n        return this.$_setFlag('unit', name);\n    }\n\n    valid(...values) {\n\n        Common.verifyFlat(values, 'valid');\n\n        const obj = this.allow(...values);\n        obj.$_setFlag('only', !!obj._valids, { clone: false });\n        return obj;\n    }\n\n    when(condition, options) {\n\n        const obj = this.clone();\n\n        if (!obj.$_terms.whens) {\n            obj.$_terms.whens = [];\n        }\n\n        const when = Compile.when(obj, condition, options);\n        if (!['any', 'link'].includes(obj.type)) {\n            const conditions = when.is ? [when] : when.switch;\n            for (const item of conditions) {\n                Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);\n                Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);\n\n            }\n        }\n\n        obj.$_terms.whens.push(when);\n        return obj.$_mutateRebuild();\n    }\n\n    // Helpers\n\n    cache(cache) {\n\n        Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');\n        Assert(!this._cache, 'Cannot override schema cache');\n\n        const obj = this.clone();\n        obj._cache = cache || Cache.provider.provision();\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    clone() {\n\n        const obj = Object.create(Object.getPrototypeOf(this));\n        return this._assign(obj);\n    }\n\n    concat(source) {\n\n        Assert(Common.isSchema(source), 'Invalid schema object');\n        Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);\n        Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');\n        Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');\n\n        let obj = this.clone();\n\n        if (this.type === 'any' &&\n            source.type !== 'any') {\n\n            // Change obj to match source type\n\n            const tmpObj = source.clone();\n            for (const key of Object.keys(obj)) {\n                if (key !== 'type') {\n                    tmpObj[key] = obj[key];\n                }\n            }\n\n            obj = tmpObj;\n        }\n\n        obj._ids.concat(source._ids);\n        obj._refs.register(source, Ref.toSibling);\n\n        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;\n        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);\n        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);\n\n        // Remove unique rules present in source\n\n        for (const name of source._singleRules.keys()) {\n            if (obj._singleRules.has(name)) {\n                obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);\n                obj._singleRules.delete(name);\n            }\n        }\n\n        // Rules\n\n        for (const test of source._rules) {\n            if (!source._definition.rules[test.method].multi) {\n                obj._singleRules.set(test.name, test);\n            }\n\n            obj._rules.push(test);\n        }\n\n        // Flags\n\n        if (obj._flags.empty &&\n            source._flags.empty) {\n\n            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        }\n        else if (source._flags.empty) {\n            obj._flags.empty = source._flags.empty;\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        }\n        else {\n            Merge(obj._flags, source._flags);\n        }\n\n        // Terms\n\n        for (const key in source.$_terms) {\n            const terms = source.$_terms[key];\n            if (!terms) {\n                if (!obj.$_terms[key]) {\n                    obj.$_terms[key] = terms;\n                }\n\n                continue;\n            }\n\n            if (!obj.$_terms[key]) {\n                obj.$_terms[key] = terms.slice();\n                continue;\n            }\n\n            obj.$_terms[key] = obj.$_terms[key].concat(terms);\n        }\n\n        // Tracing\n\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [this, source]);\n        }\n\n        // Rebuild\n\n        return obj.$_mutateRebuild();\n    }\n\n    extend(options) {\n\n        Assert(!options.base, 'Cannot extend type with another base');\n\n        return Extend.type(this, options);\n    }\n\n    extract(path) {\n\n        path = Array.isArray(path) ? path : path.split('.');\n        return this._ids.reach(path);\n    }\n\n    fork(paths, adjuster) {\n\n        Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');\n\n        let obj = this;                                             // eslint-disable-line consistent-this\n        for (let path of [].concat(paths)) {\n            path = Array.isArray(path) ? path : path.split('.');\n            obj = obj._ids.fork(path, adjuster, obj);\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    rule(options) {\n\n        const def = this._definition;\n        Common.assertOptions(options, Object.keys(def.modifiers));\n\n        Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');\n        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;\n        Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');\n\n        const obj = this.clone();\n\n        for (let i = start; i < obj._rules.length; ++i) {\n            const original = obj._rules[i];\n            const rule = Clone(original);\n\n            for (const name in options) {\n                def.modifiers[name](rule, options[name]);\n                Assert(rule.name === original.name, 'Cannot change rule name');\n            }\n\n            obj._rules[i] = rule;\n\n            if (obj._singleRules.get(rule.name) === original) {\n                obj._singleRules.set(rule.name, rule);\n            }\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n\n    get ruleset() {\n\n        Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');\n\n        const obj = this.clone();\n        obj.$_temp.ruleset = obj._rules.length;\n        return obj;\n    }\n\n    get $() {\n\n        return this.ruleset;\n    }\n\n    tailor(targets) {\n\n        targets = [].concat(targets);\n\n        Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');\n\n        let obj = this;                                                     // eslint-disable-line consistent-this\n\n        if (this.$_terms.alterations) {\n            for (const { target, adjuster } of this.$_terms.alterations) {\n                if (targets.includes(target)) {\n                    obj = adjuster(obj);\n                    Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');\n                }\n            }\n        }\n\n        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n\n    tracer() {\n\n        return Trace.location ? Trace.location(this) : this;                // $lab:coverage:ignore$\n    }\n\n    validate(value, options) {\n\n        return Validator.entry(value, this, options);\n    }\n\n    validateAsync(value, options) {\n\n        return Validator.entryAsync(value, this, options);\n    }\n\n    // Extensions\n\n    $_addRule(options) {\n\n        // Normalize rule\n\n        if (typeof options === 'string') {\n            options = { name: options };\n        }\n\n        Assert(options && typeof options === 'object', 'Invalid options');\n        Assert(options.name && typeof options.name === 'string', 'Invalid rule name');\n\n        for (const key in options) {\n            Assert(key[0] !== '_', 'Cannot set private rule properties');\n        }\n\n        const rule = Object.assign({}, options);        // Shallow cloned\n        rule._resolve = [];\n        rule.method = rule.method || rule.name;\n\n        const definition = this._definition.rules[rule.method];\n        const args = rule.args;\n\n        Assert(definition, 'Unknown rule', rule.method);\n\n        // Args\n\n        const obj = this.clone();\n\n        if (args) {\n            Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);\n\n            for (const key in args) {\n                let arg = args[key];\n                if (arg === undefined) {\n                    delete args[key];\n                    continue;\n                }\n\n                if (definition.argsByName) {\n                    const resolver = definition.argsByName.get(key);\n\n                    if (resolver.ref &&\n                        Common.isResolvable(arg)) {\n\n                        rule._resolve.push(key);\n                        obj.$_mutateRegister(arg);\n                    }\n                    else {\n                        if (resolver.normalize) {\n                            arg = resolver.normalize(arg);\n                            args[key] = arg;\n                        }\n\n                        if (resolver.assert) {\n                            const error = Common.validateArg(arg, key, resolver);\n                            Assert(!error, error, 'or reference');\n                        }\n                    }\n                }\n\n                args[key] = arg;\n            }\n        }\n\n        // Unique rules\n\n        if (!definition.multi) {\n            obj._ruleRemove(rule.name, { clone: false });\n            obj._singleRules.set(rule.name, rule);\n        }\n\n        if (obj.$_temp.ruleset === false) {\n            obj.$_temp.ruleset = null;\n        }\n\n        if (definition.priority) {\n            obj._rules.unshift(rule);\n        }\n        else {\n            obj._rules.push(rule);\n        }\n\n        return obj;\n    }\n\n    $_compile(schema, options) {\n\n        return Compile.schema(this.$_root, schema, options);\n    }\n\n    $_createError(code, value, local, state, prefs, options = {}) {\n\n        const flags = options.flags !== false ? this._flags : {};\n        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;\n        return new Errors.Report(code, value, local, flags, messages, state, prefs);\n    }\n\n    $_getFlag(name) {\n\n        return this._flags[name];\n    }\n\n    $_getRule(name) {\n\n        return this._singleRules.get(name);\n    }\n\n    $_mapLabels(path) {\n\n        path = Array.isArray(path) ? path : path.split('.');\n        return this._ids.labels(path);\n    }\n\n    $_match(value, state, prefs, overrides) {\n\n        prefs = Object.assign({}, prefs);       // Shallow cloned\n        prefs.abortEarly = true;\n        prefs._externals = false;\n\n        state.snapshot();\n        const result = !Validator.validate(value, this, state, prefs, overrides).errors;\n        state.restore();\n\n        return result;\n    }\n\n    $_modify(options) {\n\n        Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);\n        return Modify.schema(this, options) || this;\n    }\n\n    $_mutateRebuild() {\n\n        Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');\n\n        this._refs.reset();\n        this._ids.reset();\n\n        const each = (item, { source, name, path, key }) => {\n\n            const family = this._definition[source][name] && this._definition[source][name].register;\n            if (family !== false) {\n                this.$_mutateRegister(item, { family, key });\n            }\n        };\n\n        this.$_modify({ each });\n\n        if (this._definition.rebuild) {\n            this._definition.rebuild(this);\n        }\n\n        this.$_temp.ruleset = false;\n        return this;\n    }\n\n    $_mutateRegister(schema, { family, key } = {}) {\n\n        this._refs.register(schema, family);\n        this._ids.register(schema, { key });\n    }\n\n    $_property(name) {\n\n        return this._definition.properties[name];\n    }\n\n    $_reach(path) {\n\n        return this._ids.reach(path);\n    }\n\n    $_rootReferences() {\n\n        return this._refs.roots();\n    }\n\n    $_setFlag(name, value, options = {}) {\n\n        Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');\n\n        const flag = this._definition.flags[name] || {};\n        if (DeepEqual(value, flag.default)) {\n            value = undefined;\n        }\n\n        if (DeepEqual(value, this._flags[name])) {\n            return this;\n        }\n\n        const obj = options.clone !== false ? this.clone() : this;\n\n        if (value !== undefined) {\n            obj._flags[name] = value;\n            obj.$_mutateRegister(value);\n        }\n        else {\n            delete obj._flags[name];\n        }\n\n        if (name[0] !== '_') {\n            obj.$_temp.ruleset = false;\n        }\n\n        return obj;\n    }\n\n    $_validate(value, state, prefs) {\n\n        return Validator.validate(value, this, state, prefs);\n    }\n\n    // Internals\n\n    _assign(target) {\n\n        target.type = this.type;\n\n        target.$_root = this.$_root;\n\n        target.$_temp = Object.assign({}, this.$_temp);\n        target.$_temp.whens = {};\n\n        target._ids = this._ids.clone();\n        target._preferences = this._preferences;\n        target._valids = this._valids && this._valids.clone();\n        target._invalids = this._invalids && this._invalids.clone();\n        target._rules = this._rules.slice();\n        target._singleRules = Clone(this._singleRules, { shallow: true });\n        target._refs = this._refs.clone();\n        target._flags = Object.assign({}, this._flags);\n        target._cache = null;\n\n        target.$_terms = {};\n        for (const key in this.$_terms) {\n            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;\n        }\n\n        target.$_super = {};\n        for (const override in this.$_super) {\n            target.$_super[override] = this._super[override].bind(target);\n        }\n\n        return target;\n    }\n\n    _default(flag, value, options = {}) {\n\n        Common.assertOptions(options, 'literal');\n\n        Assert(value !== undefined, 'Missing', flag, 'value');\n        Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');\n\n        if (typeof value === 'function' &&\n            options.literal) {\n\n            value = {\n                [Common.symbols.literal]: true,\n                literal: value\n            };\n        }\n\n        const obj = this.$_setFlag(flag, value);\n        return obj;\n    }\n\n    _generate(value, state, prefs) {\n\n        if (!this.$_terms.whens) {\n            return { schema: this };\n        }\n\n        // Collect matching whens\n\n        const whens = [];\n        const ids = [];\n        for (let i = 0; i < this.$_terms.whens.length; ++i) {\n            const when = this.$_terms.whens[i];\n\n            if (when.concat) {\n                whens.push(when.concat);\n                ids.push(`${i}.concat`);\n                continue;\n            }\n\n            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;\n            const tests = when.is ? [when] : when.switch;\n            const before = ids.length;\n\n            for (let j = 0; j < tests.length; ++j) {\n                const { is, then, otherwise } = tests[j];\n\n                const baseId = `${i}${when.switch ? '.' + j : ''}`;\n                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {\n                    if (then) {\n                        const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);\n                        const { schema: generated, id } = then._generate(value, localState, prefs);\n                        whens.push(generated);\n                        ids.push(`${baseId}.then${id ? `(${id})` : ''}`);\n                        break;\n                    }\n                }\n                else if (otherwise) {\n                    const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);\n                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);\n                    whens.push(generated);\n                    ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);\n                    break;\n                }\n            }\n\n            if (when.break &&\n                ids.length > before) {          // Something matched\n\n                break;\n            }\n        }\n\n        // Check cache\n\n        const id = ids.join(', ');\n        state.mainstay.tracer.debug(state, 'rule', 'when', id);\n\n        if (!id) {\n            return { schema: this };\n        }\n\n        if (!state.mainstay.tracer.active &&\n            this.$_temp.whens[id]) {\n\n            return { schema: this.$_temp.whens[id], id };\n        }\n\n        // Generate dynamic schema\n\n        let obj = this;                                             // eslint-disable-line consistent-this\n        if (this._definition.generate) {\n            obj = this._definition.generate(this, value, state, prefs);\n        }\n\n        // Apply whens\n\n        for (const when of whens) {\n            obj = obj.concat(when);\n        }\n\n        // Tracing\n\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [this, ...whens]);\n        }\n\n        // Cache result\n\n        this.$_temp.whens[id] = obj;\n        return { schema: obj, id };\n    }\n\n    _inner(type, values, options = {}) {\n\n        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);\n\n        const obj = this.clone();\n        if (!obj.$_terms[type] ||\n            options.override) {\n\n            obj.$_terms[type] = [];\n        }\n\n        if (options.single) {\n            obj.$_terms[type].push(values);\n        }\n        else {\n            obj.$_terms[type].push(...values);\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    _inRuleset() {\n\n        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;\n    }\n\n    _ruleRemove(name, options = {}) {\n\n        if (!this._singleRules.has(name)) {\n            return this;\n        }\n\n        const obj = options.clone !== false ? this.clone() : this;\n\n        obj._singleRules.delete(name);\n\n        const filtered = [];\n        for (let i = 0; i < obj._rules.length; ++i) {\n            const test = obj._rules[i];\n            if (test.name === name &&\n                !test.keep) {\n\n                if (obj._inRuleset() &&\n                    i < obj.$_temp.ruleset) {\n\n                    --obj.$_temp.ruleset;\n                }\n\n                continue;\n            }\n\n            filtered.push(test);\n        }\n\n        obj._rules = filtered;\n        return obj;\n    }\n\n    _values(values, key) {\n\n        Common.verifyFlat(values, key.slice(1, -1));\n\n        const obj = this.clone();\n\n        const override = values[0] === Common.symbols.override;\n        if (override) {\n            values = values.slice(1);\n        }\n\n        if (!obj[key] &&\n            values.length) {\n\n            obj[key] = new Values();\n        }\n        else if (override) {\n            obj[key] = values.length ? new Values() : null;\n            obj.$_mutateRebuild();\n        }\n\n        if (!obj[key]) {\n            return obj;\n        }\n\n        if (override) {\n            obj[key].override();\n        }\n\n        for (const value of values) {\n            Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            Assert(value !== Common.symbols.override, 'Override must be the first value');\n\n            const other = key === '_invalids' ? '_valids' : '_invalids';\n            if (obj[other]) {\n                obj[other].remove(value);\n                if (!obj[other].length) {\n                    Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');\n                    obj[other] = null;\n                }\n            }\n\n            obj[key].add(value, obj._refs);\n        }\n\n        return obj;\n    }\n};\n\n\ninternals.Base.prototype[Common.symbols.any] = {\n    version: Common.version,\n    compile: Compile.compile,\n    root: '$_root'\n};\n\n\ninternals.Base.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects (must be on prototype)\n\n\n// Aliases\n\ninternals.Base.prototype.deny = internals.Base.prototype.invalid;\ninternals.Base.prototype.disallow = internals.Base.prototype.invalid;\ninternals.Base.prototype.equal = internals.Base.prototype.valid;\ninternals.Base.prototype.exist = internals.Base.prototype.required;\ninternals.Base.prototype.not = internals.Base.prototype.invalid;\ninternals.Base.prototype.options = internals.Base.prototype.prefs;\ninternals.Base.prototype.preferences = internals.Base.prototype.prefs;\n\n\nmodule.exports = new internals.Base();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}