{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst internals = {};\nmodule.exports = Any.extend({\n  type: 'binary',\n  coerce: {\n    from: 'string',\n\n    method(value, _ref) {\n      let {\n        schema\n      } = _ref;\n\n      try {\n        return {\n          value: Buffer.from(value, schema._flags.encoding)\n        };\n      } catch (ignoreErr) {}\n    }\n\n  },\n\n  validate(value, _ref2) {\n    let {\n      error\n    } = _ref2;\n\n    if (!Buffer.isBuffer(value)) {\n      return {\n        value,\n        errors: error('binary.base')\n      };\n    }\n  },\n\n  rules: {\n    encoding: {\n      method(encoding) {\n        Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n        return this.$_setFlag('encoding', encoding);\n      }\n\n    },\n    length: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'length',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '='\n        });\n      },\n\n      validate(value, helpers, _ref3, _ref4) {\n        let {\n          limit\n        } = _ref3;\n        let {\n          name,\n          operator,\n          args\n        } = _ref4;\n\n        if (Common.compare(value.length, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('binary.' + name, {\n          limit: args.limit,\n          value\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.limit,\n        message: 'must be a positive integer'\n      }]\n    },\n    max: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'max',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '<='\n        });\n      }\n\n    },\n    min: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'min',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '>='\n        });\n      }\n\n    }\n  },\n  cast: {\n    string: {\n      from: value => Buffer.isBuffer(value),\n\n      to(value, helpers) {\n        return value.toString();\n      }\n\n    }\n  },\n  messages: {\n    'binary.base': '{{#label}} must be a buffer or a string',\n    'binary.length': '{{#label}} must be {{#limit}} bytes',\n    'binary.max': '{{#label}} must be less than or equal to {{#limit}} bytes',\n    'binary.min': '{{#label}} must be at least {{#limit}} bytes'\n  }\n});","map":{"version":3,"names":["Assert","require","Any","Common","internals","module","exports","extend","type","coerce","from","method","value","schema","Buffer","_flags","encoding","ignoreErr","validate","error","isBuffer","errors","rules","isEncoding","$_setFlag","length","limit","$_addRule","name","args","operator","helpers","compare","ref","assert","message","max","min","cast","string","to","toString","messages"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/types/binary.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\nconst Common = require('../common');\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'binary',\n\n    coerce: {\n        from: 'string',\n        method(value, { schema }) {\n\n            try {\n                return { value: Buffer.from(value, schema._flags.encoding) };\n            }\n            catch (ignoreErr) { }\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (!Buffer.isBuffer(value)) {\n            return { value, errors: error('binary.base') };\n        }\n    },\n\n    rules: {\n        encoding: {\n            method(encoding) {\n\n                Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n                return this.$_setFlag('encoding', encoding);\n            }\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', method: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('binary.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        }\n    },\n\n    cast: {\n        string: {\n            from: (value) => Buffer.isBuffer(value),\n            to(value, helpers) {\n\n                return value.toString();\n            }\n        }\n    },\n\n    messages: {\n        'binary.base': '{{#label}} must be a buffer or a string',\n        'binary.length': '{{#label}} must be {{#limit}} bytes',\n        'binary.max': '{{#label}} must be less than or equal to {{#limit}} bytes',\n        'binary.min': '{{#label}} must be at least {{#limit}} bytes'\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}