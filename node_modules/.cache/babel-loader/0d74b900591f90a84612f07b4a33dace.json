{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\n\nconst Messages = require('./messages');\n\nconst Ref = require('./ref');\n\nconst Template = require('./template');\n\nlet Schemas;\nconst internals = {};\n\nexports.describe = function (schema) {\n  const def = schema._definition; // Type\n\n  const desc = {\n    type: schema.type,\n    flags: {},\n    rules: []\n  }; // Flags\n\n  for (const flag in schema._flags) {\n    if (flag[0] !== '_') {\n      desc.flags[flag] = internals.describe(schema._flags[flag]);\n    }\n  }\n\n  if (!Object.keys(desc.flags).length) {\n    delete desc.flags;\n  } // Preferences\n\n\n  if (schema._preferences) {\n    desc.preferences = Clone(schema._preferences, {\n      shallow: ['messages']\n    });\n    delete desc.preferences[Common.symbols.prefs];\n\n    if (desc.preferences.messages) {\n      desc.preferences.messages = Messages.decompile(desc.preferences.messages);\n    }\n  } // Allow / Invalid\n\n\n  if (schema._valids) {\n    desc.allow = schema._valids.describe();\n  }\n\n  if (schema._invalids) {\n    desc.invalid = schema._invalids.describe();\n  } // Rules\n\n\n  for (const rule of schema._rules) {\n    const ruleDef = def.rules[rule.name];\n\n    if (ruleDef.manifest === false) {\n      // Defaults to true\n      continue;\n    }\n\n    const item = {\n      name: rule.name\n    };\n\n    for (const custom in def.modifiers) {\n      if (rule[custom] !== undefined) {\n        item[custom] = internals.describe(rule[custom]);\n      }\n    }\n\n    if (rule.args) {\n      item.args = {};\n\n      for (const key in rule.args) {\n        const arg = rule.args[key];\n\n        if (key === 'options' && !Object.keys(arg).length) {\n          continue;\n        }\n\n        item.args[key] = internals.describe(arg, {\n          assign: key\n        });\n      }\n\n      if (!Object.keys(item.args).length) {\n        delete item.args;\n      }\n    }\n\n    desc.rules.push(item);\n  }\n\n  if (!desc.rules.length) {\n    delete desc.rules;\n  } // Terms (must be last to verify no name conflicts)\n\n\n  for (const term in schema.$_terms) {\n    if (term[0] === '_') {\n      continue;\n    }\n\n    Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);\n    const items = schema.$_terms[term];\n\n    if (!items) {\n      continue;\n    }\n\n    if (items instanceof Map) {\n      if (items.size) {\n        desc[term] = [...items.entries()];\n      }\n\n      continue;\n    }\n\n    if (Common.isValues(items)) {\n      desc[term] = items.describe();\n      continue;\n    }\n\n    Assert(def.terms[term], 'Term', term, 'missing configuration');\n    const manifest = def.terms[term].manifest;\n    const mapped = typeof manifest === 'object';\n\n    if (!items.length && !mapped) {\n      continue;\n    }\n\n    const normalized = [];\n\n    for (const item of items) {\n      normalized.push(internals.describe(item));\n    } // Mapped\n\n\n    if (mapped) {\n      const {\n        from,\n        to\n      } = manifest.mapped;\n      desc[term] = {};\n\n      for (const item of normalized) {\n        desc[term][item[to]] = item[from];\n      }\n\n      continue;\n    } // Single\n\n\n    if (manifest === 'single') {\n      Assert(normalized.length === 1, 'Term', term, 'contains more than one item');\n      desc[term] = normalized[0];\n      continue;\n    } // Array\n\n\n    desc[term] = normalized;\n  }\n\n  internals.validate(schema.$_root, desc);\n  return desc;\n};\n\ninternals.describe = function (item) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (Array.isArray(item)) {\n    return item.map(internals.describe);\n  }\n\n  if (item === Common.symbols.deepDefault) {\n    return {\n      special: 'deep'\n    };\n  }\n\n  if (typeof item !== 'object' || item === null) {\n    return item;\n  }\n\n  if (options.assign === 'options') {\n    return Clone(item);\n  }\n\n  if (Buffer && Buffer.isBuffer(item)) {\n    // $lab:coverage:ignore$\n    return {\n      buffer: item.toString('binary')\n    };\n  }\n\n  if (item instanceof Date) {\n    return item.toISOString();\n  }\n\n  if (item instanceof Error) {\n    return item;\n  }\n\n  if (item instanceof RegExp) {\n    if (options.assign === 'regex') {\n      return item.toString();\n    }\n\n    return {\n      regex: item.toString()\n    };\n  }\n\n  if (item[Common.symbols.literal]) {\n    return {\n      function: item.literal\n    };\n  }\n\n  if (typeof item.describe === 'function') {\n    if (options.assign === 'ref') {\n      return item.describe().ref;\n    }\n\n    return item.describe();\n  }\n\n  const normalized = {};\n\n  for (const key in item) {\n    const value = item[key];\n\n    if (value === undefined) {\n      continue;\n    }\n\n    normalized[key] = internals.describe(value, {\n      assign: key\n    });\n  }\n\n  return normalized;\n};\n\nexports.build = function (joi, desc) {\n  const builder = new internals.Builder(joi);\n  return builder.parse(desc);\n};\n\ninternals.Builder = class {\n  constructor(joi) {\n    this.joi = joi;\n  }\n\n  parse(desc) {\n    internals.validate(this.joi, desc); // Type\n\n    let schema = this.joi[desc.type]();\n    const def = schema._definition; // Flags\n\n    if (desc.flags) {\n      for (const flag in desc.flags) {\n        const setter = def.flags[flag] && def.flags[flag].setter || flag;\n        Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);\n        schema = schema[setter](this.build(desc.flags[flag]));\n      }\n    } // Preferences\n\n\n    if (desc.preferences) {\n      schema = schema.preferences(this.build(desc.preferences));\n    } // Allow / Invalid\n\n\n    if (desc.allow) {\n      schema = schema.allow(...this.build(desc.allow));\n    }\n\n    if (desc.invalid) {\n      schema = schema.invalid(...this.build(desc.invalid));\n    } // Rules\n\n\n    if (desc.rules) {\n      for (const rule of desc.rules) {\n        Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);\n        const args = [];\n\n        if (rule.args) {\n          const built = {};\n\n          for (const key in rule.args) {\n            built[key] = this.build(rule.args[key], {\n              assign: key\n            });\n          }\n\n          const keys = Object.keys(built);\n          const definition = def.rules[rule.name].args;\n\n          if (definition) {\n            Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');\n\n            for (const {\n              name\n            } of definition) {\n              args.push(built[name]);\n            }\n          } else {\n            Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');\n            args.push(built[keys[0]]);\n          }\n        } // Apply\n\n\n        schema = schema[rule.name](...args); // Ruleset\n\n        const options = {};\n\n        for (const custom in def.modifiers) {\n          if (rule[custom] !== undefined) {\n            options[custom] = this.build(rule[custom]);\n          }\n        }\n\n        if (Object.keys(options).length) {\n          schema = schema.rule(options);\n        }\n      }\n    } // Terms\n\n\n    const terms = {};\n\n    for (const key in desc) {\n      if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {\n        continue;\n      }\n\n      Assert(def.terms[key], 'Term', key, 'missing configuration');\n      const manifest = def.terms[key].manifest;\n\n      if (manifest === 'schema') {\n        terms[key] = desc[key].map(item => this.parse(item));\n        continue;\n      }\n\n      if (manifest === 'values') {\n        terms[key] = desc[key].map(item => this.build(item));\n        continue;\n      }\n\n      if (manifest === 'single') {\n        terms[key] = this.build(desc[key]);\n        continue;\n      }\n\n      if (typeof manifest === 'object') {\n        terms[key] = {};\n\n        for (const name in desc[key]) {\n          const value = desc[key][name];\n          terms[key][name] = this.parse(value);\n        }\n\n        continue;\n      }\n\n      terms[key] = this.build(desc[key]);\n    }\n\n    if (desc.whens) {\n      terms.whens = desc.whens.map(when => this.build(when));\n    }\n\n    schema = def.manifest.build(schema, terms);\n    schema.$_temp.ruleset = false;\n    return schema;\n  }\n\n  build(desc) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (desc === null) {\n      return null;\n    }\n\n    if (Array.isArray(desc)) {\n      return desc.map(item => this.build(item));\n    }\n\n    if (desc instanceof Error) {\n      return desc;\n    }\n\n    if (options.assign === 'options') {\n      return Clone(desc);\n    }\n\n    if (options.assign === 'regex') {\n      return internals.regex(desc);\n    }\n\n    if (options.assign === 'ref') {\n      return Ref.build(desc);\n    }\n\n    if (typeof desc !== 'object') {\n      return desc;\n    }\n\n    if (Object.keys(desc).length === 1) {\n      if (desc.buffer) {\n        Assert(Buffer, 'Buffers are not supported');\n        return Buffer && Buffer.from(desc.buffer, 'binary'); // $lab:coverage:ignore$\n      }\n\n      if (desc.function) {\n        return {\n          [Common.symbols.literal]: true,\n          literal: desc.function\n        };\n      }\n\n      if (desc.override) {\n        return Common.symbols.override;\n      }\n\n      if (desc.ref) {\n        return Ref.build(desc.ref);\n      }\n\n      if (desc.regex) {\n        return internals.regex(desc.regex);\n      }\n\n      if (desc.special) {\n        Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);\n        return Common.symbols.deepDefault;\n      }\n\n      if (desc.value) {\n        return Clone(desc.value);\n      }\n    }\n\n    if (desc.type) {\n      return this.parse(desc);\n    }\n\n    if (desc.template) {\n      return Template.build(desc);\n    }\n\n    const normalized = {};\n\n    for (const key in desc) {\n      normalized[key] = this.build(desc[key], {\n        assign: key\n      });\n    }\n\n    return normalized;\n  }\n\n};\n\ninternals.regex = function (string) {\n  const end = string.lastIndexOf('/');\n  const exp = string.slice(1, end);\n  const flags = string.slice(end + 1);\n  return new RegExp(exp, flags);\n};\n\ninternals.validate = function (joi, desc) {\n  Schemas = Schemas || require('./schemas');\n  joi.assert(desc, Schemas.description);\n};","map":{"version":3,"names":["Assert","require","Clone","Common","Messages","Ref","Template","Schemas","internals","exports","describe","schema","def","_definition","desc","type","flags","rules","flag","_flags","Object","keys","length","_preferences","preferences","shallow","symbols","prefs","messages","decompile","_valids","allow","_invalids","invalid","rule","_rules","ruleDef","name","manifest","item","custom","modifiers","undefined","args","key","arg","assign","push","term","$_terms","items","Map","size","entries","isValues","terms","mapped","normalized","from","to","validate","$_root","options","Array","isArray","map","deepDefault","special","Buffer","isBuffer","buffer","toString","Date","toISOString","Error","RegExp","regex","literal","function","ref","value","build","joi","builder","Builder","parse","constructor","setter","built","definition","includes","whens","when","$_temp","ruleset","override","template","string","end","lastIndexOf","exp","slice","assert","description"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/manifest.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\nconst Messages = require('./messages');\nconst Ref = require('./ref');\nconst Template = require('./template');\n\nlet Schemas;\n\n\nconst internals = {};\n\n\nexports.describe = function (schema) {\n\n    const def = schema._definition;\n\n    // Type\n\n    const desc = {\n        type: schema.type,\n        flags: {},\n        rules: []\n    };\n\n    // Flags\n\n    for (const flag in schema._flags) {\n        if (flag[0] !== '_') {\n            desc.flags[flag] = internals.describe(schema._flags[flag]);\n        }\n    }\n\n    if (!Object.keys(desc.flags).length) {\n        delete desc.flags;\n    }\n\n    // Preferences\n\n    if (schema._preferences) {\n        desc.preferences = Clone(schema._preferences, { shallow: ['messages'] });\n        delete desc.preferences[Common.symbols.prefs];\n        if (desc.preferences.messages) {\n            desc.preferences.messages = Messages.decompile(desc.preferences.messages);\n        }\n    }\n\n    // Allow / Invalid\n\n    if (schema._valids) {\n        desc.allow = schema._valids.describe();\n    }\n\n    if (schema._invalids) {\n        desc.invalid = schema._invalids.describe();\n    }\n\n    // Rules\n\n    for (const rule of schema._rules) {\n        const ruleDef = def.rules[rule.name];\n        if (ruleDef.manifest === false) {                           // Defaults to true\n            continue;\n        }\n\n        const item = { name: rule.name };\n\n        for (const custom in def.modifiers) {\n            if (rule[custom] !== undefined) {\n                item[custom] = internals.describe(rule[custom]);\n            }\n        }\n\n        if (rule.args) {\n            item.args = {};\n            for (const key in rule.args) {\n                const arg = rule.args[key];\n                if (key === 'options' &&\n                    !Object.keys(arg).length) {\n\n                    continue;\n                }\n\n                item.args[key] = internals.describe(arg, { assign: key });\n            }\n\n            if (!Object.keys(item.args).length) {\n                delete item.args;\n            }\n        }\n\n        desc.rules.push(item);\n    }\n\n    if (!desc.rules.length) {\n        delete desc.rules;\n    }\n\n    // Terms (must be last to verify no name conflicts)\n\n    for (const term in schema.$_terms) {\n        if (term[0] === '_') {\n            continue;\n        }\n\n        Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);\n\n        const items = schema.$_terms[term];\n        if (!items) {\n            continue;\n        }\n\n        if (items instanceof Map) {\n            if (items.size) {\n                desc[term] = [...items.entries()];\n            }\n\n            continue;\n        }\n\n        if (Common.isValues(items)) {\n            desc[term] = items.describe();\n            continue;\n        }\n\n        Assert(def.terms[term], 'Term', term, 'missing configuration');\n        const manifest = def.terms[term].manifest;\n        const mapped = typeof manifest === 'object';\n        if (!items.length &&\n            !mapped) {\n\n            continue;\n        }\n\n        const normalized = [];\n        for (const item of items) {\n            normalized.push(internals.describe(item));\n        }\n\n        // Mapped\n\n        if (mapped) {\n            const { from, to } = manifest.mapped;\n            desc[term] = {};\n            for (const item of normalized) {\n                desc[term][item[to]] = item[from];\n            }\n\n            continue;\n        }\n\n        // Single\n\n        if (manifest === 'single') {\n            Assert(normalized.length === 1, 'Term', term, 'contains more than one item');\n            desc[term] = normalized[0];\n            continue;\n        }\n\n        // Array\n\n        desc[term] = normalized;\n    }\n\n    internals.validate(schema.$_root, desc);\n    return desc;\n};\n\n\ninternals.describe = function (item, options = {}) {\n\n    if (Array.isArray(item)) {\n        return item.map(internals.describe);\n    }\n\n    if (item === Common.symbols.deepDefault) {\n        return { special: 'deep' };\n    }\n\n    if (typeof item !== 'object' ||\n        item === null) {\n\n        return item;\n    }\n\n    if (options.assign === 'options') {\n        return Clone(item);\n    }\n\n    if (Buffer && Buffer.isBuffer(item)) {                          // $lab:coverage:ignore$\n        return { buffer: item.toString('binary') };\n    }\n\n    if (item instanceof Date) {\n        return item.toISOString();\n    }\n\n    if (item instanceof Error) {\n        return item;\n    }\n\n    if (item instanceof RegExp) {\n        if (options.assign === 'regex') {\n            return item.toString();\n        }\n\n        return { regex: item.toString() };\n    }\n\n    if (item[Common.symbols.literal]) {\n        return { function: item.literal };\n    }\n\n    if (typeof item.describe === 'function') {\n        if (options.assign === 'ref') {\n            return item.describe().ref;\n        }\n\n        return item.describe();\n    }\n\n    const normalized = {};\n    for (const key in item) {\n        const value = item[key];\n        if (value === undefined) {\n            continue;\n        }\n\n        normalized[key] = internals.describe(value, { assign: key });\n    }\n\n    return normalized;\n};\n\n\nexports.build = function (joi, desc) {\n\n    const builder = new internals.Builder(joi);\n    return builder.parse(desc);\n};\n\n\ninternals.Builder = class {\n\n    constructor(joi) {\n\n        this.joi = joi;\n    }\n\n    parse(desc) {\n\n        internals.validate(this.joi, desc);\n\n        // Type\n\n        let schema = this.joi[desc.type]();\n        const def = schema._definition;\n\n        // Flags\n\n        if (desc.flags) {\n            for (const flag in desc.flags) {\n                const setter = def.flags[flag] && def.flags[flag].setter || flag;\n                Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);\n                schema = schema[setter](this.build(desc.flags[flag]));\n            }\n        }\n\n        // Preferences\n\n        if (desc.preferences) {\n            schema = schema.preferences(this.build(desc.preferences));\n        }\n\n        // Allow / Invalid\n\n        if (desc.allow) {\n            schema = schema.allow(...this.build(desc.allow));\n        }\n\n        if (desc.invalid) {\n            schema = schema.invalid(...this.build(desc.invalid));\n        }\n\n        // Rules\n\n        if (desc.rules) {\n            for (const rule of desc.rules) {\n                Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);\n\n                const args = [];\n                if (rule.args) {\n                    const built = {};\n                    for (const key in rule.args) {\n                        built[key] = this.build(rule.args[key], { assign: key });\n                    }\n\n                    const keys = Object.keys(built);\n                    const definition = def.rules[rule.name].args;\n                    if (definition) {\n                        Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');\n                        for (const { name } of definition) {\n                            args.push(built[name]);\n                        }\n                    }\n                    else {\n                        Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');\n                        args.push(built[keys[0]]);\n                    }\n                }\n\n                // Apply\n\n                schema = schema[rule.name](...args);\n\n                // Ruleset\n\n                const options = {};\n                for (const custom in def.modifiers) {\n                    if (rule[custom] !== undefined) {\n                        options[custom] = this.build(rule[custom]);\n                    }\n                }\n\n                if (Object.keys(options).length) {\n                    schema = schema.rule(options);\n                }\n            }\n        }\n\n        // Terms\n\n        const terms = {};\n        for (const key in desc) {\n            if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {\n                continue;\n            }\n\n            Assert(def.terms[key], 'Term', key, 'missing configuration');\n            const manifest = def.terms[key].manifest;\n\n            if (manifest === 'schema') {\n                terms[key] = desc[key].map((item) => this.parse(item));\n                continue;\n            }\n\n            if (manifest === 'values') {\n                terms[key] = desc[key].map((item) => this.build(item));\n                continue;\n            }\n\n            if (manifest === 'single') {\n                terms[key] = this.build(desc[key]);\n                continue;\n            }\n\n            if (typeof manifest === 'object') {\n                terms[key] = {};\n                for (const name in desc[key]) {\n                    const value = desc[key][name];\n                    terms[key][name] = this.parse(value);\n                }\n\n                continue;\n            }\n\n            terms[key] = this.build(desc[key]);\n        }\n\n        if (desc.whens) {\n            terms.whens = desc.whens.map((when) => this.build(when));\n        }\n\n        schema = def.manifest.build(schema, terms);\n        schema.$_temp.ruleset = false;\n        return schema;\n    }\n\n    build(desc, options = {}) {\n\n        if (desc === null) {\n            return null;\n        }\n\n        if (Array.isArray(desc)) {\n            return desc.map((item) => this.build(item));\n        }\n\n        if (desc instanceof Error) {\n            return desc;\n        }\n\n        if (options.assign === 'options') {\n            return Clone(desc);\n        }\n\n        if (options.assign === 'regex') {\n            return internals.regex(desc);\n        }\n\n        if (options.assign === 'ref') {\n            return Ref.build(desc);\n        }\n\n        if (typeof desc !== 'object') {\n            return desc;\n        }\n\n        if (Object.keys(desc).length === 1) {\n            if (desc.buffer) {\n                Assert(Buffer, 'Buffers are not supported');\n                return Buffer && Buffer.from(desc.buffer, 'binary');                    // $lab:coverage:ignore$\n            }\n\n            if (desc.function) {\n                return { [Common.symbols.literal]: true, literal: desc.function };\n            }\n\n            if (desc.override) {\n                return Common.symbols.override;\n            }\n\n            if (desc.ref) {\n                return Ref.build(desc.ref);\n            }\n\n            if (desc.regex) {\n                return internals.regex(desc.regex);\n            }\n\n            if (desc.special) {\n                Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);\n                return Common.symbols.deepDefault;\n            }\n\n            if (desc.value) {\n                return Clone(desc.value);\n            }\n        }\n\n        if (desc.type) {\n            return this.parse(desc);\n        }\n\n        if (desc.template) {\n            return Template.build(desc);\n        }\n\n        const normalized = {};\n        for (const key in desc) {\n            normalized[key] = this.build(desc[key], { assign: key });\n        }\n\n        return normalized;\n    }\n};\n\n\ninternals.regex = function (string) {\n\n    const end = string.lastIndexOf('/');\n    const exp = string.slice(1, end);\n    const flags = string.slice(end + 1);\n    return new RegExp(exp, flags);\n};\n\n\ninternals.validate = function (joi, desc) {\n\n    Schemas = Schemas || require('./schemas');\n\n    joi.assert(desc, Schemas.description);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}