{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Domain = require('@hapi/address/lib/domain');\n\nconst Email = require('@hapi/address/lib/email');\n\nconst Ip = require('@hapi/address/lib/ip');\n\nconst EscapeRegex = require('@hapi/hoek/lib/escapeRegex');\n\nconst Tlds = require('@hapi/address/lib/tlds');\n\nconst Uri = require('@hapi/address/lib/uri');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst internals = {\n  tlds: Tlds instanceof Set ? {\n    tlds: {\n      allow: Tlds,\n      deny: null\n    }\n  } : false,\n  // $lab:coverage:ignore$\n  base64Regex: {\n    // paddingRequired\n    true: {\n      // urlSafe\n      true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}==|[\\w\\-]{3}=)?$/,\n      false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n    },\n    false: {\n      true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}(==)?|[\\w\\-]{3}=?)?$/,\n      false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/\n    }\n  },\n  dataUriRegex: /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/,\n  hexRegex: /^[a-f0-9]+$/i,\n  ipRegex: Ip.regex().regex,\n  isoDurationRegex: /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/,\n  guidBrackets: {\n    '{': '}',\n    '[': ']',\n    '(': ')',\n    '': ''\n  },\n  guidVersions: {\n    uuidv1: '1',\n    uuidv2: '2',\n    uuidv3: '3',\n    uuidv4: '4',\n    uuidv5: '5'\n  },\n  cidrPresences: ['required', 'optional', 'forbidden'],\n  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\nmodule.exports = Any.extend({\n  type: 'string',\n  flags: {\n    insensitive: {\n      default: false\n    },\n    truncate: {\n      default: false\n    }\n  },\n  terms: {\n    replacements: {\n      init: null\n    }\n  },\n  coerce: {\n    from: 'string',\n\n    method(value, _ref) {\n      let {\n        schema,\n        state,\n        prefs\n      } = _ref;\n      const normalize = schema.$_getRule('normalize');\n\n      if (normalize) {\n        value = value.normalize(normalize.args.form);\n      }\n\n      const casing = schema.$_getRule('case');\n\n      if (casing) {\n        value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n      }\n\n      const trim = schema.$_getRule('trim');\n\n      if (trim && trim.args.enabled) {\n        value = value.trim();\n      }\n\n      if (schema.$_terms.replacements) {\n        for (const replacement of schema.$_terms.replacements) {\n          value = value.replace(replacement.pattern, replacement.replacement);\n        }\n      }\n\n      const hex = schema.$_getRule('hex');\n\n      if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {\n        value = `0${value}`;\n      }\n\n      if (schema.$_getRule('isoDate')) {\n        const iso = internals.isoDate(value);\n\n        if (iso) {\n          value = iso;\n        }\n      }\n\n      if (schema._flags.truncate) {\n        const rule = schema.$_getRule('max');\n\n        if (rule) {\n          let limit = rule.args.limit;\n\n          if (Common.isResolvable(limit)) {\n            limit = limit.resolve(value, state, prefs);\n\n            if (!Common.limit(limit)) {\n              return {\n                value,\n                errors: schema.$_createError('any.ref', limit, {\n                  ref: rule.args.limit,\n                  arg: 'limit',\n                  reason: 'must be a positive integer'\n                }, state, prefs)\n              };\n            }\n          }\n\n          value = value.slice(0, limit);\n        }\n      }\n\n      return {\n        value\n      };\n    }\n\n  },\n\n  validate(value, _ref2) {\n    let {\n      error\n    } = _ref2;\n\n    if (typeof value !== 'string') {\n      return {\n        value,\n        errors: error('string.base')\n      };\n    }\n\n    if (value === '') {\n      return {\n        value,\n        errors: error('string.empty')\n      };\n    }\n  },\n\n  rules: {\n    alphanum: {\n      method() {\n        return this.$_addRule('alphanum');\n      },\n\n      validate(value, helpers) {\n        if (/^[a-zA-Z0-9]+$/.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.alphanum');\n      }\n\n    },\n    base64: {\n      method() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        Common.assertOptions(options, ['paddingRequired', 'urlSafe']);\n        options = {\n          urlSafe: false,\n          paddingRequired: true,\n          ...options\n        };\n        Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n        Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');\n        return this.$_addRule({\n          name: 'base64',\n          args: {\n            options\n          }\n        });\n      },\n\n      validate(value, helpers, _ref3) {\n        let {\n          options\n        } = _ref3;\n        const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];\n\n        if (regex.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.base64');\n      }\n\n    },\n    case: {\n      method(direction) {\n        Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);\n        return this.$_addRule({\n          name: 'case',\n          args: {\n            direction\n          }\n        });\n      },\n\n      validate(value, helpers, _ref4) {\n        let {\n          direction\n        } = _ref4;\n\n        if (direction === 'lower' && value === value.toLocaleLowerCase() || direction === 'upper' && value === value.toLocaleUpperCase()) {\n          return value;\n        }\n\n        return helpers.error(`string.${direction}case`);\n      },\n\n      convert: true\n    },\n    creditCard: {\n      method() {\n        return this.$_addRule('creditCard');\n      },\n\n      validate(value, helpers) {\n        let i = value.length;\n        let sum = 0;\n        let mul = 1;\n\n        while (i--) {\n          const char = value.charAt(i) * mul;\n          sum = sum + (char - (char > 9) * 9);\n          mul = mul ^ 3;\n        }\n\n        if (sum > 0 && sum % 10 === 0) {\n          return value;\n        }\n\n        return helpers.error('string.creditCard');\n      }\n\n    },\n    dataUri: {\n      method() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        Common.assertOptions(options, ['paddingRequired']);\n        options = {\n          paddingRequired: true,\n          ...options\n        };\n        Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n        return this.$_addRule({\n          name: 'dataUri',\n          args: {\n            options\n          }\n        });\n      },\n\n      validate(value, helpers, _ref5) {\n        let {\n          options\n        } = _ref5;\n        const matches = value.match(internals.dataUriRegex);\n\n        if (matches) {\n          if (!matches[2]) {\n            return value;\n          }\n\n          if (matches[2] !== 'base64') {\n            return value;\n          }\n\n          const base64regex = internals.base64Regex[options.paddingRequired].false;\n\n          if (base64regex.test(matches[3])) {\n            return value;\n          }\n        }\n\n        return helpers.error('string.dataUri');\n      }\n\n    },\n    domain: {\n      method(options) {\n        if (options) {\n          Common.assertOptions(options, ['allowUnicode', 'minDomainSegments', 'tlds']);\n        }\n\n        const address = internals.addressOptions(options);\n        return this.$_addRule({\n          name: 'domain',\n          args: {\n            options\n          },\n          address\n        });\n      },\n\n      validate(value, helpers, args, _ref6) {\n        let {\n          address\n        } = _ref6;\n\n        if (Domain.isValid(value, address)) {\n          return value;\n        }\n\n        return helpers.error('string.domain');\n      }\n\n    },\n    email: {\n      method() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        Common.assertOptions(options, ['allowUnicode', 'ignoreLength', 'minDomainSegments', 'multiple', 'separator', 'tlds']);\n        Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');\n        const address = internals.addressOptions(options);\n        const regex = new RegExp(`\\\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\\\s*`);\n        return this.$_addRule({\n          name: 'email',\n          args: {\n            options\n          },\n          regex,\n          address\n        });\n      },\n\n      validate(value, helpers, _ref7, _ref8) {\n        let {\n          options\n        } = _ref7;\n        let {\n          regex,\n          address\n        } = _ref8;\n        const emails = options.multiple ? value.split(regex) : [value];\n        const invalids = [];\n\n        for (const email of emails) {\n          if (!Email.isValid(email, address)) {\n            invalids.push(email);\n          }\n        }\n\n        if (!invalids.length) {\n          return value;\n        }\n\n        return helpers.error('string.email', {\n          value,\n          invalids\n        });\n      }\n\n    },\n    guid: {\n      alias: 'uuid',\n\n      method() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        Common.assertOptions(options, ['version']);\n        let versionNumbers = '';\n\n        if (options.version) {\n          const versions = [].concat(options.version);\n          Assert(versions.length >= 1, 'version must have at least 1 valid version specified');\n          const set = new Set();\n\n          for (let i = 0; i < versions.length; ++i) {\n            const version = versions[i];\n            Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n            const versionNumber = internals.guidVersions[version.toLowerCase()];\n            Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n            Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');\n            versionNumbers += versionNumber;\n            set.add(versionNumber);\n          }\n        }\n\n        const regex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n        return this.$_addRule({\n          name: 'guid',\n          args: {\n            options\n          },\n          regex\n        });\n      },\n\n      validate(value, helpers, args, _ref9) {\n        let {\n          regex\n        } = _ref9;\n        const results = regex.exec(value);\n\n        if (!results) {\n          return helpers.error('string.guid');\n        } // Matching braces\n\n\n        if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n          return helpers.error('string.guid');\n        }\n\n        return value;\n      }\n\n    },\n    hex: {\n      method() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        Common.assertOptions(options, ['byteAligned']);\n        options = {\n          byteAligned: false,\n          ...options\n        };\n        Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');\n        return this.$_addRule({\n          name: 'hex',\n          args: {\n            options\n          }\n        });\n      },\n\n      validate(value, helpers, _ref10) {\n        let {\n          options\n        } = _ref10;\n\n        if (!internals.hexRegex.test(value)) {\n          return helpers.error('string.hex');\n        }\n\n        if (options.byteAligned && value.length % 2 !== 0) {\n          return helpers.error('string.hexAlign');\n        }\n\n        return value;\n      }\n\n    },\n    hostname: {\n      method() {\n        return this.$_addRule('hostname');\n      },\n\n      validate(value, helpers) {\n        if (Domain.isValid(value, {\n          minDomainSegments: 1\n        }) || internals.ipRegex.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.hostname');\n      }\n\n    },\n    insensitive: {\n      method() {\n        return this.$_setFlag('insensitive', true);\n      }\n\n    },\n    ip: {\n      method() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        Common.assertOptions(options, ['cidr', 'version']);\n        const {\n          cidr,\n          versions,\n          regex\n        } = Ip.regex(options);\n        const version = options.version ? versions : undefined;\n        return this.$_addRule({\n          name: 'ip',\n          args: {\n            options: {\n              cidr,\n              version\n            }\n          },\n          regex\n        });\n      },\n\n      validate(value, helpers, _ref11, _ref12) {\n        let {\n          options\n        } = _ref11;\n        let {\n          regex\n        } = _ref12;\n\n        if (regex.test(value)) {\n          return value;\n        }\n\n        if (options.version) {\n          return helpers.error('string.ipVersion', {\n            value,\n            cidr: options.cidr,\n            version: options.version\n          });\n        }\n\n        return helpers.error('string.ip', {\n          value,\n          cidr: options.cidr\n        });\n      }\n\n    },\n    isoDate: {\n      method() {\n        return this.$_addRule('isoDate');\n      },\n\n      validate(value, _ref13) {\n        let {\n          error\n        } = _ref13;\n\n        if (internals.isoDate(value)) {\n          return value;\n        }\n\n        return error('string.isoDate');\n      }\n\n    },\n    isoDuration: {\n      method() {\n        return this.$_addRule('isoDuration');\n      },\n\n      validate(value, helpers) {\n        if (internals.isoDurationRegex.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.isoDuration');\n      }\n\n    },\n    length: {\n      method(limit, encoding) {\n        return internals.length(this, 'length', limit, '=', encoding);\n      },\n\n      validate(value, helpers, _ref14, _ref15) {\n        let {\n          limit,\n          encoding\n        } = _ref14;\n        let {\n          name,\n          operator,\n          args\n        } = _ref15;\n        const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length; // $lab:coverage:ignore$\n\n        if (Common.compare(length, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('string.' + name, {\n          limit: args.limit,\n          value,\n          encoding\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.limit,\n        message: 'must be a positive integer'\n      }, 'encoding']\n    },\n    lowercase: {\n      method() {\n        return this.case('lower');\n      }\n\n    },\n    max: {\n      method(limit, encoding) {\n        return internals.length(this, 'max', limit, '<=', encoding);\n      },\n\n      args: ['limit', 'encoding']\n    },\n    min: {\n      method(limit, encoding) {\n        return internals.length(this, 'min', limit, '>=', encoding);\n      },\n\n      args: ['limit', 'encoding']\n    },\n    normalize: {\n      method() {\n        let form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NFC';\n        Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n        return this.$_addRule({\n          name: 'normalize',\n          args: {\n            form\n          }\n        });\n      },\n\n      validate(value, _ref16, _ref17) {\n        let {\n          error\n        } = _ref16;\n        let {\n          form\n        } = _ref17;\n\n        if (value === value.normalize(form)) {\n          return value;\n        }\n\n        return error('string.normalize', {\n          value,\n          form\n        });\n      },\n\n      convert: true\n    },\n    pattern: {\n      alias: 'regex',\n\n      method(regex) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Assert(regex instanceof RegExp, 'regex must be a RegExp');\n        Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');\n\n        if (typeof options === 'string') {\n          options = {\n            name: options\n          };\n        }\n\n        Common.assertOptions(options, ['invert', 'name']);\n        const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');\n        return this.$_addRule({\n          name: 'pattern',\n          args: {\n            regex,\n            options\n          },\n          errorCode\n        });\n      },\n\n      validate(value, helpers, _ref18, _ref19) {\n        let {\n          regex,\n          options\n        } = _ref18;\n        let {\n          errorCode\n        } = _ref19;\n        const patternMatch = regex.test(value);\n\n        if (patternMatch ^ options.invert) {\n          return value;\n        }\n\n        return helpers.error(errorCode, {\n          name: options.name,\n          regex,\n          value\n        });\n      },\n\n      args: ['regex', 'options'],\n      multi: true\n    },\n    replace: {\n      method(pattern, replacement) {\n        if (typeof pattern === 'string') {\n          pattern = new RegExp(EscapeRegex(pattern), 'g');\n        }\n\n        Assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Assert(typeof replacement === 'string', 'replacement must be a String');\n        const obj = this.clone();\n\n        if (!obj.$_terms.replacements) {\n          obj.$_terms.replacements = [];\n        }\n\n        obj.$_terms.replacements.push({\n          pattern,\n          replacement\n        });\n        return obj;\n      }\n\n    },\n    token: {\n      method() {\n        return this.$_addRule('token');\n      },\n\n      validate(value, helpers) {\n        if (/^\\w+$/.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.token');\n      }\n\n    },\n    trim: {\n      method() {\n        let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n        return this.$_addRule({\n          name: 'trim',\n          args: {\n            enabled\n          }\n        });\n      },\n\n      validate(value, helpers, _ref20) {\n        let {\n          enabled\n        } = _ref20;\n\n        if (!enabled || value === value.trim()) {\n          return value;\n        }\n\n        return helpers.error('string.trim');\n      },\n\n      convert: true\n    },\n    truncate: {\n      method() {\n        let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n        return this.$_setFlag('truncate', enabled);\n      }\n\n    },\n    uppercase: {\n      method() {\n        return this.case('upper');\n      }\n\n    },\n    uri: {\n      method() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);\n\n        if (options.domain) {\n          Common.assertOptions(options.domain, ['allowUnicode', 'minDomainSegments', 'tlds']);\n        }\n\n        const {\n          regex,\n          scheme\n        } = Uri.regex(options);\n        const domain = options.domain ? internals.addressOptions(options.domain) : null;\n        return this.$_addRule({\n          name: 'uri',\n          args: {\n            options\n          },\n          regex,\n          domain,\n          scheme\n        });\n      },\n\n      validate(value, helpers, _ref21, _ref22) {\n        let {\n          options\n        } = _ref21;\n        let {\n          regex,\n          domain,\n          scheme\n        } = _ref22;\n\n        if (['http:/', 'https:/'].includes(value)) {\n          // scheme:/ is technically valid but makes no sense\n          return helpers.error('string.uri');\n        }\n\n        const match = regex.exec(value);\n\n        if (match) {\n          if (domain) {\n            const matched = match[1] || match[2];\n\n            if (!Domain.isValid(matched, domain)) {\n              return helpers.error('string.domain', {\n                value: matched\n              });\n            }\n          }\n\n          return value;\n        }\n\n        if (options.relativeOnly) {\n          return helpers.error('string.uriRelativeOnly');\n        }\n\n        if (options.scheme) {\n          return helpers.error('string.uriCustomScheme', {\n            scheme,\n            value\n          });\n        }\n\n        return helpers.error('string.uri');\n      }\n\n    }\n  },\n  manifest: {\n    build(obj, desc) {\n      if (desc.replacements) {\n        for (const {\n          pattern,\n          replacement\n        } of desc.replacements) {\n          obj = obj.replace(pattern, replacement);\n        }\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'string.alphanum': '{{#label}} must only contain alpha-numeric characters',\n    'string.base': '{{#label}} must be a string',\n    'string.base64': '{{#label}} must be a valid base64 string',\n    'string.creditCard': '{{#label}} must be a credit card',\n    'string.dataUri': '{{#label}} must be a valid dataUri string',\n    'string.domain': '{{#label}} must contain a valid domain name',\n    'string.email': '{{#label}} must be a valid email',\n    'string.empty': '{{#label}} is not allowed to be empty',\n    'string.guid': '{{#label}} must be a valid GUID',\n    'string.hex': '{{#label}} must only contain hexadecimal characters',\n    'string.hexAlign': '{{#label}} hex decoded representation must be byte aligned',\n    'string.hostname': '{{#label}} must be a valid hostname',\n    'string.ip': '{{#label}} must be a valid ip address with a {{#cidr}} CIDR',\n    'string.ipVersion': '{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',\n    'string.isoDate': '{{#label}} must be in iso format',\n    'string.isoDuration': '{{#label}} must be a valid ISO 8601 duration',\n    'string.length': '{{#label}} length must be {{#limit}} characters long',\n    'string.lowercase': '{{#label}} must only contain lowercase characters',\n    'string.max': '{{#label}} length must be less than or equal to {{#limit}} characters long',\n    'string.min': '{{#label}} length must be at least {{#limit}} characters long',\n    'string.normalize': '{{#label}} must be unicode normalized in the {{#form}} form',\n    'string.token': '{{#label}} must only contain alpha-numeric and underscore characters',\n    'string.pattern.base': '{{#label}} with value \"{[.]}\" fails to match the required pattern: {{#regex}}',\n    'string.pattern.name': '{{#label}} with value \"{[.]}\" fails to match the {{#name}} pattern',\n    'string.pattern.invert.base': '{{#label}} with value \"{[.]}\" matches the inverted pattern: {{#regex}}',\n    'string.pattern.invert.name': '{{#label}} with value \"{[.]}\" matches the inverted {{#name}} pattern',\n    'string.trim': '{{#label}} must not have leading or trailing whitespace',\n    'string.uri': '{{#label}} must be a valid uri',\n    'string.uriCustomScheme': '{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern',\n    'string.uriRelativeOnly': '{{#label}} must be a valid relative uri',\n    'string.uppercase': '{{#label}} must only contain uppercase characters'\n  }\n}); // Helpers\n\ninternals.addressOptions = function (options) {\n  if (!options) {\n    return options;\n  } // minDomainSegments\n\n\n  Assert(options.minDomainSegments === undefined || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer'); // tlds\n\n  if (options.tlds === false) {\n    return options;\n  }\n\n  if (options.tlds === true || options.tlds === undefined) {\n    Assert(internals.tlds, 'Built-in TLD list disabled');\n    return Object.assign({}, options, internals.tlds);\n  }\n\n  Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');\n  const deny = options.tlds.deny;\n\n  if (deny) {\n    if (Array.isArray(deny)) {\n      options = Object.assign({}, options, {\n        tlds: {\n          deny: new Set(deny)\n        }\n      });\n    }\n\n    Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');\n    Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');\n    return options;\n  }\n\n  const allow = options.tlds.allow;\n\n  if (!allow) {\n    return options;\n  }\n\n  if (allow === true) {\n    Assert(internals.tlds, 'Built-in TLD list disabled');\n    return Object.assign({}, options, internals.tlds);\n  }\n\n  if (Array.isArray(allow)) {\n    options = Object.assign({}, options, {\n      tlds: {\n        allow: new Set(allow)\n      }\n    });\n  }\n\n  Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n  return options;\n};\n\ninternals.isoDate = function (value) {\n  if (!Common.isIsoDate(value)) {\n    return null;\n  }\n\n  const date = new Date(value);\n\n  if (isNaN(date.getTime())) {\n    return null;\n  }\n\n  return date.toISOString();\n};\n\ninternals.length = function (schema, name, limit, operator, encoding) {\n  Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding); // $lab:coverage:ignore$\n\n  return schema.$_addRule({\n    name,\n    method: 'length',\n    args: {\n      limit,\n      encoding\n    },\n    operator\n  });\n};","map":{"version":3,"names":["Assert","require","Domain","Email","Ip","EscapeRegex","Tlds","Uri","Any","Common","internals","tlds","Set","allow","deny","base64Regex","true","false","dataUriRegex","hexRegex","ipRegex","regex","isoDurationRegex","guidBrackets","guidVersions","uuidv1","uuidv2","uuidv3","uuidv4","uuidv5","cidrPresences","normalizationForms","module","exports","extend","type","flags","insensitive","default","truncate","terms","replacements","init","coerce","from","method","value","schema","state","prefs","normalize","$_getRule","args","form","casing","direction","toLocaleUpperCase","toLocaleLowerCase","trim","enabled","$_terms","replacement","replace","pattern","hex","options","byteAligned","length","iso","isoDate","_flags","rule","limit","isResolvable","resolve","errors","$_createError","ref","arg","reason","slice","validate","error","rules","alphanum","$_addRule","helpers","test","base64","assertOptions","urlSafe","paddingRequired","name","case","includes","convert","creditCard","i","sum","mul","char","charAt","dataUri","matches","match","base64regex","domain","address","addressOptions","isValid","email","multiple","undefined","RegExp","separator","emails","split","invalids","push","guid","alias","versionNumbers","version","versions","concat","set","versionNumber","toLowerCase","Object","keys","join","has","add","results","exec","hostname","minDomainSegments","$_setFlag","ip","cidr","isoDuration","encoding","operator","Buffer","byteLength","compare","assert","message","lowercase","max","min","errorCode","invert","patternMatch","multi","obj","clone","token","uppercase","uri","scheme","matched","relativeOnly","manifest","build","desc","messages","Number","isSafeInteger","assign","Array","isArray","isIsoDate","date","Date","isNaN","getTime","toISOString","isEncoding"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/types/string.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Domain = require('@hapi/address/lib/domain');\nconst Email = require('@hapi/address/lib/email');\nconst Ip = require('@hapi/address/lib/ip');\nconst EscapeRegex = require('@hapi/hoek/lib/escapeRegex');\nconst Tlds = require('@hapi/address/lib/tlds');\nconst Uri = require('@hapi/address/lib/uri');\n\nconst Any = require('./any');\nconst Common = require('../common');\n\n\nconst internals = {\n    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,              // $lab:coverage:ignore$\n    base64Regex: {\n        // paddingRequired\n        true: {\n            // urlSafe\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}==|[\\w\\-]{3}=)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n        },\n        false: {\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}(==)?|[\\w\\-]{3}=?)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/\n        }\n    },\n    dataUriRegex: /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/,\n    hexRegex: /^[a-f0-9]+$/i,\n    ipRegex: Ip.regex().regex,\n    isoDurationRegex: /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/,\n\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5'\n    },\n\n    cidrPresences: ['required', 'optional', 'forbidden'],\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'string',\n\n    flags: {\n\n        insensitive: { default: false },\n        truncate: { default: false }\n    },\n\n    terms: {\n\n        replacements: { init: null }\n    },\n\n    coerce: {\n        from: 'string',\n        method(value, { schema, state, prefs }) {\n\n            const normalize = schema.$_getRule('normalize');\n            if (normalize) {\n                value = value.normalize(normalize.args.form);\n            }\n\n            const casing = schema.$_getRule('case');\n            if (casing) {\n                value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n            }\n\n            const trim = schema.$_getRule('trim');\n            if (trim &&\n                trim.args.enabled) {\n\n                value = value.trim();\n            }\n\n            if (schema.$_terms.replacements) {\n                for (const replacement of schema.$_terms.replacements) {\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            const hex = schema.$_getRule('hex');\n            if (hex &&\n                hex.args.options.byteAligned &&\n                value.length % 2 !== 0) {\n\n                value = `0${value}`;\n            }\n\n            if (schema.$_getRule('isoDate')) {\n                const iso = internals.isoDate(value);\n                if (iso) {\n                    value = iso;\n                }\n            }\n\n            if (schema._flags.truncate) {\n                const rule = schema.$_getRule('max');\n                if (rule) {\n                    let limit = rule.args.limit;\n                    if (Common.isResolvable(limit)) {\n                        limit = limit.resolve(value, state, prefs);\n                        if (!Common.limit(limit)) {\n                            return { value, errors: schema.$_createError('any.ref', limit, { ref: rule.args.limit, arg: 'limit', reason: 'must be a positive integer' }, state, prefs) };\n                        }\n                    }\n\n                    value = value.slice(0, limit);\n                }\n            }\n\n            return { value };\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'string') {\n            return { value, errors: error('string.base') };\n        }\n\n        if (value === '') {\n            return { value, errors: error('string.empty') };\n        }\n    },\n\n    rules: {\n\n        alphanum: {\n            method() {\n\n                return this.$_addRule('alphanum');\n            },\n            validate(value, helpers) {\n\n                if (/^[a-zA-Z0-9]+$/.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.alphanum');\n            }\n        },\n\n        base64: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['paddingRequired', 'urlSafe']);\n\n                options = { urlSafe: false, paddingRequired: true, ...options };\n                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n                Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');\n\n                return this.$_addRule({ name: 'base64', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];\n                if (regex.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.base64');\n            }\n        },\n\n        case: {\n            method(direction) {\n\n                Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);\n\n                return this.$_addRule({ name: 'case', args: { direction } });\n            },\n            validate(value, helpers, { direction }) {\n\n                if (direction === 'lower' && value === value.toLocaleLowerCase() ||\n                    direction === 'upper' && value === value.toLocaleUpperCase()) {\n\n                    return value;\n                }\n\n                return helpers.error(`string.${direction}case`);\n            },\n            convert: true\n        },\n\n        creditCard: {\n            method() {\n\n                return this.$_addRule('creditCard');\n            },\n            validate(value, helpers) {\n\n                let i = value.length;\n                let sum = 0;\n                let mul = 1;\n\n                while (i--) {\n                    const char = value.charAt(i) * mul;\n                    sum = sum + (char - (char > 9) * 9);\n                    mul = mul ^ 3;\n                }\n\n                if (sum > 0 &&\n                    sum % 10 === 0) {\n\n                    return value;\n                }\n\n                return helpers.error('string.creditCard');\n            }\n        },\n\n        dataUri: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['paddingRequired']);\n\n                options = { paddingRequired: true, ...options };\n                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n\n                return this.$_addRule({ name: 'dataUri', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const matches = value.match(internals.dataUriRegex);\n\n                if (matches) {\n                    if (!matches[2]) {\n                        return value;\n                    }\n\n                    if (matches[2] !== 'base64') {\n                        return value;\n                    }\n\n                    const base64regex = internals.base64Regex[options.paddingRequired].false;\n                    if (base64regex.test(matches[3])) {\n                        return value;\n                    }\n                }\n\n                return helpers.error('string.dataUri');\n            }\n        },\n\n        domain: {\n            method(options) {\n\n                if (options) {\n                    Common.assertOptions(options, ['allowUnicode', 'minDomainSegments', 'tlds']);\n                }\n\n                const address = internals.addressOptions(options);\n                return this.$_addRule({ name: 'domain', args: { options }, address });\n            },\n            validate(value, helpers, args, { address }) {\n\n                if (Domain.isValid(value, address)) {\n                    return value;\n                }\n\n                return helpers.error('string.domain');\n            }\n        },\n\n        email: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['allowUnicode', 'ignoreLength', 'minDomainSegments', 'multiple', 'separator', 'tlds']);\n                Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');\n\n                const address = internals.addressOptions(options);\n                const regex = new RegExp(`\\\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\\\s*`);\n\n                return this.$_addRule({ name: 'email', args: { options }, regex, address });\n            },\n            validate(value, helpers, { options }, { regex, address }) {\n\n                const emails = options.multiple ? value.split(regex) : [value];\n                const invalids = [];\n                for (const email of emails) {\n                    if (!Email.isValid(email, address)) {\n                        invalids.push(email);\n                    }\n                }\n\n                if (!invalids.length) {\n                    return value;\n                }\n\n                return helpers.error('string.email', { value, invalids });\n            }\n        },\n\n        guid: {\n            alias: 'uuid',\n            method(options = {}) {\n\n                Common.assertOptions(options, ['version']);\n\n                let versionNumbers = '';\n\n                if (options.version) {\n                    const versions = [].concat(options.version);\n\n                    Assert(versions.length >= 1, 'version must have at least 1 valid version specified');\n                    const set = new Set();\n\n                    for (let i = 0; i < versions.length; ++i) {\n                        const version = versions[i];\n                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                        const versionNumber = internals.guidVersions[version.toLowerCase()];\n                        Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                        Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');\n\n                        versionNumbers += versionNumber;\n                        set.add(versionNumber);\n                    }\n                }\n\n                const regex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n                return this.$_addRule({ name: 'guid', args: { options }, regex });\n            },\n            validate(value, helpers, args, { regex }) {\n\n                const results = regex.exec(value);\n\n                if (!results) {\n                    return helpers.error('string.guid');\n                }\n\n                // Matching braces\n\n                if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                    return helpers.error('string.guid');\n                }\n\n                return value;\n            }\n        },\n\n        hex: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['byteAligned']);\n\n                options = { byteAligned: false, ...options };\n                Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');\n\n                return this.$_addRule({ name: 'hex', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                if (!internals.hexRegex.test(value)) {\n                    return helpers.error('string.hex');\n                }\n\n                if (options.byteAligned &&\n                    value.length % 2 !== 0) {\n\n                    return helpers.error('string.hexAlign');\n                }\n\n                return value;\n            }\n        },\n\n        hostname: {\n            method() {\n\n                return this.$_addRule('hostname');\n            },\n            validate(value, helpers) {\n\n                if (Domain.isValid(value, { minDomainSegments: 1 }) ||\n                    internals.ipRegex.test(value)) {\n\n                    return value;\n                }\n\n                return helpers.error('string.hostname');\n            }\n        },\n\n        insensitive: {\n            method() {\n\n                return this.$_setFlag('insensitive', true);\n            }\n        },\n\n        ip: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['cidr', 'version']);\n\n                const { cidr, versions, regex } = Ip.regex(options);\n                const version = options.version ? versions : undefined;\n                return this.$_addRule({ name: 'ip', args: { options: { cidr, version } }, regex });\n            },\n            validate(value, helpers, { options }, { regex }) {\n\n                if (regex.test(value)) {\n                    return value;\n                }\n\n                if (options.version) {\n                    return helpers.error('string.ipVersion', { value, cidr: options.cidr, version: options.version });\n                }\n\n                return helpers.error('string.ip', { value, cidr: options.cidr });\n            }\n        },\n\n        isoDate: {\n            method() {\n\n                return this.$_addRule('isoDate');\n            },\n            validate(value, { error }) {\n\n                if (internals.isoDate(value)) {\n                    return value;\n                }\n\n                return error('string.isoDate');\n            }\n        },\n\n        isoDuration: {\n            method() {\n\n                return this.$_addRule('isoDuration');\n            },\n            validate(value, helpers) {\n\n                if (internals.isoDurationRegex.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.isoDuration');\n            }\n        },\n\n        length: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'length', limit, '=', encoding);\n            },\n            validate(value, helpers, { limit, encoding }, { name, operator, args }) {\n\n                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;      // $lab:coverage:ignore$\n                if (Common.compare(length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('string.' + name, { limit: args.limit, value, encoding });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                },\n                'encoding'\n            ]\n        },\n\n        lowercase: {\n            method() {\n\n                return this.case('lower');\n            }\n        },\n\n        max: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'max', limit, '<=', encoding);\n            },\n            args: ['limit', 'encoding']\n        },\n\n        min: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'min', limit, '>=', encoding);\n            },\n            args: ['limit', 'encoding']\n        },\n\n        normalize: {\n            method(form = 'NFC') {\n\n                Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n                return this.$_addRule({ name: 'normalize', args: { form } });\n            },\n            validate(value, { error }, { form }) {\n\n                if (value === value.normalize(form)) {\n                    return value;\n                }\n\n                return error('string.normalize', { value, form });\n            },\n            convert: true\n        },\n\n        pattern: {\n            alias: 'regex',\n            method(regex, options = {}) {\n\n                Assert(regex instanceof RegExp, 'regex must be a RegExp');\n                Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');\n\n                if (typeof options === 'string') {\n                    options = { name: options };\n                }\n\n                Common.assertOptions(options, ['invert', 'name']);\n\n                const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');\n                return this.$_addRule({ name: 'pattern', args: { regex, options }, errorCode });\n            },\n            validate(value, helpers, { regex, options }, { errorCode }) {\n\n                const patternMatch = regex.test(value);\n\n                if (patternMatch ^ options.invert) {\n                    return value;\n                }\n\n                return helpers.error(errorCode, { name: options.name, regex, value });\n            },\n            args: ['regex', 'options'],\n            multi: true\n        },\n\n        replace: {\n            method(pattern, replacement) {\n\n                if (typeof pattern === 'string') {\n                    pattern = new RegExp(EscapeRegex(pattern), 'g');\n                }\n\n                Assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n                Assert(typeof replacement === 'string', 'replacement must be a String');\n\n                const obj = this.clone();\n\n                if (!obj.$_terms.replacements) {\n                    obj.$_terms.replacements = [];\n                }\n\n                obj.$_terms.replacements.push({ pattern, replacement });\n                return obj;\n            }\n        },\n\n        token: {\n            method() {\n\n                return this.$_addRule('token');\n            },\n            validate(value, helpers) {\n\n                if (/^\\w+$/.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.token');\n            }\n        },\n\n        trim: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_addRule({ name: 'trim', args: { enabled } });\n            },\n            validate(value, helpers, { enabled }) {\n\n                if (!enabled ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return helpers.error('string.trim');\n            },\n            convert: true\n        },\n\n        truncate: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_setFlag('truncate', enabled);\n            }\n        },\n\n        uppercase: {\n            method() {\n\n                return this.case('upper');\n            }\n        },\n\n        uri: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);\n\n                if (options.domain) {\n                    Common.assertOptions(options.domain, ['allowUnicode', 'minDomainSegments', 'tlds']);\n                }\n\n                const { regex, scheme } = Uri.regex(options);\n                const domain = options.domain ? internals.addressOptions(options.domain) : null;\n                return this.$_addRule({ name: 'uri', args: { options }, regex, domain, scheme });\n            },\n            validate(value, helpers, { options }, { regex, domain, scheme }) {\n\n                if (['http:/', 'https:/'].includes(value)) {            // scheme:/ is technically valid but makes no sense\n                    return helpers.error('string.uri');\n                }\n\n                const match = regex.exec(value);\n                if (match) {\n                    if (domain) {\n                        const matched = match[1] || match[2];\n                        if (!Domain.isValid(matched, domain)) {\n                            return helpers.error('string.domain', { value: matched });\n                        }\n                    }\n\n                    return value;\n                }\n\n                if (options.relativeOnly) {\n                    return helpers.error('string.uriRelativeOnly');\n                }\n\n                if (options.scheme) {\n                    return helpers.error('string.uriCustomScheme', { scheme, value });\n                }\n\n                return helpers.error('string.uri');\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.replacements) {\n                for (const { pattern, replacement } of desc.replacements) {\n                    obj = obj.replace(pattern, replacement);\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'string.alphanum': '{{#label}} must only contain alpha-numeric characters',\n        'string.base': '{{#label}} must be a string',\n        'string.base64': '{{#label}} must be a valid base64 string',\n        'string.creditCard': '{{#label}} must be a credit card',\n        'string.dataUri': '{{#label}} must be a valid dataUri string',\n        'string.domain': '{{#label}} must contain a valid domain name',\n        'string.email': '{{#label}} must be a valid email',\n        'string.empty': '{{#label}} is not allowed to be empty',\n        'string.guid': '{{#label}} must be a valid GUID',\n        'string.hex': '{{#label}} must only contain hexadecimal characters',\n        'string.hexAlign': '{{#label}} hex decoded representation must be byte aligned',\n        'string.hostname': '{{#label}} must be a valid hostname',\n        'string.ip': '{{#label}} must be a valid ip address with a {{#cidr}} CIDR',\n        'string.ipVersion': '{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',\n        'string.isoDate': '{{#label}} must be in iso format',\n        'string.isoDuration': '{{#label}} must be a valid ISO 8601 duration',\n        'string.length': '{{#label}} length must be {{#limit}} characters long',\n        'string.lowercase': '{{#label}} must only contain lowercase characters',\n        'string.max': '{{#label}} length must be less than or equal to {{#limit}} characters long',\n        'string.min': '{{#label}} length must be at least {{#limit}} characters long',\n        'string.normalize': '{{#label}} must be unicode normalized in the {{#form}} form',\n        'string.token': '{{#label}} must only contain alpha-numeric and underscore characters',\n        'string.pattern.base': '{{#label}} with value \"{[.]}\" fails to match the required pattern: {{#regex}}',\n        'string.pattern.name': '{{#label}} with value \"{[.]}\" fails to match the {{#name}} pattern',\n        'string.pattern.invert.base': '{{#label}} with value \"{[.]}\" matches the inverted pattern: {{#regex}}',\n        'string.pattern.invert.name': '{{#label}} with value \"{[.]}\" matches the inverted {{#name}} pattern',\n        'string.trim': '{{#label}} must not have leading or trailing whitespace',\n        'string.uri': '{{#label}} must be a valid uri',\n        'string.uriCustomScheme': '{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern',\n        'string.uriRelativeOnly': '{{#label}} must be a valid relative uri',\n        'string.uppercase': '{{#label}} must only contain uppercase characters'\n    }\n});\n\n\n// Helpers\n\ninternals.addressOptions = function (options) {\n\n    if (!options) {\n        return options;\n    }\n\n    // minDomainSegments\n\n    Assert(options.minDomainSegments === undefined ||\n        Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer');\n\n    // tlds\n\n    if (options.tlds === false) {\n        return options;\n    }\n\n    if (options.tlds === true ||\n        options.tlds === undefined) {\n\n        Assert(internals.tlds, 'Built-in TLD list disabled');\n        return Object.assign({}, options, internals.tlds);\n    }\n\n    Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');\n\n    const deny = options.tlds.deny;\n    if (deny) {\n        if (Array.isArray(deny)) {\n            options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });\n        }\n\n        Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');\n        Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');\n        return options;\n    }\n\n    const allow = options.tlds.allow;\n    if (!allow) {\n        return options;\n    }\n\n    if (allow === true) {\n        Assert(internals.tlds, 'Built-in TLD list disabled');\n        return Object.assign({}, options, internals.tlds);\n    }\n\n    if (Array.isArray(allow)) {\n        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });\n    }\n\n    Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n    return options;\n};\n\n\ninternals.isoDate = function (value) {\n\n    if (!Common.isIsoDate(value)) {\n        return null;\n    }\n\n    const date = new Date(value);\n    if (isNaN(date.getTime())) {\n        return null;\n    }\n\n    return date.toISOString();\n};\n\n\ninternals.length = function (schema, name, limit, operator, encoding) {\n\n    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);      // $lab:coverage:ignore$\n\n    return schema.$_addRule({ name, method: 'length', args: { limit, encoding }, operator });\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,0BAAD,CAAtB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,yBAAD,CAArB;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,sBAAD,CAAlB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,4BAAD,CAA3B;;AACA,MAAMK,IAAI,GAAGL,OAAO,CAAC,wBAAD,CAApB;;AACA,MAAMM,GAAG,GAAGN,OAAO,CAAC,uBAAD,CAAnB;;AAEA,MAAMO,GAAG,GAAGP,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,WAAD,CAAtB;;AAGA,MAAMS,SAAS,GAAG;EACdC,IAAI,EAAEL,IAAI,YAAYM,GAAhB,GAAsB;IAAED,IAAI,EAAE;MAAEE,KAAK,EAAEP,IAAT;MAAeQ,IAAI,EAAE;IAArB;EAAR,CAAtB,GAA8D,KADtD;EAC0E;EACxFC,WAAW,EAAE;IACT;IACAC,IAAI,EAAE;MACF;MACAA,IAAI,EAAE,sDAFJ;MAGFC,KAAK,EAAE;IAHL,CAFG;IAOTA,KAAK,EAAE;MACHD,IAAI,EAAE,0DADH;MAEHC,KAAK,EAAE;IAFJ;EAPE,CAFC;EAcdC,YAAY,EAAE,2DAdA;EAedC,QAAQ,EAAE,cAfI;EAgBdC,OAAO,EAAEhB,EAAE,CAACiB,KAAH,GAAWA,KAhBN;EAiBdC,gBAAgB,EAAE,qEAjBJ;EAmBdC,YAAY,EAAE;IACV,KAAK,GADK;IACA,KAAK,GADL;IACU,KAAK,GADf;IACoB,IAAI;EADxB,CAnBA;EAsBdC,YAAY,EAAE;IACVC,MAAM,EAAE,GADE;IAEVC,MAAM,EAAE,GAFE;IAGVC,MAAM,EAAE,GAHE;IAIVC,MAAM,EAAE,GAJE;IAKVC,MAAM,EAAE;EALE,CAtBA;EA8BdC,aAAa,EAAE,CAAC,UAAD,EAAa,UAAb,EAAyB,WAAzB,CA9BD;EA+BdC,kBAAkB,EAAE,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,MAAvB;AA/BN,CAAlB;AAmCAC,MAAM,CAACC,OAAP,GAAiBzB,GAAG,CAAC0B,MAAJ,CAAW;EAExBC,IAAI,EAAE,QAFkB;EAIxBC,KAAK,EAAE;IAEHC,WAAW,EAAE;MAAEC,OAAO,EAAE;IAAX,CAFV;IAGHC,QAAQ,EAAE;MAAED,OAAO,EAAE;IAAX;EAHP,CAJiB;EAUxBE,KAAK,EAAE;IAEHC,YAAY,EAAE;MAAEC,IAAI,EAAE;IAAR;EAFX,CAViB;EAexBC,MAAM,EAAE;IACJC,IAAI,EAAE,QADF;;IAEJC,MAAM,CAACC,KAAD,QAAkC;MAAA,IAA1B;QAAEC,MAAF;QAAUC,KAAV;QAAiBC;MAAjB,CAA0B;MAEpC,MAAMC,SAAS,GAAGH,MAAM,CAACI,SAAP,CAAiB,WAAjB,CAAlB;;MACA,IAAID,SAAJ,EAAe;QACXJ,KAAK,GAAGA,KAAK,CAACI,SAAN,CAAgBA,SAAS,CAACE,IAAV,CAAeC,IAA/B,CAAR;MACH;;MAED,MAAMC,MAAM,GAAGP,MAAM,CAACI,SAAP,CAAiB,MAAjB,CAAf;;MACA,IAAIG,MAAJ,EAAY;QACRR,KAAK,GAAGQ,MAAM,CAACF,IAAP,CAAYG,SAAZ,KAA0B,OAA1B,GAAoCT,KAAK,CAACU,iBAAN,EAApC,GAAgEV,KAAK,CAACW,iBAAN,EAAxE;MACH;;MAED,MAAMC,IAAI,GAAGX,MAAM,CAACI,SAAP,CAAiB,MAAjB,CAAb;;MACA,IAAIO,IAAI,IACJA,IAAI,CAACN,IAAL,CAAUO,OADd,EACuB;QAEnBb,KAAK,GAAGA,KAAK,CAACY,IAAN,EAAR;MACH;;MAED,IAAIX,MAAM,CAACa,OAAP,CAAenB,YAAnB,EAAiC;QAC7B,KAAK,MAAMoB,WAAX,IAA0Bd,MAAM,CAACa,OAAP,CAAenB,YAAzC,EAAuD;UACnDK,KAAK,GAAGA,KAAK,CAACgB,OAAN,CAAcD,WAAW,CAACE,OAA1B,EAAmCF,WAAW,CAACA,WAA/C,CAAR;QACH;MACJ;;MAED,MAAMG,GAAG,GAAGjB,MAAM,CAACI,SAAP,CAAiB,KAAjB,CAAZ;;MACA,IAAIa,GAAG,IACHA,GAAG,CAACZ,IAAJ,CAASa,OAAT,CAAiBC,WADjB,IAEApB,KAAK,CAACqB,MAAN,GAAe,CAAf,KAAqB,CAFzB,EAE4B;QAExBrB,KAAK,GAAI,IAAGA,KAAM,EAAlB;MACH;;MAED,IAAIC,MAAM,CAACI,SAAP,CAAiB,SAAjB,CAAJ,EAAiC;QAC7B,MAAMiB,GAAG,GAAG1D,SAAS,CAAC2D,OAAV,CAAkBvB,KAAlB,CAAZ;;QACA,IAAIsB,GAAJ,EAAS;UACLtB,KAAK,GAAGsB,GAAR;QACH;MACJ;;MAED,IAAIrB,MAAM,CAACuB,MAAP,CAAc/B,QAAlB,EAA4B;QACxB,MAAMgC,IAAI,GAAGxB,MAAM,CAACI,SAAP,CAAiB,KAAjB,CAAb;;QACA,IAAIoB,IAAJ,EAAU;UACN,IAAIC,KAAK,GAAGD,IAAI,CAACnB,IAAL,CAAUoB,KAAtB;;UACA,IAAI/D,MAAM,CAACgE,YAAP,CAAoBD,KAApB,CAAJ,EAAgC;YAC5BA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc5B,KAAd,EAAqBE,KAArB,EAA4BC,KAA5B,CAAR;;YACA,IAAI,CAACxC,MAAM,CAAC+D,KAAP,CAAaA,KAAb,CAAL,EAA0B;cACtB,OAAO;gBAAE1B,KAAF;gBAAS6B,MAAM,EAAE5B,MAAM,CAAC6B,aAAP,CAAqB,SAArB,EAAgCJ,KAAhC,EAAuC;kBAAEK,GAAG,EAAEN,IAAI,CAACnB,IAAL,CAAUoB,KAAjB;kBAAwBM,GAAG,EAAE,OAA7B;kBAAsCC,MAAM,EAAE;gBAA9C,CAAvC,EAAqH/B,KAArH,EAA4HC,KAA5H;cAAjB,CAAP;YACH;UACJ;;UAEDH,KAAK,GAAGA,KAAK,CAACkC,KAAN,CAAY,CAAZ,EAAeR,KAAf,CAAR;QACH;MACJ;;MAED,OAAO;QAAE1B;MAAF,CAAP;IACH;;EA1DG,CAfgB;;EA4ExBmC,QAAQ,CAACnC,KAAD,SAAmB;IAAA,IAAX;MAAEoC;IAAF,CAAW;;IAEvB,IAAI,OAAOpC,KAAP,KAAiB,QAArB,EAA+B;MAC3B,OAAO;QAAEA,KAAF;QAAS6B,MAAM,EAAEO,KAAK,CAAC,aAAD;MAAtB,CAAP;IACH;;IAED,IAAIpC,KAAK,KAAK,EAAd,EAAkB;MACd,OAAO;QAAEA,KAAF;QAAS6B,MAAM,EAAEO,KAAK,CAAC,cAAD;MAAtB,CAAP;IACH;EACJ,CArFuB;;EAuFxBC,KAAK,EAAE;IAEHC,QAAQ,EAAE;MACNvC,MAAM,GAAG;QAEL,OAAO,KAAKwC,SAAL,CAAe,UAAf,CAAP;MACH,CAJK;;MAKNJ,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,EAAiB;QAErB,IAAI,iBAAiBC,IAAjB,CAAsBzC,KAAtB,CAAJ,EAAkC;UAC9B,OAAOA,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,iBAAd,CAAP;MACH;;IAZK,CAFP;IAiBHM,MAAM,EAAE;MACJ3C,MAAM,GAAe;QAAA,IAAdoB,OAAc,uEAAJ,EAAI;QAEjBxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,iBAAD,EAAoB,SAApB,CAA9B;QAEAA,OAAO,GAAG;UAAEyB,OAAO,EAAE,KAAX;UAAkBC,eAAe,EAAE,IAAnC;UAAyC,GAAG1B;QAA5C,CAAV;QACAjE,MAAM,CAAC,OAAOiE,OAAO,CAAC0B,eAAf,KAAmC,SAApC,EAA+C,iCAA/C,CAAN;QACA3F,MAAM,CAAC,OAAOiE,OAAO,CAACyB,OAAf,KAA2B,SAA5B,EAAuC,yBAAvC,CAAN;QAEA,OAAO,KAAKL,SAAL,CAAe;UAAEO,IAAI,EAAE,QAAR;UAAkBxC,IAAI,EAAE;YAAEa;UAAF;QAAxB,CAAf,CAAP;MACH,CAVG;;MAWJgB,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,SAA8B;QAAA,IAAb;UAAErB;QAAF,CAAa;QAElC,MAAM5C,KAAK,GAAGX,SAAS,CAACK,WAAV,CAAsBkD,OAAO,CAAC0B,eAA9B,EAA+C1B,OAAO,CAACyB,OAAvD,CAAd;;QACA,IAAIrE,KAAK,CAACkE,IAAN,CAAWzC,KAAX,CAAJ,EAAuB;UACnB,OAAOA,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,eAAd,CAAP;MACH;;IAnBG,CAjBL;IAuCHW,IAAI,EAAE;MACFhD,MAAM,CAACU,SAAD,EAAY;QAEdvD,MAAM,CAAC,CAAC,OAAD,EAAU,OAAV,EAAmB8F,QAAnB,CAA4BvC,SAA5B,CAAD,EAAyC,eAAzC,EAA0DA,SAA1D,CAAN;QAEA,OAAO,KAAK8B,SAAL,CAAe;UAAEO,IAAI,EAAE,MAAR;UAAgBxC,IAAI,EAAE;YAAEG;UAAF;QAAtB,CAAf,CAAP;MACH,CANC;;MAOF0B,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,SAAgC;QAAA,IAAf;UAAE/B;QAAF,CAAe;;QAEpC,IAAIA,SAAS,KAAK,OAAd,IAAyBT,KAAK,KAAKA,KAAK,CAACW,iBAAN,EAAnC,IACAF,SAAS,KAAK,OAAd,IAAyBT,KAAK,KAAKA,KAAK,CAACU,iBAAN,EADvC,EACkE;UAE9D,OAAOV,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAe,UAAS3B,SAAU,MAAlC,CAAP;MACH,CAhBC;;MAiBFwC,OAAO,EAAE;IAjBP,CAvCH;IA2DHC,UAAU,EAAE;MACRnD,MAAM,GAAG;QAEL,OAAO,KAAKwC,SAAL,CAAe,YAAf,CAAP;MACH,CAJO;;MAKRJ,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,EAAiB;QAErB,IAAIW,CAAC,GAAGnD,KAAK,CAACqB,MAAd;QACA,IAAI+B,GAAG,GAAG,CAAV;QACA,IAAIC,GAAG,GAAG,CAAV;;QAEA,OAAOF,CAAC,EAAR,EAAY;UACR,MAAMG,IAAI,GAAGtD,KAAK,CAACuD,MAAN,CAAaJ,CAAb,IAAkBE,GAA/B;UACAD,GAAG,GAAGA,GAAG,IAAIE,IAAI,GAAG,CAACA,IAAI,GAAG,CAAR,IAAa,CAAxB,CAAT;UACAD,GAAG,GAAGA,GAAG,GAAG,CAAZ;QACH;;QAED,IAAID,GAAG,GAAG,CAAN,IACAA,GAAG,GAAG,EAAN,KAAa,CADjB,EACoB;UAEhB,OAAOpD,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,mBAAd,CAAP;MACH;;IAxBO,CA3DT;IAsFHoB,OAAO,EAAE;MACLzD,MAAM,GAAe;QAAA,IAAdoB,OAAc,uEAAJ,EAAI;QAEjBxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,iBAAD,CAA9B;QAEAA,OAAO,GAAG;UAAE0B,eAAe,EAAE,IAAnB;UAAyB,GAAG1B;QAA5B,CAAV;QACAjE,MAAM,CAAC,OAAOiE,OAAO,CAAC0B,eAAf,KAAmC,SAApC,EAA+C,iCAA/C,CAAN;QAEA,OAAO,KAAKN,SAAL,CAAe;UAAEO,IAAI,EAAE,SAAR;UAAmBxC,IAAI,EAAE;YAAEa;UAAF;QAAzB,CAAf,CAAP;MACH,CATI;;MAULgB,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,SAA8B;QAAA,IAAb;UAAErB;QAAF,CAAa;QAElC,MAAMsC,OAAO,GAAGzD,KAAK,CAAC0D,KAAN,CAAY9F,SAAS,CAACQ,YAAtB,CAAhB;;QAEA,IAAIqF,OAAJ,EAAa;UACT,IAAI,CAACA,OAAO,CAAC,CAAD,CAAZ,EAAiB;YACb,OAAOzD,KAAP;UACH;;UAED,IAAIyD,OAAO,CAAC,CAAD,CAAP,KAAe,QAAnB,EAA6B;YACzB,OAAOzD,KAAP;UACH;;UAED,MAAM2D,WAAW,GAAG/F,SAAS,CAACK,WAAV,CAAsBkD,OAAO,CAAC0B,eAA9B,EAA+C1E,KAAnE;;UACA,IAAIwF,WAAW,CAAClB,IAAZ,CAAiBgB,OAAO,CAAC,CAAD,CAAxB,CAAJ,EAAkC;YAC9B,OAAOzD,KAAP;UACH;QACJ;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,gBAAd,CAAP;MACH;;IA9BI,CAtFN;IAuHHwB,MAAM,EAAE;MACJ7D,MAAM,CAACoB,OAAD,EAAU;QAEZ,IAAIA,OAAJ,EAAa;UACTxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,cAAD,EAAiB,mBAAjB,EAAsC,MAAtC,CAA9B;QACH;;QAED,MAAM0C,OAAO,GAAGjG,SAAS,CAACkG,cAAV,CAAyB3C,OAAzB,CAAhB;QACA,OAAO,KAAKoB,SAAL,CAAe;UAAEO,IAAI,EAAE,QAAR;UAAkBxC,IAAI,EAAE;YAAEa;UAAF,CAAxB;UAAqC0C;QAArC,CAAf,CAAP;MACH,CATG;;MAUJ1B,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,EAAiBlC,IAAjB,SAAoC;QAAA,IAAb;UAAEuD;QAAF,CAAa;;QAExC,IAAIzG,MAAM,CAAC2G,OAAP,CAAe/D,KAAf,EAAsB6D,OAAtB,CAAJ,EAAoC;UAChC,OAAO7D,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,eAAd,CAAP;MACH;;IAjBG,CAvHL;IA2IH4B,KAAK,EAAE;MACHjE,MAAM,GAAe;QAAA,IAAdoB,OAAc,uEAAJ,EAAI;QAEjBxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,cAAD,EAAiB,cAAjB,EAAiC,mBAAjC,EAAsD,UAAtD,EAAkE,WAAlE,EAA+E,MAA/E,CAA9B;QACAjE,MAAM,CAACiE,OAAO,CAAC8C,QAAR,KAAqBC,SAArB,IAAkC,OAAO/C,OAAO,CAAC8C,QAAf,KAA4B,SAA/D,EAA0E,oCAA1E,CAAN;QAEA,MAAMJ,OAAO,GAAGjG,SAAS,CAACkG,cAAV,CAAyB3C,OAAzB,CAAhB;QACA,MAAM5C,KAAK,GAAG,IAAI4F,MAAJ,CAAY,QAAOhD,OAAO,CAACiD,SAAR,GAAoB7G,WAAW,CAAC4D,OAAO,CAACiD,SAAT,CAA/B,GAAqD,GAAI,OAA5E,CAAd;QAEA,OAAO,KAAK7B,SAAL,CAAe;UAAEO,IAAI,EAAE,OAAR;UAAiBxC,IAAI,EAAE;YAAEa;UAAF,CAAvB;UAAoC5C,KAApC;UAA2CsF;QAA3C,CAAf,CAAP;MACH,CAVE;;MAWH1B,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,gBAAkD;QAAA,IAAjC;UAAErB;QAAF,CAAiC;QAAA,IAApB;UAAE5C,KAAF;UAASsF;QAAT,CAAoB;QAEtD,MAAMQ,MAAM,GAAGlD,OAAO,CAAC8C,QAAR,GAAmBjE,KAAK,CAACsE,KAAN,CAAY/F,KAAZ,CAAnB,GAAwC,CAACyB,KAAD,CAAvD;QACA,MAAMuE,QAAQ,GAAG,EAAjB;;QACA,KAAK,MAAMP,KAAX,IAAoBK,MAApB,EAA4B;UACxB,IAAI,CAAChH,KAAK,CAAC0G,OAAN,CAAcC,KAAd,EAAqBH,OAArB,CAAL,EAAoC;YAChCU,QAAQ,CAACC,IAAT,CAAcR,KAAd;UACH;QACJ;;QAED,IAAI,CAACO,QAAQ,CAAClD,MAAd,EAAsB;UAClB,OAAOrB,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,cAAd,EAA8B;UAAEpC,KAAF;UAASuE;QAAT,CAA9B,CAAP;MACH;;IA1BE,CA3IJ;IAwKHE,IAAI,EAAE;MACFC,KAAK,EAAE,MADL;;MAEF3E,MAAM,GAAe;QAAA,IAAdoB,OAAc,uEAAJ,EAAI;QAEjBxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,SAAD,CAA9B;QAEA,IAAIwD,cAAc,GAAG,EAArB;;QAEA,IAAIxD,OAAO,CAACyD,OAAZ,EAAqB;UACjB,MAAMC,QAAQ,GAAG,GAAGC,MAAH,CAAU3D,OAAO,CAACyD,OAAlB,CAAjB;UAEA1H,MAAM,CAAC2H,QAAQ,CAACxD,MAAT,IAAmB,CAApB,EAAuB,sDAAvB,CAAN;UACA,MAAM0D,GAAG,GAAG,IAAIjH,GAAJ,EAAZ;;UAEA,KAAK,IAAIqF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0B,QAAQ,CAACxD,MAA7B,EAAqC,EAAE8B,CAAvC,EAA0C;YACtC,MAAMyB,OAAO,GAAGC,QAAQ,CAAC1B,CAAD,CAAxB;YACAjG,MAAM,CAAC,OAAO0H,OAAP,KAAmB,QAApB,EAA8B,yBAAyBzB,CAAzB,GAA6B,mBAA3D,CAAN;YACA,MAAM6B,aAAa,GAAGpH,SAAS,CAACc,YAAV,CAAuBkG,OAAO,CAACK,WAAR,EAAvB,CAAtB;YACA/H,MAAM,CAAC8H,aAAD,EAAgB,yBAAyB7B,CAAzB,GAA6B,kBAA7B,GAAkD+B,MAAM,CAACC,IAAP,CAAYvH,SAAS,CAACc,YAAtB,EAAoC0G,IAApC,CAAyC,IAAzC,CAAlE,CAAN;YACAlI,MAAM,CAAC,CAAC6H,GAAG,CAACM,GAAJ,CAAQL,aAAR,CAAF,EAA0B,yBAAyB7B,CAAzB,GAA6B,0BAAvD,CAAN;YAEAwB,cAAc,IAAIK,aAAlB;YACAD,GAAG,CAACO,GAAJ,CAAQN,aAAR;UACH;QACJ;;QAED,MAAMzG,KAAK,GAAG,IAAI4F,MAAJ,CAAY,kDAAiDQ,cAAc,IAAI,QAAS,oBAAmBA,cAAc,GAAG,MAAH,GAAY,QAAS,2CAA9I,EAA0L,GAA1L,CAAd;QAEA,OAAO,KAAKpC,SAAL,CAAe;UAAEO,IAAI,EAAE,MAAR;UAAgBxC,IAAI,EAAE;YAAEa;UAAF,CAAtB;UAAmC5C;QAAnC,CAAf,CAAP;MACH,CA7BC;;MA8BF4D,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,EAAiBlC,IAAjB,SAAkC;QAAA,IAAX;UAAE/B;QAAF,CAAW;QAEtC,MAAMgH,OAAO,GAAGhH,KAAK,CAACiH,IAAN,CAAWxF,KAAX,CAAhB;;QAEA,IAAI,CAACuF,OAAL,EAAc;UACV,OAAO/C,OAAO,CAACJ,KAAR,CAAc,aAAd,CAAP;QACH,CANqC,CAQtC;;;QAEA,IAAIxE,SAAS,CAACa,YAAV,CAAuB8G,OAAO,CAAC,CAAD,CAA9B,MAAuCA,OAAO,CAACA,OAAO,CAAClE,MAAR,GAAiB,CAAlB,CAAlD,EAAwE;UACpE,OAAOmB,OAAO,CAACJ,KAAR,CAAc,aAAd,CAAP;QACH;;QAED,OAAOpC,KAAP;MACH;;IA7CC,CAxKH;IAwNHkB,GAAG,EAAE;MACDnB,MAAM,GAAe;QAAA,IAAdoB,OAAc,uEAAJ,EAAI;QAEjBxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,aAAD,CAA9B;QAEAA,OAAO,GAAG;UAAEC,WAAW,EAAE,KAAf;UAAsB,GAAGD;QAAzB,CAAV;QACAjE,MAAM,CAAC,OAAOiE,OAAO,CAACC,WAAf,KAA+B,SAAhC,EAA2C,6BAA3C,CAAN;QAEA,OAAO,KAAKmB,SAAL,CAAe;UAAEO,IAAI,EAAE,KAAR;UAAexC,IAAI,EAAE;YAAEa;UAAF;QAArB,CAAf,CAAP;MACH,CATA;;MAUDgB,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,UAA8B;QAAA,IAAb;UAAErB;QAAF,CAAa;;QAElC,IAAI,CAACvD,SAAS,CAACS,QAAV,CAAmBoE,IAAnB,CAAwBzC,KAAxB,CAAL,EAAqC;UACjC,OAAOwC,OAAO,CAACJ,KAAR,CAAc,YAAd,CAAP;QACH;;QAED,IAAIjB,OAAO,CAACC,WAAR,IACApB,KAAK,CAACqB,MAAN,GAAe,CAAf,KAAqB,CADzB,EAC4B;UAExB,OAAOmB,OAAO,CAACJ,KAAR,CAAc,iBAAd,CAAP;QACH;;QAED,OAAOpC,KAAP;MACH;;IAvBA,CAxNF;IAkPHyF,QAAQ,EAAE;MACN1F,MAAM,GAAG;QAEL,OAAO,KAAKwC,SAAL,CAAe,UAAf,CAAP;MACH,CAJK;;MAKNJ,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,EAAiB;QAErB,IAAIpF,MAAM,CAAC2G,OAAP,CAAe/D,KAAf,EAAsB;UAAE0F,iBAAiB,EAAE;QAArB,CAAtB,KACA9H,SAAS,CAACU,OAAV,CAAkBmE,IAAlB,CAAuBzC,KAAvB,CADJ,EACmC;UAE/B,OAAOA,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,iBAAd,CAAP;MACH;;IAdK,CAlPP;IAmQH7C,WAAW,EAAE;MACTQ,MAAM,GAAG;QAEL,OAAO,KAAK4F,SAAL,CAAe,aAAf,EAA8B,IAA9B,CAAP;MACH;;IAJQ,CAnQV;IA0QHC,EAAE,EAAE;MACA7F,MAAM,GAAe;QAAA,IAAdoB,OAAc,uEAAJ,EAAI;QAEjBxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,MAAD,EAAS,SAAT,CAA9B;QAEA,MAAM;UAAE0E,IAAF;UAAQhB,QAAR;UAAkBtG;QAAlB,IAA4BjB,EAAE,CAACiB,KAAH,CAAS4C,OAAT,CAAlC;QACA,MAAMyD,OAAO,GAAGzD,OAAO,CAACyD,OAAR,GAAkBC,QAAlB,GAA6BX,SAA7C;QACA,OAAO,KAAK3B,SAAL,CAAe;UAAEO,IAAI,EAAE,IAAR;UAAcxC,IAAI,EAAE;YAAEa,OAAO,EAAE;cAAE0E,IAAF;cAAQjB;YAAR;UAAX,CAApB;UAAoDrG;QAApD,CAAf,CAAP;MACH,CARD;;MASA4D,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,kBAAyC;QAAA,IAAxB;UAAErB;QAAF,CAAwB;QAAA,IAAX;UAAE5C;QAAF,CAAW;;QAE7C,IAAIA,KAAK,CAACkE,IAAN,CAAWzC,KAAX,CAAJ,EAAuB;UACnB,OAAOA,KAAP;QACH;;QAED,IAAImB,OAAO,CAACyD,OAAZ,EAAqB;UACjB,OAAOpC,OAAO,CAACJ,KAAR,CAAc,kBAAd,EAAkC;YAAEpC,KAAF;YAAS6F,IAAI,EAAE1E,OAAO,CAAC0E,IAAvB;YAA6BjB,OAAO,EAAEzD,OAAO,CAACyD;UAA9C,CAAlC,CAAP;QACH;;QAED,OAAOpC,OAAO,CAACJ,KAAR,CAAc,WAAd,EAA2B;UAAEpC,KAAF;UAAS6F,IAAI,EAAE1E,OAAO,CAAC0E;QAAvB,CAA3B,CAAP;MACH;;IApBD,CA1QD;IAiSHtE,OAAO,EAAE;MACLxB,MAAM,GAAG;QAEL,OAAO,KAAKwC,SAAL,CAAe,SAAf,CAAP;MACH,CAJI;;MAKLJ,QAAQ,CAACnC,KAAD,UAAmB;QAAA,IAAX;UAAEoC;QAAF,CAAW;;QAEvB,IAAIxE,SAAS,CAAC2D,OAAV,CAAkBvB,KAAlB,CAAJ,EAA8B;UAC1B,OAAOA,KAAP;QACH;;QAED,OAAOoC,KAAK,CAAC,gBAAD,CAAZ;MACH;;IAZI,CAjSN;IAgTH0D,WAAW,EAAE;MACT/F,MAAM,GAAG;QAEL,OAAO,KAAKwC,SAAL,CAAe,aAAf,CAAP;MACH,CAJQ;;MAKTJ,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,EAAiB;QAErB,IAAI5E,SAAS,CAACY,gBAAV,CAA2BiE,IAA3B,CAAgCzC,KAAhC,CAAJ,EAA4C;UACxC,OAAOA,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,oBAAd,CAAP;MACH;;IAZQ,CAhTV;IA+THf,MAAM,EAAE;MACJtB,MAAM,CAAC2B,KAAD,EAAQqE,QAAR,EAAkB;QAEpB,OAAOnI,SAAS,CAACyD,MAAV,CAAiB,IAAjB,EAAuB,QAAvB,EAAiCK,KAAjC,EAAwC,GAAxC,EAA6CqE,QAA7C,CAAP;MACH,CAJG;;MAKJ5D,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,kBAAgE;QAAA,IAA/C;UAAEd,KAAF;UAASqE;QAAT,CAA+C;QAAA,IAA1B;UAAEjD,IAAF;UAAQkD,QAAR;UAAkB1F;QAAlB,CAA0B;QAEpE,MAAMe,MAAM,GAAG0E,QAAQ,GAAGE,MAAM,IAAIA,MAAM,CAACC,UAAP,CAAkBlG,KAAlB,EAAyB+F,QAAzB,CAAb,GAAkD/F,KAAK,CAACqB,MAA/E,CAFoE,CAEwB;;QAC5F,IAAI1D,MAAM,CAACwI,OAAP,CAAe9E,MAAf,EAAuBK,KAAvB,EAA8BsE,QAA9B,CAAJ,EAA6C;UACzC,OAAOhG,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,YAAYU,IAA1B,EAAgC;UAAEpB,KAAK,EAAEpB,IAAI,CAACoB,KAAd;UAAqB1B,KAArB;UAA4B+F;QAA5B,CAAhC,CAAP;MACH,CAbG;;MAcJzF,IAAI,EAAE,CACF;QACIwC,IAAI,EAAE,OADV;QAEIf,GAAG,EAAE,IAFT;QAGIqE,MAAM,EAAEzI,MAAM,CAAC+D,KAHnB;QAII2E,OAAO,EAAE;MAJb,CADE,EAOF,UAPE;IAdF,CA/TL;IAwVHC,SAAS,EAAE;MACPvG,MAAM,GAAG;QAEL,OAAO,KAAKgD,IAAL,CAAU,OAAV,CAAP;MACH;;IAJM,CAxVR;IA+VHwD,GAAG,EAAE;MACDxG,MAAM,CAAC2B,KAAD,EAAQqE,QAAR,EAAkB;QAEpB,OAAOnI,SAAS,CAACyD,MAAV,CAAiB,IAAjB,EAAuB,KAAvB,EAA8BK,KAA9B,EAAqC,IAArC,EAA2CqE,QAA3C,CAAP;MACH,CAJA;;MAKDzF,IAAI,EAAE,CAAC,OAAD,EAAU,UAAV;IALL,CA/VF;IAuWHkG,GAAG,EAAE;MACDzG,MAAM,CAAC2B,KAAD,EAAQqE,QAAR,EAAkB;QAEpB,OAAOnI,SAAS,CAACyD,MAAV,CAAiB,IAAjB,EAAuB,KAAvB,EAA8BK,KAA9B,EAAqC,IAArC,EAA2CqE,QAA3C,CAAP;MACH,CAJA;;MAKDzF,IAAI,EAAE,CAAC,OAAD,EAAU,UAAV;IALL,CAvWF;IA+WHF,SAAS,EAAE;MACPL,MAAM,GAAe;QAAA,IAAdQ,IAAc,uEAAP,KAAO;QAEjBrD,MAAM,CAACU,SAAS,CAACqB,kBAAV,CAA6B+D,QAA7B,CAAsCzC,IAAtC,CAAD,EAA8C,uCAAuC3C,SAAS,CAACqB,kBAAV,CAA6BmG,IAA7B,CAAkC,IAAlC,CAArF,CAAN;QAEA,OAAO,KAAK7C,SAAL,CAAe;UAAEO,IAAI,EAAE,WAAR;UAAqBxC,IAAI,EAAE;YAAEC;UAAF;QAA3B,CAAf,CAAP;MACH,CANM;;MAOP4B,QAAQ,CAACnC,KAAD,kBAA6B;QAAA,IAArB;UAAEoC;QAAF,CAAqB;QAAA,IAAV;UAAE7B;QAAF,CAAU;;QAEjC,IAAIP,KAAK,KAAKA,KAAK,CAACI,SAAN,CAAgBG,IAAhB,CAAd,EAAqC;UACjC,OAAOP,KAAP;QACH;;QAED,OAAOoC,KAAK,CAAC,kBAAD,EAAqB;UAAEpC,KAAF;UAASO;QAAT,CAArB,CAAZ;MACH,CAdM;;MAeP0C,OAAO,EAAE;IAfF,CA/WR;IAiYHhC,OAAO,EAAE;MACLyD,KAAK,EAAE,OADF;;MAEL3E,MAAM,CAACxB,KAAD,EAAsB;QAAA,IAAd4C,OAAc,uEAAJ,EAAI;QAExBjE,MAAM,CAACqB,KAAK,YAAY4F,MAAlB,EAA0B,wBAA1B,CAAN;QACAjH,MAAM,CAAC,CAACqB,KAAK,CAACe,KAAN,CAAY0D,QAAZ,CAAqB,GAArB,CAAD,IAA8B,CAACzE,KAAK,CAACe,KAAN,CAAY0D,QAAZ,CAAqB,GAArB,CAAhC,EAA2D,4CAA3D,CAAN;;QAEA,IAAI,OAAO7B,OAAP,KAAmB,QAAvB,EAAiC;UAC7BA,OAAO,GAAG;YAAE2B,IAAI,EAAE3B;UAAR,CAAV;QACH;;QAEDxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,QAAD,EAAW,MAAX,CAA9B;QAEA,MAAMsF,SAAS,GAAG,CAAC,gBAAD,EAAmBtF,OAAO,CAACuF,MAAR,GAAiB,SAAjB,GAA6B,EAAhD,EAAoDvF,OAAO,CAAC2B,IAAR,GAAe,OAAf,GAAyB,OAA7E,EAAsFsC,IAAtF,CAA2F,EAA3F,CAAlB;QACA,OAAO,KAAK7C,SAAL,CAAe;UAAEO,IAAI,EAAE,SAAR;UAAmBxC,IAAI,EAAE;YAAE/B,KAAF;YAAS4C;UAAT,CAAzB;UAA6CsF;QAA7C,CAAf,CAAP;MACH,CAfI;;MAgBLtE,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,kBAAoD;QAAA,IAAnC;UAAEjE,KAAF;UAAS4C;QAAT,CAAmC;QAAA,IAAf;UAAEsF;QAAF,CAAe;QAExD,MAAME,YAAY,GAAGpI,KAAK,CAACkE,IAAN,CAAWzC,KAAX,CAArB;;QAEA,IAAI2G,YAAY,GAAGxF,OAAO,CAACuF,MAA3B,EAAmC;UAC/B,OAAO1G,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAcqE,SAAd,EAAyB;UAAE3D,IAAI,EAAE3B,OAAO,CAAC2B,IAAhB;UAAsBvE,KAAtB;UAA6ByB;QAA7B,CAAzB,CAAP;MACH,CAzBI;;MA0BLM,IAAI,EAAE,CAAC,OAAD,EAAU,SAAV,CA1BD;MA2BLsG,KAAK,EAAE;IA3BF,CAjYN;IA+ZH5F,OAAO,EAAE;MACLjB,MAAM,CAACkB,OAAD,EAAUF,WAAV,EAAuB;QAEzB,IAAI,OAAOE,OAAP,KAAmB,QAAvB,EAAiC;UAC7BA,OAAO,GAAG,IAAIkD,MAAJ,CAAW5G,WAAW,CAAC0D,OAAD,CAAtB,EAAiC,GAAjC,CAAV;QACH;;QAED/D,MAAM,CAAC+D,OAAO,YAAYkD,MAApB,EAA4B,0BAA5B,CAAN;QACAjH,MAAM,CAAC,OAAO6D,WAAP,KAAuB,QAAxB,EAAkC,8BAAlC,CAAN;QAEA,MAAM8F,GAAG,GAAG,KAAKC,KAAL,EAAZ;;QAEA,IAAI,CAACD,GAAG,CAAC/F,OAAJ,CAAYnB,YAAjB,EAA+B;UAC3BkH,GAAG,CAAC/F,OAAJ,CAAYnB,YAAZ,GAA2B,EAA3B;QACH;;QAEDkH,GAAG,CAAC/F,OAAJ,CAAYnB,YAAZ,CAAyB6E,IAAzB,CAA8B;UAAEvD,OAAF;UAAWF;QAAX,CAA9B;QACA,OAAO8F,GAAP;MACH;;IAlBI,CA/ZN;IAobHE,KAAK,EAAE;MACHhH,MAAM,GAAG;QAEL,OAAO,KAAKwC,SAAL,CAAe,OAAf,CAAP;MACH,CAJE;;MAKHJ,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,EAAiB;QAErB,IAAI,QAAQC,IAAR,CAAazC,KAAb,CAAJ,EAAyB;UACrB,OAAOA,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,cAAd,CAAP;MACH;;IAZE,CApbJ;IAmcHxB,IAAI,EAAE;MACFb,MAAM,GAAiB;QAAA,IAAhBc,OAAgB,uEAAN,IAAM;QAEnB3D,MAAM,CAAC,OAAO2D,OAAP,KAAmB,SAApB,EAA+B,2BAA/B,CAAN;QAEA,OAAO,KAAK0B,SAAL,CAAe;UAAEO,IAAI,EAAE,MAAR;UAAgBxC,IAAI,EAAE;YAAEO;UAAF;QAAtB,CAAf,CAAP;MACH,CANC;;MAOFsB,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,UAA8B;QAAA,IAAb;UAAE3B;QAAF,CAAa;;QAElC,IAAI,CAACA,OAAD,IACAb,KAAK,KAAKA,KAAK,CAACY,IAAN,EADd,EAC4B;UAExB,OAAOZ,KAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,aAAd,CAAP;MACH,CAhBC;;MAiBFa,OAAO,EAAE;IAjBP,CAncH;IAudHxD,QAAQ,EAAE;MACNM,MAAM,GAAiB;QAAA,IAAhBc,OAAgB,uEAAN,IAAM;QAEnB3D,MAAM,CAAC,OAAO2D,OAAP,KAAmB,SAApB,EAA+B,2BAA/B,CAAN;QAEA,OAAO,KAAK8E,SAAL,CAAe,UAAf,EAA2B9E,OAA3B,CAAP;MACH;;IANK,CAvdP;IAgeHmG,SAAS,EAAE;MACPjH,MAAM,GAAG;QAEL,OAAO,KAAKgD,IAAL,CAAU,OAAV,CAAP;MACH;;IAJM,CAheR;IAueHkE,GAAG,EAAE;MACDlH,MAAM,GAAe;QAAA,IAAdoB,OAAc,uEAAJ,EAAI;QAEjBxD,MAAM,CAACgF,aAAP,CAAqBxB,OAArB,EAA8B,CAAC,eAAD,EAAkB,0BAAlB,EAA8C,QAA9C,EAAwD,cAAxD,EAAwE,QAAxE,CAA9B;;QAEA,IAAIA,OAAO,CAACyC,MAAZ,EAAoB;UAChBjG,MAAM,CAACgF,aAAP,CAAqBxB,OAAO,CAACyC,MAA7B,EAAqC,CAAC,cAAD,EAAiB,mBAAjB,EAAsC,MAAtC,CAArC;QACH;;QAED,MAAM;UAAErF,KAAF;UAAS2I;QAAT,IAAoBzJ,GAAG,CAACc,KAAJ,CAAU4C,OAAV,CAA1B;QACA,MAAMyC,MAAM,GAAGzC,OAAO,CAACyC,MAAR,GAAiBhG,SAAS,CAACkG,cAAV,CAAyB3C,OAAO,CAACyC,MAAjC,CAAjB,GAA4D,IAA3E;QACA,OAAO,KAAKrB,SAAL,CAAe;UAAEO,IAAI,EAAE,KAAR;UAAexC,IAAI,EAAE;YAAEa;UAAF,CAArB;UAAkC5C,KAAlC;UAAyCqF,MAAzC;UAAiDsD;QAAjD,CAAf,CAAP;MACH,CAZA;;MAaD/E,QAAQ,CAACnC,KAAD,EAAQwC,OAAR,kBAAyD;QAAA,IAAxC;UAAErB;QAAF,CAAwC;QAAA,IAA3B;UAAE5C,KAAF;UAASqF,MAAT;UAAiBsD;QAAjB,CAA2B;;QAE7D,IAAI,CAAC,QAAD,EAAW,SAAX,EAAsBlE,QAAtB,CAA+BhD,KAA/B,CAAJ,EAA2C;UAAa;UACpD,OAAOwC,OAAO,CAACJ,KAAR,CAAc,YAAd,CAAP;QACH;;QAED,MAAMsB,KAAK,GAAGnF,KAAK,CAACiH,IAAN,CAAWxF,KAAX,CAAd;;QACA,IAAI0D,KAAJ,EAAW;UACP,IAAIE,MAAJ,EAAY;YACR,MAAMuD,OAAO,GAAGzD,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAjC;;YACA,IAAI,CAACtG,MAAM,CAAC2G,OAAP,CAAeoD,OAAf,EAAwBvD,MAAxB,CAAL,EAAsC;cAClC,OAAOpB,OAAO,CAACJ,KAAR,CAAc,eAAd,EAA+B;gBAAEpC,KAAK,EAAEmH;cAAT,CAA/B,CAAP;YACH;UACJ;;UAED,OAAOnH,KAAP;QACH;;QAED,IAAImB,OAAO,CAACiG,YAAZ,EAA0B;UACtB,OAAO5E,OAAO,CAACJ,KAAR,CAAc,wBAAd,CAAP;QACH;;QAED,IAAIjB,OAAO,CAAC+F,MAAZ,EAAoB;UAChB,OAAO1E,OAAO,CAACJ,KAAR,CAAc,wBAAd,EAAwC;YAAE8E,MAAF;YAAUlH;UAAV,CAAxC,CAAP;QACH;;QAED,OAAOwC,OAAO,CAACJ,KAAR,CAAc,YAAd,CAAP;MACH;;IAxCA;EAveF,CAvFiB;EA0mBxBiF,QAAQ,EAAE;IAENC,KAAK,CAACT,GAAD,EAAMU,IAAN,EAAY;MAEb,IAAIA,IAAI,CAAC5H,YAAT,EAAuB;QACnB,KAAK,MAAM;UAAEsB,OAAF;UAAWF;QAAX,CAAX,IAAuCwG,IAAI,CAAC5H,YAA5C,EAA0D;UACtDkH,GAAG,GAAGA,GAAG,CAAC7F,OAAJ,CAAYC,OAAZ,EAAqBF,WAArB,CAAN;QACH;MACJ;;MAED,OAAO8F,GAAP;IACH;;EAXK,CA1mBc;EAwnBxBW,QAAQ,EAAE;IACN,mBAAmB,uDADb;IAEN,eAAe,6BAFT;IAGN,iBAAiB,0CAHX;IAIN,qBAAqB,kCAJf;IAKN,kBAAkB,2CALZ;IAMN,iBAAiB,6CANX;IAON,gBAAgB,kCAPV;IAQN,gBAAgB,uCARV;IASN,eAAe,iCATT;IAUN,cAAc,qDAVR;IAWN,mBAAmB,4DAXb;IAYN,mBAAmB,qCAZb;IAaN,aAAa,6DAbP;IAcN,oBAAoB,2GAdd;IAeN,kBAAkB,kCAfZ;IAgBN,sBAAsB,8CAhBhB;IAiBN,iBAAiB,sDAjBX;IAkBN,oBAAoB,mDAlBd;IAmBN,cAAc,4EAnBR;IAoBN,cAAc,+DApBR;IAqBN,oBAAoB,6DArBd;IAsBN,gBAAgB,sEAtBV;IAuBN,uBAAuB,+EAvBjB;IAwBN,uBAAuB,oEAxBjB;IAyBN,8BAA8B,wEAzBxB;IA0BN,8BAA8B,sEA1BxB;IA2BN,eAAe,yDA3BT;IA4BN,cAAc,gCA5BR;IA6BN,0BAA0B,+EA7BpB;IA8BN,0BAA0B,yCA9BpB;IA+BN,oBAAoB;EA/Bd;AAxnBc,CAAX,CAAjB,C,CA4pBA;;AAEA5J,SAAS,CAACkG,cAAV,GAA2B,UAAU3C,OAAV,EAAmB;EAE1C,IAAI,CAACA,OAAL,EAAc;IACV,OAAOA,OAAP;EACH,CAJyC,CAM1C;;;EAEAjE,MAAM,CAACiE,OAAO,CAACuE,iBAAR,KAA8BxB,SAA9B,IACHuD,MAAM,CAACC,aAAP,CAAqBvG,OAAO,CAACuE,iBAA7B,KAAmDvE,OAAO,CAACuE,iBAAR,GAA4B,CAD7E,EACgF,8CADhF,CAAN,CAR0C,CAW1C;;EAEA,IAAIvE,OAAO,CAACtD,IAAR,KAAiB,KAArB,EAA4B;IACxB,OAAOsD,OAAP;EACH;;EAED,IAAIA,OAAO,CAACtD,IAAR,KAAiB,IAAjB,IACAsD,OAAO,CAACtD,IAAR,KAAiBqG,SADrB,EACgC;IAE5BhH,MAAM,CAACU,SAAS,CAACC,IAAX,EAAiB,4BAAjB,CAAN;IACA,OAAOqH,MAAM,CAACyC,MAAP,CAAc,EAAd,EAAkBxG,OAAlB,EAA2BvD,SAAS,CAACC,IAArC,CAAP;EACH;;EAEDX,MAAM,CAAC,OAAOiE,OAAO,CAACtD,IAAf,KAAwB,QAAzB,EAAmC,wCAAnC,CAAN;EAEA,MAAMG,IAAI,GAAGmD,OAAO,CAACtD,IAAR,CAAaG,IAA1B;;EACA,IAAIA,IAAJ,EAAU;IACN,IAAI4J,KAAK,CAACC,OAAN,CAAc7J,IAAd,CAAJ,EAAyB;MACrBmD,OAAO,GAAG+D,MAAM,CAACyC,MAAP,CAAc,EAAd,EAAkBxG,OAAlB,EAA2B;QAAEtD,IAAI,EAAE;UAAEG,IAAI,EAAE,IAAIF,GAAJ,CAAQE,IAAR;QAAR;MAAR,CAA3B,CAAV;IACH;;IAEDd,MAAM,CAACiE,OAAO,CAACtD,IAAR,CAAaG,IAAb,YAA6BF,GAA9B,EAAmC,6CAAnC,CAAN;IACAZ,MAAM,CAAC,CAACiE,OAAO,CAACtD,IAAR,CAAaE,KAAf,EAAsB,oDAAtB,CAAN;IACA,OAAOoD,OAAP;EACH;;EAED,MAAMpD,KAAK,GAAGoD,OAAO,CAACtD,IAAR,CAAaE,KAA3B;;EACA,IAAI,CAACA,KAAL,EAAY;IACR,OAAOoD,OAAP;EACH;;EAED,IAAIpD,KAAK,KAAK,IAAd,EAAoB;IAChBb,MAAM,CAACU,SAAS,CAACC,IAAX,EAAiB,4BAAjB,CAAN;IACA,OAAOqH,MAAM,CAACyC,MAAP,CAAc,EAAd,EAAkBxG,OAAlB,EAA2BvD,SAAS,CAACC,IAArC,CAAP;EACH;;EAED,IAAI+J,KAAK,CAACC,OAAN,CAAc9J,KAAd,CAAJ,EAA0B;IACtBoD,OAAO,GAAG+D,MAAM,CAACyC,MAAP,CAAc,EAAd,EAAkBxG,OAAlB,EAA2B;MAAEtD,IAAI,EAAE;QAAEE,KAAK,EAAE,IAAID,GAAJ,CAAQC,KAAR;MAAT;IAAR,CAA3B,CAAV;EACH;;EAEDb,MAAM,CAACiE,OAAO,CAACtD,IAAR,CAAaE,KAAb,YAA8BD,GAA/B,EAAoC,8CAApC,CAAN;EACA,OAAOqD,OAAP;AACH,CArDD;;AAwDAvD,SAAS,CAAC2D,OAAV,GAAoB,UAAUvB,KAAV,EAAiB;EAEjC,IAAI,CAACrC,MAAM,CAACmK,SAAP,CAAiB9H,KAAjB,CAAL,EAA8B;IAC1B,OAAO,IAAP;EACH;;EAED,MAAM+H,IAAI,GAAG,IAAIC,IAAJ,CAAShI,KAAT,CAAb;;EACA,IAAIiI,KAAK,CAACF,IAAI,CAACG,OAAL,EAAD,CAAT,EAA2B;IACvB,OAAO,IAAP;EACH;;EAED,OAAOH,IAAI,CAACI,WAAL,EAAP;AACH,CAZD;;AAeAvK,SAAS,CAACyD,MAAV,GAAmB,UAAUpB,MAAV,EAAkB6C,IAAlB,EAAwBpB,KAAxB,EAA+BsE,QAA/B,EAAyCD,QAAzC,EAAmD;EAElE7I,MAAM,CAAC,CAAC6I,QAAD,IAAaE,MAAM,IAAIA,MAAM,CAACmC,UAAP,CAAkBrC,QAAlB,CAAxB,EAAqD,mBAArD,EAA0EA,QAA1E,CAAN,CAFkE,CAE8B;;EAEhG,OAAO9F,MAAM,CAACsC,SAAP,CAAiB;IAAEO,IAAF;IAAQ/C,MAAM,EAAE,QAAhB;IAA0BO,IAAI,EAAE;MAAEoB,KAAF;MAASqE;IAAT,CAAhC;IAAqDC;EAArD,CAAjB,CAAP;AACH,CALD"},"metadata":{},"sourceType":"script"}