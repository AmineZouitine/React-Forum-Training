{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\n\nlet Template;\nconst internals = {\n  symbol: Symbol('ref'),\n  // Used to internally identify references (shared with other joi versions)\n  defaults: {\n    adjust: null,\n    in: false,\n    iterables: null,\n    map: null,\n    separator: '.',\n    type: 'value'\n  }\n};\n\nexports.create = function (key) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Assert(typeof key === 'string', 'Invalid reference key:', key);\n  Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'separator']);\n  Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');\n  const ref = Object.assign({}, internals.defaults, options);\n  delete ref.prefix;\n  const separator = ref.separator;\n  const context = internals.context(key, separator, options.prefix);\n  ref.type = context.type;\n  key = context.key;\n\n  if (ref.type === 'value') {\n    if (context.root) {\n      Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');\n      ref.ancestor = 'root';\n\n      if (!key) {\n        key = null;\n      }\n    }\n\n    if (separator && separator === key) {\n      key = null;\n      ref.ancestor = 0;\n    } else {\n      if (ref.ancestor !== undefined) {\n        Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');\n      } else {\n        const [ancestor, slice] = internals.ancestor(key, separator);\n\n        if (slice) {\n          key = key.slice(slice);\n\n          if (key === '') {\n            key = null;\n          }\n        }\n\n        ref.ancestor = ancestor;\n      }\n    }\n  }\n\n  ref.path = separator ? key === null ? [] : key.split(separator) : [key];\n  return new internals.Ref(ref);\n};\n\nexports.in = function (key) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return exports.create(key, Object.assign({}, options, {\n    in: true\n  }));\n};\n\nexports.isRef = function (ref) {\n  return ref ? !!ref[Common.symbols.ref] : false;\n};\n\ninternals.Ref = class {\n  constructor(options) {\n    Assert(typeof options === 'object', 'Invalid reference construction');\n    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'separator', 'type', // Copied\n    'depth', 'key', 'root', 'display' // Overridden\n    ]);\n    Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');\n    Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');\n    Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');\n    Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');\n    Object.assign(this, internals.defaults, options);\n    Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');\n\n    if (Array.isArray(this.map)) {\n      this.map = new Map(this.map);\n    }\n\n    this.depth = this.path.length;\n    this.key = this.path.length ? this.path.join(this.separator) : null;\n    this.root = this.path[0];\n    this.updateDisplay();\n  }\n\n  resolve(value, state, prefs, local) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    Assert(!this.in || options.in, 'Invalid in() reference usage');\n\n    if (this.type === 'global') {\n      return this._resolve(prefs.context, state, options);\n    }\n\n    if (this.type === 'local') {\n      return this._resolve(local, state, options);\n    }\n\n    if (!this.ancestor) {\n      return this._resolve(value, state, options);\n    }\n\n    if (this.ancestor === 'root') {\n      return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);\n    }\n\n    Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);\n    return this._resolve(state.ancestors[this.ancestor - 1], state, options);\n  }\n\n  _resolve(target, state, options) {\n    let resolved;\n\n    if (this.type === 'value' && state.mainstay.shadow && options.shadow !== false) {\n      resolved = state.mainstay.shadow.get(this.absolute(state));\n    }\n\n    if (resolved === undefined) {\n      resolved = Reach(target, this.path, {\n        iterables: this.iterables,\n        functions: true\n      });\n    }\n\n    if (this.adjust) {\n      resolved = this.adjust(resolved);\n    }\n\n    if (this.map) {\n      const mapped = this.map.get(resolved);\n\n      if (mapped !== undefined) {\n        resolved = mapped;\n      }\n    }\n\n    if (state.mainstay) {\n      state.mainstay.tracer.resolve(state, this, resolved);\n    }\n\n    return resolved;\n  }\n\n  toString() {\n    return this.display;\n  }\n\n  absolute(state) {\n    return [...state.path.slice(0, -this.ancestor), ...this.path];\n  }\n\n  clone() {\n    return new internals.Ref(this);\n  }\n\n  describe() {\n    const ref = {\n      path: this.path\n    };\n\n    if (this.type !== 'value') {\n      ref.type = this.type;\n    }\n\n    if (this.separator !== '.') {\n      ref.separator = this.separator;\n    }\n\n    if (this.type === 'value' && this.ancestor !== 1) {\n      ref.ancestor = this.ancestor;\n    }\n\n    if (this.map) {\n      ref.map = [...this.map];\n    }\n\n    for (const key of ['adjust', 'iterables']) {\n      if (this[key] !== null) {\n        ref[key] = this[key];\n      }\n    }\n\n    if (this.in !== false) {\n      ref.in = true;\n    }\n\n    return {\n      ref\n    };\n  }\n\n  updateDisplay() {\n    const key = this.key !== null ? this.key : '';\n\n    if (this.type !== 'value') {\n      this.display = `ref:${this.type}:${key}`;\n      return;\n    }\n\n    if (!this.separator) {\n      this.display = `ref:${key}`;\n      return;\n    }\n\n    if (!this.ancestor) {\n      this.display = `ref:${this.separator}${key}`;\n      return;\n    }\n\n    if (this.ancestor === 'root') {\n      this.display = `ref:root:${key}`;\n      return;\n    }\n\n    if (this.ancestor === 1) {\n      this.display = `ref:${key || '..'}`;\n      return;\n    }\n\n    const lead = new Array(this.ancestor + 1).fill(this.separator).join('');\n    this.display = `ref:${lead}${key || ''}`;\n  }\n\n};\ninternals.Ref.prototype[Common.symbols.ref] = true;\n\nexports.build = function (desc) {\n  desc = Object.assign({}, internals.defaults, desc);\n\n  if (desc.type === 'value' && desc.ancestor === undefined) {\n    desc.ancestor = 1;\n  }\n\n  return new internals.Ref(desc);\n};\n\ninternals.context = function (key, separator) {\n  let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  key = key.trim();\n\n  if (prefix) {\n    const globalp = prefix.global === undefined ? '$' : prefix.global;\n\n    if (globalp !== separator && key.startsWith(globalp)) {\n      return {\n        key: key.slice(globalp.length),\n        type: 'global'\n      };\n    }\n\n    const local = prefix.local === undefined ? '#' : prefix.local;\n\n    if (local !== separator && key.startsWith(local)) {\n      return {\n        key: key.slice(local.length),\n        type: 'local'\n      };\n    }\n\n    const root = prefix.root === undefined ? '/' : prefix.root;\n\n    if (root !== separator && key.startsWith(root)) {\n      return {\n        key: key.slice(root.length),\n        type: 'value',\n        root: true\n      };\n    }\n  }\n\n  return {\n    key,\n    type: 'value'\n  };\n};\n\ninternals.ancestor = function (key, separator) {\n  if (!separator) {\n    return [1, 0]; // 'a_b' -> 1 (parent)\n  }\n\n  if (key[0] !== separator) {\n    // 'a.b' -> 1 (parent)\n    return [1, 0];\n  }\n\n  if (key[1] !== separator) {\n    // '.a.b' -> 0 (self)\n    return [0, 1];\n  }\n\n  let i = 2;\n\n  while (key[i] === separator) {\n    ++i;\n  }\n\n  return [i - 1, i]; // '...a.b.' -> 2 (grandparent)\n};\n\nexports.toSibling = 0;\nexports.toParent = 1;\nexports.Manager = class {\n  constructor() {\n    this.refs = []; // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...\n  }\n\n  register(source, target) {\n    if (!source) {\n      return;\n    }\n\n    target = target === undefined ? exports.toParent : target; // Array\n\n    if (Array.isArray(source)) {\n      for (const ref of source) {\n        this.register(ref, target);\n      }\n\n      return;\n    } // Schema\n\n\n    if (Common.isSchema(source)) {\n      for (const item of source._refs.refs) {\n        if (item.ancestor - target >= 0) {\n          this.refs.push({\n            ancestor: item.ancestor - target,\n            root: item.root\n          });\n        }\n      }\n\n      return;\n    } // Reference\n\n\n    if (exports.isRef(source) && source.type === 'value' && source.ancestor - target >= 0) {\n      this.refs.push({\n        ancestor: source.ancestor - target,\n        root: source.root\n      });\n    } // Template\n\n\n    Template = Template || require('./template');\n\n    if (Template.isTemplate(source)) {\n      this.register(source.refs(), target);\n    }\n  }\n\n  get length() {\n    return this.refs.length;\n  }\n\n  clone() {\n    const copy = new exports.Manager();\n    copy.refs = Clone(this.refs);\n    return copy;\n  }\n\n  reset() {\n    this.refs = [];\n  }\n\n  roots() {\n    return this.refs.filter(ref => !ref.ancestor).map(ref => ref.root);\n  }\n\n};","map":{"version":3,"names":["Assert","require","Clone","Reach","Common","Template","internals","symbol","Symbol","defaults","adjust","in","iterables","map","separator","type","exports","create","key","options","assertOptions","prefix","ref","Object","assign","context","root","ancestor","undefined","slice","path","split","Ref","isRef","symbols","constructor","includes","length","Array","isArray","Map","depth","join","updateDisplay","resolve","value","state","prefs","local","_resolve","ancestors","display","target","resolved","mainstay","shadow","get","absolute","functions","mapped","tracer","toString","clone","describe","lead","fill","prototype","build","desc","trim","globalp","global","startsWith","i","toSibling","toParent","Manager","refs","register","source","isSchema","item","_refs","push","isTemplate","copy","reset","roots","filter"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/ref.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\n\nlet Template;\n\n\nconst internals = {\n    symbol: Symbol('ref'),      // Used to internally identify references (shared with other joi versions)\n    defaults: {\n        adjust: null,\n        in: false,\n        iterables: null,\n        map: null,\n        separator: '.',\n        type: 'value'\n    }\n};\n\n\nexports.create = function (key, options = {}) {\n\n    Assert(typeof key === 'string', 'Invalid reference key:', key);\n    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'separator']);\n    Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');\n\n    const ref = Object.assign({}, internals.defaults, options);\n    delete ref.prefix;\n\n    const separator = ref.separator;\n    const context = internals.context(key, separator, options.prefix);\n    ref.type = context.type;\n    key = context.key;\n\n    if (ref.type === 'value') {\n        if (context.root) {\n            Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');\n            ref.ancestor = 'root';\n            if (!key) {\n                key = null;\n            }\n        }\n\n        if (separator &&\n            separator === key) {\n\n            key = null;\n            ref.ancestor = 0;\n        }\n        else {\n            if (ref.ancestor !== undefined) {\n                Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');\n            }\n            else {\n                const [ancestor, slice] = internals.ancestor(key, separator);\n                if (slice) {\n                    key = key.slice(slice);\n                    if (key === '') {\n                        key = null;\n                    }\n                }\n\n                ref.ancestor = ancestor;\n            }\n        }\n    }\n\n    ref.path = separator ? (key === null ? [] : key.split(separator)) : [key];\n\n    return new internals.Ref(ref);\n};\n\n\nexports.in = function (key, options = {}) {\n\n    return exports.create(key, Object.assign({}, options, { in: true }));\n};\n\n\nexports.isRef = function (ref) {\n\n    return ref ? !!ref[Common.symbols.ref] : false;\n};\n\n\ninternals.Ref = class {\n\n    constructor(options) {\n\n        Assert(typeof options === 'object', 'Invalid reference construction');\n        Common.assertOptions(options, [\n            'adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'separator', 'type',    // Copied\n            'depth', 'key', 'root', 'display'                                               // Overridden\n        ]);\n\n        Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');\n        Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');\n        Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');\n        Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');\n\n        Object.assign(this, internals.defaults, options);\n\n        Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');\n\n        if (Array.isArray(this.map)) {\n            this.map = new Map(this.map);\n        }\n\n        this.depth = this.path.length;\n        this.key = this.path.length ? this.path.join(this.separator) : null;\n        this.root = this.path[0];\n\n        this.updateDisplay();\n    }\n\n    resolve(value, state, prefs, local, options = {}) {\n\n        Assert(!this.in || options.in, 'Invalid in() reference usage');\n\n        if (this.type === 'global') {\n            return this._resolve(prefs.context, state, options);\n        }\n\n        if (this.type === 'local') {\n            return this._resolve(local, state, options);\n        }\n\n        if (!this.ancestor) {\n            return this._resolve(value, state, options);\n        }\n\n        if (this.ancestor === 'root') {\n            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);\n        }\n\n        Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);\n        return this._resolve(state.ancestors[this.ancestor - 1], state, options);\n    }\n\n    _resolve(target, state, options) {\n\n        let resolved;\n\n        if (this.type === 'value' &&\n            state.mainstay.shadow &&\n            options.shadow !== false) {\n\n            resolved = state.mainstay.shadow.get(this.absolute(state));\n        }\n\n        if (resolved === undefined) {\n            resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });\n        }\n\n        if (this.adjust) {\n            resolved = this.adjust(resolved);\n        }\n\n        if (this.map) {\n            const mapped = this.map.get(resolved);\n            if (mapped !== undefined) {\n                resolved = mapped;\n            }\n        }\n\n        if (state.mainstay) {\n            state.mainstay.tracer.resolve(state, this, resolved);\n        }\n\n        return resolved;\n    }\n\n    toString() {\n\n        return this.display;\n    }\n\n    absolute(state) {\n\n        return [...state.path.slice(0, -this.ancestor), ...this.path];\n    }\n\n    clone() {\n\n        return new internals.Ref(this);\n    }\n\n    describe() {\n\n        const ref = { path: this.path };\n\n        if (this.type !== 'value') {\n            ref.type = this.type;\n        }\n\n        if (this.separator !== '.') {\n            ref.separator = this.separator;\n        }\n\n        if (this.type === 'value' &&\n            this.ancestor !== 1) {\n\n            ref.ancestor = this.ancestor;\n        }\n\n        if (this.map) {\n            ref.map = [...this.map];\n        }\n\n        for (const key of ['adjust', 'iterables']) {\n            if (this[key] !== null) {\n                ref[key] = this[key];\n            }\n        }\n\n        if (this.in !== false) {\n            ref.in = true;\n        }\n\n        return { ref };\n    }\n\n    updateDisplay() {\n\n        const key = this.key !== null ? this.key : '';\n        if (this.type !== 'value') {\n            this.display = `ref:${this.type}:${key}`;\n            return;\n        }\n\n        if (!this.separator) {\n            this.display = `ref:${key}`;\n            return;\n        }\n\n        if (!this.ancestor) {\n            this.display = `ref:${this.separator}${key}`;\n            return;\n        }\n\n        if (this.ancestor === 'root') {\n            this.display = `ref:root:${key}`;\n            return;\n        }\n\n        if (this.ancestor === 1) {\n            this.display = `ref:${key || '..'}`;\n            return;\n        }\n\n        const lead = new Array(this.ancestor + 1).fill(this.separator).join('');\n        this.display = `ref:${lead}${key || ''}`;\n    }\n};\n\n\ninternals.Ref.prototype[Common.symbols.ref] = true;\n\n\nexports.build = function (desc) {\n\n    desc = Object.assign({}, internals.defaults, desc);\n    if (desc.type === 'value' &&\n        desc.ancestor === undefined) {\n\n        desc.ancestor = 1;\n    }\n\n    return new internals.Ref(desc);\n};\n\n\ninternals.context = function (key, separator, prefix = {}) {\n\n    key = key.trim();\n\n    if (prefix) {\n        const globalp = prefix.global === undefined ? '$' : prefix.global;\n        if (globalp !== separator &&\n            key.startsWith(globalp)) {\n\n            return { key: key.slice(globalp.length), type: 'global' };\n        }\n\n        const local = prefix.local === undefined ? '#' : prefix.local;\n        if (local !== separator &&\n            key.startsWith(local)) {\n\n            return { key: key.slice(local.length), type: 'local' };\n        }\n\n        const root = prefix.root === undefined ? '/' : prefix.root;\n        if (root !== separator &&\n            key.startsWith(root)) {\n\n            return { key: key.slice(root.length), type: 'value', root: true };\n        }\n    }\n\n    return { key, type: 'value' };\n};\n\n\ninternals.ancestor = function (key, separator) {\n\n    if (!separator) {\n        return [1, 0];              // 'a_b' -> 1 (parent)\n    }\n\n    if (key[0] !== separator) {     // 'a.b' -> 1 (parent)\n        return [1, 0];\n    }\n\n    if (key[1] !== separator) {     // '.a.b' -> 0 (self)\n        return [0, 1];\n    }\n\n    let i = 2;\n    while (key[i] === separator) {\n        ++i;\n    }\n\n    return [i - 1, i];              // '...a.b.' -> 2 (grandparent)\n};\n\n\nexports.toSibling = 0;\n\nexports.toParent = 1;\n\n\nexports.Manager = class {\n\n    constructor() {\n\n        this.refs = [];                     // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...\n    }\n\n    register(source, target) {\n\n        if (!source) {\n            return;\n        }\n\n        target = target === undefined ? exports.toParent : target;\n\n        // Array\n\n        if (Array.isArray(source)) {\n            for (const ref of source) {\n                this.register(ref, target);\n            }\n\n            return;\n        }\n\n        // Schema\n\n        if (Common.isSchema(source)) {\n            for (const item of source._refs.refs) {\n                if (item.ancestor - target >= 0) {\n                    this.refs.push({ ancestor: item.ancestor - target, root: item.root });\n                }\n            }\n\n            return;\n        }\n\n        // Reference\n\n        if (exports.isRef(source) &&\n            source.type === 'value' &&\n            source.ancestor - target >= 0) {\n\n            this.refs.push({ ancestor: source.ancestor - target, root: source.root });\n        }\n\n        // Template\n\n        Template = Template || require('./template');\n\n        if (Template.isTemplate(source)) {\n            this.register(source.refs(), target);\n        }\n    }\n\n    get length() {\n\n        return this.refs.length;\n    }\n\n    clone() {\n\n        const copy = new exports.Manager();\n        copy.refs = Clone(this.refs);\n        return copy;\n    }\n\n    reset() {\n\n        this.refs = [];\n    }\n\n    roots() {\n\n        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}