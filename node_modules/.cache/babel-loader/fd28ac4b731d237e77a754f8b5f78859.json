{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Compile = require('../compile');\n\nconst Errors = require('../errors');\n\nconst internals = {};\nmodule.exports = Any.extend({\n  type: 'link',\n  properties: {\n    schemaChain: true\n  },\n  terms: {\n    link: {\n      init: null,\n      manifest: 'single',\n      register: false\n    }\n  },\n\n  args(schema, ref) {\n    return schema.ref(ref);\n  },\n\n  validate(value, _ref) {\n    let {\n      schema,\n      state,\n      prefs\n    } = _ref;\n    Assert(schema.$_terms.link, 'Uninitialized link schema');\n    const linked = internals.generate(schema, value, state, prefs);\n    const ref = schema.$_terms.link[0].ref;\n    return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);\n  },\n\n  generate(schema, value, state, prefs) {\n    return internals.generate(schema, value, state, prefs);\n  },\n\n  rules: {\n    ref: {\n      method(ref) {\n        Assert(!this.$_terms.link, 'Cannot reinitialize schema');\n        ref = Compile.ref(ref);\n        Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);\n        Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');\n        const obj = this.clone();\n        obj.$_terms.link = [{\n          ref\n        }];\n        return obj;\n      }\n\n    },\n    relative: {\n      method() {\n        let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        return this.$_setFlag('relative', enabled);\n      }\n\n    }\n  },\n  overrides: {\n    concat(source) {\n      Assert(this.$_terms.link, 'Uninitialized link schema');\n      Assert(Common.isSchema(source), 'Invalid schema object');\n      Assert(source.type !== 'link', 'Cannot merge type link with another link');\n      const obj = this.clone();\n\n      if (!obj.$_terms.whens) {\n        obj.$_terms.whens = [];\n      }\n\n      obj.$_terms.whens.push({\n        concat: source\n      });\n      return obj.$_mutateRebuild();\n    }\n\n  },\n  manifest: {\n    build(obj, desc) {\n      Assert(desc.link, 'Invalid link description missing link');\n      return obj.ref(desc.link);\n    }\n\n  }\n}); // Helpers\n\ninternals.generate = function (schema, value, state, prefs) {\n  let linked = state.mainstay.links.get(schema);\n\n  if (linked) {\n    return linked._generate(value, state, prefs).schema;\n  }\n\n  const ref = schema.$_terms.link[0].ref;\n  const {\n    perspective,\n    path\n  } = internals.perspective(ref, state);\n  internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);\n\n  try {\n    linked = path.length ? perspective.$_reach(path) : perspective;\n  } catch (ignoreErr) {\n    internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);\n  }\n\n  internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);\n\n  if (!schema._flags.relative) {\n    state.mainstay.links.set(schema, linked);\n  }\n\n  return linked._generate(value, state, prefs).schema;\n};\n\ninternals.perspective = function (ref, state) {\n  if (ref.type === 'local') {\n    for (const {\n      schema,\n      key\n    } of state.schemas) {\n      // From parent to root\n      const id = schema._flags.id || key;\n\n      if (id === ref.path[0]) {\n        return {\n          perspective: schema,\n          path: ref.path.slice(1)\n        };\n      }\n\n      if (schema.$_terms.shared) {\n        for (const shared of schema.$_terms.shared) {\n          if (shared._flags.id === ref.path[0]) {\n            return {\n              perspective: shared,\n              path: ref.path.slice(1)\n            };\n          }\n        }\n      }\n    }\n\n    return {\n      perspective: null,\n      path: null\n    };\n  }\n\n  if (ref.ancestor === 'root') {\n    return {\n      perspective: state.schemas[state.schemas.length - 1].schema,\n      path: ref.path\n    };\n  }\n\n  return {\n    perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema,\n    path: ref.path\n  };\n};\n\ninternals.assert = function (condition, message, ref, schema, state, prefs) {\n  if (condition) {\n    // Manual check to avoid generating error message on success\n    return;\n  }\n\n  Assert(false, `\"${Errors.label(schema._flags, state, prefs)}\" contains link reference \"${ref.display}\" ${message}`);\n};","map":{"version":3,"names":["Assert","require","Any","Common","Compile","Errors","internals","module","exports","extend","type","properties","schemaChain","terms","link","init","manifest","register","args","schema","ref","validate","value","state","prefs","$_terms","linked","generate","$_validate","nest","display","rules","method","ancestor","obj","clone","relative","enabled","$_setFlag","overrides","concat","source","isSchema","whens","push","$_mutateRebuild","build","desc","mainstay","links","get","_generate","perspective","path","assert","length","$_reach","ignoreErr","_flags","set","key","schemas","id","slice","shared","condition","message","label"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/types/link.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Compile = require('../compile');\nconst Errors = require('../errors');\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'link',\n\n    properties: {\n        schemaChain: true\n    },\n\n    terms: {\n\n        link: { init: null, manifest: 'single', register: false }\n    },\n\n    args(schema, ref) {\n\n        return schema.ref(ref);\n    },\n\n    validate(value, { schema, state, prefs }) {\n\n        Assert(schema.$_terms.link, 'Uninitialized link schema');\n\n        const linked = internals.generate(schema, value, state, prefs);\n        const ref = schema.$_terms.link[0].ref;\n        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);\n    },\n\n    generate(schema, value, state, prefs) {\n\n        return internals.generate(schema, value, state, prefs);\n    },\n\n    rules: {\n\n        ref: {\n            method(ref) {\n\n                Assert(!this.$_terms.link, 'Cannot reinitialize schema');\n\n                ref = Compile.ref(ref);\n\n                Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);\n                Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');\n\n                const obj = this.clone();\n                obj.$_terms.link = [{ ref }];\n                return obj;\n            }\n        },\n\n        relative: {\n            method(enabled = true) {\n\n                return this.$_setFlag('relative', enabled);\n            }\n        }\n    },\n\n    overrides: {\n\n        concat(source) {\n\n            Assert(this.$_terms.link, 'Uninitialized link schema');\n            Assert(Common.isSchema(source), 'Invalid schema object');\n            Assert(source.type !== 'link', 'Cannot merge type link with another link');\n\n            const obj = this.clone();\n\n            if (!obj.$_terms.whens) {\n                obj.$_terms.whens = [];\n            }\n\n            obj.$_terms.whens.push({ concat: source });\n            return obj.$_mutateRebuild();\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            Assert(desc.link, 'Invalid link description missing link');\n            return obj.ref(desc.link);\n        }\n    }\n});\n\n\n// Helpers\n\ninternals.generate = function (schema, value, state, prefs) {\n\n    let linked = state.mainstay.links.get(schema);\n    if (linked) {\n        return linked._generate(value, state, prefs).schema;\n    }\n\n    const ref = schema.$_terms.link[0].ref;\n    const { perspective, path } = internals.perspective(ref, state);\n    internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);\n\n    try {\n        linked = path.length ? perspective.$_reach(path) : perspective;\n    }\n    catch (ignoreErr) {\n        internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);\n    }\n\n    internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);\n\n    if (!schema._flags.relative) {\n        state.mainstay.links.set(schema, linked);\n    }\n\n    return linked._generate(value, state, prefs).schema;\n};\n\n\ninternals.perspective = function (ref, state) {\n\n    if (ref.type === 'local') {\n        for (const { schema, key } of state.schemas) {                              // From parent to root\n            const id = schema._flags.id || key;\n            if (id === ref.path[0]) {\n                return { perspective: schema, path: ref.path.slice(1) };\n            }\n\n            if (schema.$_terms.shared) {\n                for (const shared of schema.$_terms.shared) {\n                    if (shared._flags.id === ref.path[0]) {\n                        return { perspective: shared, path: ref.path.slice(1) };\n                    }\n                }\n            }\n        }\n\n        return { perspective: null, path: null };\n    }\n\n    if (ref.ancestor === 'root') {\n        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };\n    }\n\n    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };\n};\n\n\ninternals.assert = function (condition, message, ref, schema, state, prefs) {\n\n    if (condition) {                // Manual check to avoid generating error message on success\n        return;\n    }\n\n    Assert(false, `\"${Errors.label(schema._flags, state, prefs)}\" contains link reference \"${ref.display}\" ${message}`);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}