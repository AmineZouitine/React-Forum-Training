{"ast":null,"code":"'use strict';\n\nconst Reach = require('./reach');\n\nconst Types = require('./types');\n\nconst Utils = require('./utils');\n\nconst internals = {\n  needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n};\n\nmodule.exports = internals.clone = function (obj) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  let _seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  let clone = internals.clone;\n  let seen = _seen;\n\n  if (options.shallow) {\n    if (options.shallow !== true) {\n      return internals.cloneWithShallow(obj, options);\n    }\n\n    clone = value => value;\n  } else if (seen) {\n    const lookup = seen.get(obj);\n\n    if (lookup) {\n      return lookup;\n    }\n  } else {\n    seen = new Map();\n  } // Built-in object types\n\n\n  const baseProto = Types.getInternalProto(obj);\n\n  if (baseProto === Types.buffer) {\n    return Buffer && Buffer.from(obj); // $lab:coverage:ignore$\n  }\n\n  if (baseProto === Types.date) {\n    return new Date(obj.getTime());\n  }\n\n  if (baseProto === Types.regex) {\n    return new RegExp(obj);\n  } // Generic objects\n\n\n  const newObj = internals.base(obj, baseProto, options);\n\n  if (newObj === obj) {\n    return obj;\n  }\n\n  if (seen) {\n    seen.set(obj, newObj); // Set seen, since obj could recurse\n  }\n\n  if (baseProto === Types.set) {\n    for (const value of obj) {\n      newObj.add(clone(value, options, seen));\n    }\n  } else if (baseProto === Types.map) {\n    for (const [key, value] of obj) {\n      newObj.set(key, clone(value, options, seen));\n    }\n  }\n\n  const keys = Utils.keys(obj, options);\n\n  for (const key of keys) {\n    if (key === '__proto__') {\n      continue;\n    }\n\n    if (baseProto === Types.array && key === 'length') {\n      newObj.length = obj.length;\n      continue;\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (descriptor) {\n      if (descriptor.get || descriptor.set) {\n        Object.defineProperty(newObj, key, descriptor);\n      } else if (descriptor.enumerable) {\n        newObj[key] = clone(obj[key], options, seen);\n      } else {\n        Object.defineProperty(newObj, key, {\n          enumerable: false,\n          writable: true,\n          configurable: true,\n          value: clone(obj[key], options, seen)\n        });\n      }\n    } else {\n      Object.defineProperty(newObj, key, {\n        enumerable: true,\n        writable: true,\n        configurable: true,\n        value: clone(obj[key], options, seen)\n      });\n    }\n  }\n\n  return newObj;\n};\n\ninternals.cloneWithShallow = function (source, options) {\n  const keys = options.shallow;\n  options = Object.assign({}, options);\n  options.shallow = false;\n  const seen = new Map();\n\n  for (const key of keys) {\n    const ref = Reach(source, key);\n\n    if (typeof ref === 'object' || typeof ref === 'function') {\n      seen.set(ref, ref);\n    }\n  }\n\n  return internals.clone(source, options, seen);\n};\n\ninternals.base = function (obj, baseProto, options) {\n  if (options.prototype === false) {\n    // Defaults to true\n    if (internals.needsProtoHack.has(baseProto)) {\n      return new baseProto.constructor();\n    }\n\n    return baseProto === Types.array ? [] : {};\n  }\n\n  const proto = Object.getPrototypeOf(obj);\n\n  if (proto && proto.isImmutable) {\n    return obj;\n  }\n\n  if (baseProto === Types.array) {\n    const newObj = [];\n\n    if (proto !== baseProto) {\n      Object.setPrototypeOf(newObj, proto);\n    }\n\n    return newObj;\n  }\n\n  if (internals.needsProtoHack.has(baseProto)) {\n    const newObj = new proto.constructor();\n\n    if (proto !== baseProto) {\n      Object.setPrototypeOf(newObj, proto);\n    }\n\n    return newObj;\n  }\n\n  return Object.create(proto);\n};","map":{"version":3,"names":["Reach","require","Types","Utils","internals","needsProtoHack","Set","set","map","weakSet","weakMap","module","exports","clone","obj","options","_seen","seen","shallow","cloneWithShallow","value","lookup","get","Map","baseProto","getInternalProto","buffer","Buffer","from","date","Date","getTime","regex","RegExp","newObj","base","add","key","keys","array","length","descriptor","Object","getOwnPropertyDescriptor","defineProperty","enumerable","writable","configurable","source","assign","ref","prototype","has","constructor","proto","getPrototypeOf","isImmutable","setPrototypeOf","create"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/hoek/lib/clone.js"],"sourcesContent":["'use strict';\n\nconst Reach = require('./reach');\nconst Types = require('./types');\nconst Utils = require('./utils');\n\n\nconst internals = {\n    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n};\n\n\nmodule.exports = internals.clone = function (obj, options = {}, _seen = null) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    let clone = internals.clone;\n    let seen = _seen;\n\n    if (options.shallow) {\n        if (options.shallow !== true) {\n            return internals.cloneWithShallow(obj, options);\n        }\n\n        clone = (value) => value;\n    }\n    else if (seen) {\n        const lookup = seen.get(obj);\n        if (lookup) {\n            return lookup;\n        }\n    }\n    else {\n        seen = new Map();\n    }\n\n    // Built-in object types\n\n    const baseProto = Types.getInternalProto(obj);\n    if (baseProto === Types.buffer) {\n        return Buffer && Buffer.from(obj);              // $lab:coverage:ignore$\n    }\n\n    if (baseProto === Types.date) {\n        return new Date(obj.getTime());\n    }\n\n    if (baseProto === Types.regex) {\n        return new RegExp(obj);\n    }\n\n    // Generic objects\n\n    const newObj = internals.base(obj, baseProto, options);\n    if (newObj === obj) {\n        return obj;\n    }\n\n    if (seen) {\n        seen.set(obj, newObj);                              // Set seen, since obj could recurse\n    }\n\n    if (baseProto === Types.set) {\n        for (const value of obj) {\n            newObj.add(clone(value, options, seen));\n        }\n    }\n    else if (baseProto === Types.map) {\n        for (const [key, value] of obj) {\n            newObj.set(key, clone(value, options, seen));\n        }\n    }\n\n    const keys = Utils.keys(obj, options);\n    for (const key of keys) {\n        if (key === '__proto__') {\n            continue;\n        }\n\n        if (baseProto === Types.array &&\n            key === 'length') {\n\n            newObj.length = obj.length;\n            continue;\n        }\n\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor) {\n            if (descriptor.get ||\n                descriptor.set) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else if (descriptor.enumerable) {\n                newObj[key] = clone(obj[key], options, seen);\n            }\n            else {\n                Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });\n            }\n        }\n        else {\n            Object.defineProperty(newObj, key, {\n                enumerable: true,\n                writable: true,\n                configurable: true,\n                value: clone(obj[key], options, seen)\n            });\n        }\n    }\n\n    return newObj;\n};\n\n\ninternals.cloneWithShallow = function (source, options) {\n\n    const keys = options.shallow;\n    options = Object.assign({}, options);\n    options.shallow = false;\n\n    const seen = new Map();\n\n    for (const key of keys) {\n        const ref = Reach(source, key);\n        if (typeof ref === 'object' ||\n            typeof ref === 'function') {\n\n            seen.set(ref, ref);\n        }\n    }\n\n    return internals.clone(source, options, seen);\n};\n\n\ninternals.base = function (obj, baseProto, options) {\n\n    if (options.prototype === false) {                  // Defaults to true\n        if (internals.needsProtoHack.has(baseProto)) {\n            return new baseProto.constructor();\n        }\n\n        return baseProto === Types.array ? [] : {};\n    }\n\n    const proto = Object.getPrototypeOf(obj);\n    if (proto &&\n        proto.isImmutable) {\n\n        return obj;\n    }\n\n    if (baseProto === Types.array) {\n        const newObj = [];\n        if (proto !== baseProto) {\n            Object.setPrototypeOf(newObj, proto);\n        }\n\n        return newObj;\n    }\n\n    if (internals.needsProtoHack.has(baseProto)) {\n        const newObj = new proto.constructor();\n        if (proto !== baseProto) {\n            Object.setPrototypeOf(newObj, proto);\n        }\n\n        return newObj;\n    }\n\n    return Object.create(proto);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}