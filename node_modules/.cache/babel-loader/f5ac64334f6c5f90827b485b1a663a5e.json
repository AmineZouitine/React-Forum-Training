{"ast":null,"code":"'use strict';\n\nconst Assert = require('./assert');\n\nconst internals = {};\n\nmodule.exports = function (obj, chain, options) {\n  if (chain === false || chain === null || chain === undefined) {\n    return obj;\n  }\n\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      separator: options\n    };\n  }\n\n  const isChainArray = Array.isArray(chain);\n  Assert(!isChainArray || !options.separator, 'Separator option is not valid for array-based chain');\n  const path = isChainArray ? chain : chain.split(options.separator || '.');\n  let ref = obj;\n\n  for (let i = 0; i < path.length; ++i) {\n    let key = path[i];\n    const type = options.iterables && internals.iterables(ref);\n\n    if (Array.isArray(ref) || type === 'set') {\n      const number = Number(key);\n\n      if (Number.isInteger(number)) {\n        key = number < 0 ? ref.length + number : number;\n      }\n    }\n\n    if (!ref || typeof ref === 'function' && options.functions === false || // Defaults to true\n    !type && ref[key] === undefined) {\n      Assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n      Assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n      ref = options.default;\n      break;\n    }\n\n    if (!type) {\n      ref = ref[key];\n    } else if (type === 'set') {\n      ref = [...ref][key];\n    } else {\n      // type === 'map'\n      ref = ref.get(key);\n    }\n  }\n\n  return ref;\n};\n\ninternals.iterables = function (ref) {\n  if (ref instanceof Set) {\n    return 'set';\n  }\n\n  if (ref instanceof Map) {\n    return 'map';\n  }\n};","map":{"version":3,"names":["Assert","require","internals","module","exports","obj","chain","options","undefined","separator","isChainArray","Array","isArray","path","split","ref","i","length","key","type","iterables","number","Number","isInteger","functions","strict","default","get","Set","Map"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/hoek/lib/reach.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('./assert');\n\n\nconst internals = {};\n\n\nmodule.exports = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        chain === undefined) {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const isChainArray = Array.isArray(chain);\n\n    Assert(!isChainArray || !options.separator, 'Separator option is not valid for array-based chain');\n\n    const path = isChainArray ? chain : chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n        const type = options.iterables && internals.iterables(ref);\n\n        if (Array.isArray(ref) ||\n            type === 'set') {\n\n            const number = Number(key);\n            if (Number.isInteger(number)) {\n                key = number < 0 ? ref.length + number : number;\n            }\n        }\n\n        if (!ref ||\n            typeof ref === 'function' && options.functions === false ||         // Defaults to true\n            !type && ref[key] === undefined) {\n\n            Assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            Assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        if (!type) {\n            ref = ref[key];\n        }\n        else if (type === 'set') {\n            ref = [...ref][key];\n        }\n        else {  // type === 'map'\n            ref = ref.get(key);\n        }\n    }\n\n    return ref;\n};\n\n\ninternals.iterables = function (ref) {\n\n    if (ref instanceof Set) {\n        return 'set';\n    }\n\n    if (ref instanceof Map) {\n        return 'map';\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}