{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Common = require('./common');\n\nconst Ref = require('./ref');\n\nconst internals = {};\n\nexports.schema = function (Joi, config) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Common.assertOptions(options, ['appendPath', 'override']);\n\n  try {\n    return internals.schema(Joi, config, options);\n  } catch (err) {\n    if (options.appendPath && err.path !== undefined) {\n      err.message = `${err.message} (${err.path})`;\n    }\n\n    throw err;\n  }\n};\n\ninternals.schema = function (Joi, config, options) {\n  Assert(config !== undefined, 'Invalid undefined schema');\n\n  if (Array.isArray(config)) {\n    Assert(config.length, 'Invalid empty array schema');\n\n    if (config.length === 1) {\n      config = config[0];\n    }\n  }\n\n  const valid = function (base) {\n    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      values[_key - 1] = arguments[_key];\n    }\n\n    if (options.override !== false) {\n      return base.valid(Joi.override, ...values);\n    }\n\n    return base.valid(...values);\n  };\n\n  if (internals.simple(config)) {\n    return valid(Joi, config);\n  }\n\n  if (typeof config === 'function') {\n    return Joi.custom(config);\n  }\n\n  Assert(typeof config === 'object', 'Invalid schema content:', typeof config);\n\n  if (Common.isResolvable(config)) {\n    return valid(Joi, config);\n  }\n\n  if (Common.isSchema(config)) {\n    return config;\n  }\n\n  if (Array.isArray(config)) {\n    for (const item of config) {\n      if (!internals.simple(item)) {\n        return Joi.alternatives().try(...config);\n      }\n    }\n\n    return valid(Joi, ...config);\n  }\n\n  if (config instanceof RegExp) {\n    return Joi.string().regex(config);\n  }\n\n  if (config instanceof Date) {\n    return valid(Joi.date(), config);\n  }\n\n  Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n  return Joi.object().keys(config);\n};\n\nexports.ref = function (id, options) {\n  return Ref.isRef(id) ? id : Ref.create(id, options);\n};\n\nexports.compile = function (root, schema) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Common.assertOptions(options, ['legacy']); // Compiled by any supported version\n\n  const any = schema && schema[Common.symbols.any];\n\n  if (any) {\n    Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas:', any.version, Common.version);\n    return schema;\n  } // Uncompiled root\n\n\n  if (typeof schema !== 'object' || !options.legacy) {\n    return exports.schema(root, schema, {\n      appendPath: true\n    }); // Will error if schema contains other versions\n  } // Scan schema for compiled parts\n\n\n  const compiler = internals.walk(schema);\n\n  if (!compiler) {\n    return exports.schema(root, schema, {\n      appendPath: true\n    });\n  }\n\n  return compiler.compile(compiler.root, schema);\n};\n\ninternals.walk = function (schema) {\n  if (typeof schema !== 'object') {\n    return null;\n  }\n\n  if (Array.isArray(schema)) {\n    for (const item of schema) {\n      const compiler = internals.walk(item);\n\n      if (compiler) {\n        return compiler;\n      }\n    }\n\n    return null;\n  }\n\n  const any = schema[Common.symbols.any];\n\n  if (any) {\n    return {\n      root: schema[any.root],\n      compile: any.compile\n    };\n  }\n\n  Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n  for (const key in schema) {\n    const compiler = internals.walk(schema[key]);\n\n    if (compiler) {\n      return compiler;\n    }\n  }\n\n  return null;\n};\n\ninternals.simple = function (value) {\n  return value === null || ['boolean', 'string', 'number'].includes(typeof value);\n};\n\nexports.when = function (schema, condition, options) {\n  if (options === undefined) {\n    Assert(condition && typeof condition === 'object', 'Missing options');\n    options = condition;\n    condition = Ref.create('.');\n  }\n\n  if (Array.isArray(options)) {\n    options = {\n      switch: options\n    };\n  }\n\n  Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']); // Schema condition\n\n  if (Common.isSchema(condition)) {\n    Assert(options.is === undefined, '\"is\" can not be used with a schema condition');\n    Assert(options.not === undefined, '\"not\" can not be used with a schema condition');\n    Assert(options.switch === undefined, '\"switch\" can not be used with a schema condition');\n    return internals.condition(schema, {\n      is: condition,\n      then: options.then,\n      otherwise: options.otherwise,\n      break: options.break\n    });\n  } // Single condition\n\n\n  Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);\n  Assert(options.not === undefined || options.is === undefined, 'Cannot combine \"is\" with \"not\"');\n\n  if (options.switch === undefined) {\n    let rule = options;\n\n    if (options.not !== undefined) {\n      rule = {\n        is: options.not,\n        then: options.otherwise,\n        otherwise: options.then,\n        break: options.break\n      };\n    }\n\n    let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();\n    Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of \"then\", \"otherwise\", or \"switch\"');\n    Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');\n\n    if (options.is !== undefined && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {\n      is = is.required(); // Only apply required if this wasn't already a schema or a ref\n    }\n\n    return internals.condition(schema, {\n      ref: exports.ref(condition),\n      is,\n      then: rule.then,\n      otherwise: rule.otherwise,\n      break: rule.break\n    });\n  } // Switch statement\n\n\n  Assert(Array.isArray(options.switch), '\"switch\" must be an array');\n  Assert(options.is === undefined, 'Cannot combine \"switch\" with \"is\"');\n  Assert(options.not === undefined, 'Cannot combine \"switch\" with \"not\"');\n  Assert(options.then === undefined, 'Cannot combine \"switch\" with \"then\"');\n  const rule = {\n    ref: exports.ref(condition),\n    switch: [],\n    break: options.break\n  };\n\n  for (let i = 0; i < options.switch.length; ++i) {\n    const test = options.switch[i];\n    const last = i === options.switch.length - 1;\n    Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);\n    Assert(test.is !== undefined, 'Switch statement missing \"is\"');\n    Assert(test.then !== undefined, 'Switch statement missing \"then\"');\n    const item = {\n      is: schema.$_compile(test.is),\n      then: schema.$_compile(test.then)\n    };\n\n    if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {\n      item.is = item.is.required(); // Only apply required if this wasn't already a schema or a ref\n    }\n\n    if (last) {\n      Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify \"otherwise\" inside and outside a \"switch\"');\n      const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;\n\n      if (otherwise !== undefined) {\n        Assert(rule.break === undefined, 'Cannot specify both otherwise and break');\n        item.otherwise = schema.$_compile(otherwise);\n      }\n    }\n\n    rule.switch.push(item);\n  }\n\n  return rule;\n};\n\ninternals.condition = function (schema, condition) {\n  for (const key of ['then', 'otherwise']) {\n    if (condition[key] === undefined) {\n      delete condition[key];\n    } else {\n      condition[key] = schema.$_compile(condition[key]);\n    }\n  }\n\n  return condition;\n};","map":{"version":3,"names":["Assert","require","Common","Ref","internals","exports","schema","Joi","config","options","assertOptions","err","appendPath","path","undefined","message","Array","isArray","length","valid","base","values","override","simple","custom","isResolvable","isSchema","item","alternatives","try","RegExp","string","regex","Date","date","Object","getPrototypeOf","object","keys","ref","id","isRef","create","compile","root","any","symbols","legacy","version","compiler","walk","key","value","includes","when","condition","switch","is","not","then","otherwise","break","rule","$_compile","$_root","invalid","required","i","test","last","push"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/compile.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Common = require('./common');\nconst Ref = require('./ref');\n\n\nconst internals = {};\n\n\nexports.schema = function (Joi, config, options = {}) {\n\n    Common.assertOptions(options, ['appendPath', 'override']);\n\n    try {\n        return internals.schema(Joi, config, options);\n    }\n    catch (err) {\n        if (options.appendPath &&\n            err.path !== undefined) {\n\n            err.message = `${err.message} (${err.path})`;\n        }\n\n        throw err;\n    }\n};\n\n\ninternals.schema = function (Joi, config, options) {\n\n    Assert(config !== undefined, 'Invalid undefined schema');\n\n    if (Array.isArray(config)) {\n        Assert(config.length, 'Invalid empty array schema');\n\n        if (config.length === 1) {\n            config = config[0];\n        }\n    }\n\n    const valid = (base, ...values) => {\n\n        if (options.override !== false) {\n            return base.valid(Joi.override, ...values);\n        }\n\n        return base.valid(...values);\n    };\n\n    if (internals.simple(config)) {\n        return valid(Joi, config);\n    }\n\n    if (typeof config === 'function') {\n        return Joi.custom(config);\n    }\n\n    Assert(typeof config === 'object', 'Invalid schema content:', typeof config);\n\n    if (Common.isResolvable(config)) {\n        return valid(Joi, config);\n    }\n\n    if (Common.isSchema(config)) {\n        return config;\n    }\n\n    if (Array.isArray(config)) {\n        for (const item of config) {\n            if (!internals.simple(item)) {\n                return Joi.alternatives().try(...config);\n            }\n        }\n\n        return valid(Joi, ...config);\n    }\n\n    if (config instanceof RegExp) {\n        return Joi.string().regex(config);\n    }\n\n    if (config instanceof Date) {\n        return valid(Joi.date(), config);\n    }\n\n    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n    return Joi.object().keys(config);\n};\n\n\nexports.ref = function (id, options) {\n\n    return Ref.isRef(id) ? id : Ref.create(id, options);\n};\n\n\nexports.compile = function (root, schema, options = {}) {\n\n    Common.assertOptions(options, ['legacy']);\n\n    // Compiled by any supported version\n\n    const any = schema && schema[Common.symbols.any];\n    if (any) {\n        Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas:', any.version, Common.version);\n        return schema;\n    }\n\n    // Uncompiled root\n\n    if (typeof schema !== 'object' ||\n        !options.legacy) {\n\n        return exports.schema(root, schema, { appendPath: true });          // Will error if schema contains other versions\n    }\n\n    // Scan schema for compiled parts\n\n    const compiler = internals.walk(schema);\n    if (!compiler) {\n        return exports.schema(root, schema, { appendPath: true });\n    }\n\n    return compiler.compile(compiler.root, schema);\n};\n\n\ninternals.walk = function (schema) {\n\n    if (typeof schema !== 'object') {\n        return null;\n    }\n\n    if (Array.isArray(schema)) {\n        for (const item of schema) {\n            const compiler = internals.walk(item);\n            if (compiler) {\n                return compiler;\n            }\n        }\n\n        return null;\n    }\n\n    const any = schema[Common.symbols.any];\n    if (any) {\n        return { root: schema[any.root], compile: any.compile };\n    }\n\n    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n    for (const key in schema) {\n        const compiler = internals.walk(schema[key]);\n        if (compiler) {\n            return compiler;\n        }\n    }\n\n    return null;\n};\n\n\ninternals.simple = function (value) {\n\n    return value === null || ['boolean', 'string', 'number'].includes(typeof value);\n};\n\n\nexports.when = function (schema, condition, options) {\n\n    if (options === undefined) {\n        Assert(condition && typeof condition === 'object', 'Missing options');\n\n        options = condition;\n        condition = Ref.create('.');\n    }\n\n    if (Array.isArray(options)) {\n        options = { switch: options };\n    }\n\n    Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']);\n\n    // Schema condition\n\n    if (Common.isSchema(condition)) {\n        Assert(options.is === undefined, '\"is\" can not be used with a schema condition');\n        Assert(options.not === undefined, '\"not\" can not be used with a schema condition');\n        Assert(options.switch === undefined, '\"switch\" can not be used with a schema condition');\n\n        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });\n    }\n\n    // Single condition\n\n    Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);\n    Assert(options.not === undefined || options.is === undefined, 'Cannot combine \"is\" with \"not\"');\n\n    if (options.switch === undefined) {\n        let rule = options;\n        if (options.not !== undefined) {\n            rule = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };\n        }\n\n        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();\n        Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of \"then\", \"otherwise\", or \"switch\"');\n        Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');\n\n        if (options.is !== undefined &&\n            !Ref.isRef(options.is) &&\n            !Common.isSchema(options.is)) {\n\n            is = is.required();                     // Only apply required if this wasn't already a schema or a ref\n        }\n\n        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule.then, otherwise: rule.otherwise, break: rule.break });\n    }\n\n    // Switch statement\n\n    Assert(Array.isArray(options.switch), '\"switch\" must be an array');\n    Assert(options.is === undefined, 'Cannot combine \"switch\" with \"is\"');\n    Assert(options.not === undefined, 'Cannot combine \"switch\" with \"not\"');\n    Assert(options.then === undefined, 'Cannot combine \"switch\" with \"then\"');\n\n    const rule = {\n        ref: exports.ref(condition),\n        switch: [],\n        break: options.break\n    };\n\n    for (let i = 0; i < options.switch.length; ++i) {\n        const test = options.switch[i];\n        const last = i === options.switch.length - 1;\n\n        Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);\n\n        Assert(test.is !== undefined, 'Switch statement missing \"is\"');\n        Assert(test.then !== undefined, 'Switch statement missing \"then\"');\n\n        const item = {\n            is: schema.$_compile(test.is),\n            then: schema.$_compile(test.then)\n        };\n\n        if (!Ref.isRef(test.is) &&\n            !Common.isSchema(test.is)) {\n\n            item.is = item.is.required();           // Only apply required if this wasn't already a schema or a ref\n        }\n\n        if (last) {\n            Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify \"otherwise\" inside and outside a \"switch\"');\n            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;\n            if (otherwise !== undefined) {\n                Assert(rule.break === undefined, 'Cannot specify both otherwise and break');\n                item.otherwise = schema.$_compile(otherwise);\n            }\n        }\n\n        rule.switch.push(item);\n    }\n\n    return rule;\n};\n\n\ninternals.condition = function (schema, condition) {\n\n    for (const key of ['then', 'otherwise']) {\n        if (condition[key] === undefined) {\n            delete condition[key];\n        }\n        else {\n            condition[key] = schema.$_compile(condition[key]);\n        }\n    }\n\n    return condition;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}