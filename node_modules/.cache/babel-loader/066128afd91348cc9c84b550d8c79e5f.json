{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\n\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Compile = require('../compile');\n\nconst internals = {};\nmodule.exports = Any.extend({\n  type: 'array',\n  flags: {\n    single: {\n      default: false\n    },\n    sparse: {\n      default: false\n    }\n  },\n  terms: {\n    items: {\n      init: [],\n      manifest: 'schema'\n    },\n    ordered: {\n      init: [],\n      manifest: 'schema'\n    },\n    _exclusions: {\n      init: []\n    },\n    _inclusions: {\n      init: []\n    },\n    _requireds: {\n      init: []\n    }\n  },\n  coerce: {\n    from: 'object',\n\n    method(value, _ref) {\n      let {\n        schema,\n        state,\n        prefs\n      } = _ref;\n\n      if (!Array.isArray(value)) {\n        return;\n      }\n\n      const sort = schema.$_getRule('sort');\n\n      if (!sort) {\n        return;\n      }\n\n      return internals.sort(schema, value, sort.args.options, state, prefs);\n    }\n\n  },\n\n  validate(value, _ref2) {\n    let {\n      schema,\n      error\n    } = _ref2;\n\n    if (!Array.isArray(value)) {\n      if (schema._flags.single) {\n        const single = [value];\n        single[Common.symbols.arraySingle] = true;\n        return {\n          value: single\n        };\n      }\n\n      return {\n        errors: error('array.base')\n      };\n    }\n\n    if (!schema.$_getRule('items') && !schema.$_terms.externals) {\n      return;\n    }\n\n    return {\n      value: value.slice()\n    }; // Clone the array so that we don't modify the original\n  },\n\n  rules: {\n    has: {\n      method(schema) {\n        schema = this.$_compile(schema, {\n          appendPath: true\n        });\n        const obj = this.$_addRule({\n          name: 'has',\n          args: {\n            schema\n          }\n        });\n        obj.$_mutateRegister(schema);\n        return obj;\n      },\n\n      validate(value, _ref3, _ref4) {\n        let {\n          state,\n          prefs,\n          error\n        } = _ref3;\n        let {\n          schema: has\n        } = _ref4;\n        const ancestors = [value, ...state.ancestors];\n\n        for (let i = 0; i < value.length; ++i) {\n          const localState = state.localize([...state.path, i], ancestors, has);\n\n          if (has.$_match(value[i], localState, prefs)) {\n            return value;\n          }\n        }\n\n        const patternLabel = has._flags.label;\n\n        if (patternLabel) {\n          return error('array.hasKnown', {\n            patternLabel\n          });\n        }\n\n        return error('array.hasUnknown', null);\n      },\n\n      multi: true\n    },\n    items: {\n      method() {\n        for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n          schemas[_key] = arguments[_key];\n        }\n\n        Common.verifyFlat(schemas, 'items');\n        const obj = this.$_addRule('items');\n\n        for (let i = 0; i < schemas.length; ++i) {\n          const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, {\n            append: true\n          });\n          obj.$_terms.items.push(type);\n        }\n\n        return obj.$_mutateRebuild();\n      },\n\n      validate(value, _ref5) {\n        let {\n          schema,\n          error,\n          state,\n          prefs\n        } = _ref5;\n\n        const requireds = schema.$_terms._requireds.slice();\n\n        const ordereds = schema.$_terms.ordered.slice();\n        const inclusions = [...schema.$_terms._inclusions, ...requireds];\n        const wasArray = !value[Common.symbols.arraySingle];\n        delete value[Common.symbols.arraySingle];\n        const errors = [];\n        let il = value.length;\n\n        for (let i = 0; i < il; ++i) {\n          const item = value[i];\n          let errored = false;\n          let isValid = false;\n          const key = wasArray ? i : new Number(i); // eslint-disable-line no-new-wrappers\n\n          const path = [...state.path, key]; // Sparse\n\n          if (!schema._flags.sparse && item === undefined) {\n            errors.push(error('array.sparse', {\n              key,\n              path,\n              pos: i,\n              value: undefined\n            }, state.localize(path)));\n\n            if (prefs.abortEarly) {\n              return errors;\n            }\n\n            ordereds.shift();\n            continue;\n          } // Exclusions\n\n\n          const ancestors = [value, ...state.ancestors];\n\n          for (const exclusion of schema.$_terms._exclusions) {\n            if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, {\n              presence: 'ignore'\n            })) {\n              continue;\n            }\n\n            errors.push(error('array.excludes', {\n              pos: i,\n              value: item\n            }, state.localize(path)));\n\n            if (prefs.abortEarly) {\n              return errors;\n            }\n\n            errored = true;\n            ordereds.shift();\n            break;\n          }\n\n          if (errored) {\n            continue;\n          } // Ordered\n\n\n          if (schema.$_terms.ordered.length) {\n            if (ordereds.length) {\n              const ordered = ordereds.shift();\n              const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);\n\n              if (!res.errors) {\n                if (ordered._flags.result === 'strip') {\n                  internals.fastSplice(value, i);\n                  --i;\n                  --il;\n                } else if (!schema._flags.sparse && res.value === undefined) {\n                  errors.push(error('array.sparse', {\n                    key,\n                    path,\n                    pos: i,\n                    value: undefined\n                  }, state.localize(path)));\n\n                  if (prefs.abortEarly) {\n                    return errors;\n                  }\n\n                  continue;\n                } else {\n                  value[i] = res.value;\n                }\n              } else {\n                errors.push(...res.errors);\n\n                if (prefs.abortEarly) {\n                  return errors;\n                }\n              }\n\n              continue;\n            } else if (!schema.$_terms.items.length) {\n              errors.push(error('array.orderedLength', {\n                pos: i,\n                limit: schema.$_terms.ordered.length\n              }));\n\n              if (prefs.abortEarly) {\n                return errors;\n              }\n\n              break; // No reason to continue since there are no other rules to validate other than array.orderedLength\n            }\n          } // Requireds\n\n\n          const requiredChecks = [];\n          let jl = requireds.length;\n\n          for (let j = 0; j < jl; ++j) {\n            const localState = state.localize(path, ancestors, requireds[j]);\n            localState.snapshot();\n            const res = requireds[j].$_validate(item, localState, prefs);\n            requiredChecks[j] = res;\n\n            if (!res.errors) {\n              value[i] = res.value;\n              isValid = true;\n              internals.fastSplice(requireds, j);\n              --j;\n              --jl;\n\n              if (!schema._flags.sparse && res.value === undefined) {\n                errors.push(error('array.sparse', {\n                  key,\n                  path,\n                  pos: i,\n                  value: undefined\n                }, state.localize(path)));\n\n                if (prefs.abortEarly) {\n                  return errors;\n                }\n              }\n\n              break;\n            }\n\n            localState.restore();\n          }\n\n          if (isValid) {\n            continue;\n          } // Inclusions\n\n\n          const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;\n          jl = inclusions.length;\n\n          for (const inclusion of inclusions) {\n            // Avoid re-running requireds that already didn't match in the previous loop\n            let res;\n            const previousCheck = requireds.indexOf(inclusion);\n\n            if (previousCheck !== -1) {\n              res = requiredChecks[previousCheck];\n            } else {\n              const localState = state.localize(path, ancestors, inclusion);\n              localState.snapshot();\n              res = inclusion.$_validate(item, localState, prefs);\n\n              if (!res.errors) {\n                if (inclusion._flags.result === 'strip') {\n                  internals.fastSplice(value, i);\n                  --i;\n                  --il;\n                } else if (!schema._flags.sparse && res.value === undefined) {\n                  errors.push(error('array.sparse', {\n                    key,\n                    path,\n                    pos: i,\n                    value: undefined\n                  }, state.localize(path)));\n                  errored = true;\n                } else {\n                  value[i] = res.value;\n                }\n\n                isValid = true;\n                break;\n              }\n\n              localState.restore();\n            } // Return the actual error if only one inclusion defined\n\n\n            if (jl === 1) {\n              if (stripUnknown) {\n                internals.fastSplice(value, i);\n                --i;\n                --il;\n                isValid = true;\n                break;\n              }\n\n              errors.push(...res.errors);\n\n              if (prefs.abortEarly) {\n                return errors;\n              }\n\n              errored = true;\n              break;\n            }\n          }\n\n          if (errored) {\n            continue;\n          }\n\n          if (schema.$_terms._inclusions.length && !isValid) {\n            if (stripUnknown) {\n              internals.fastSplice(value, i);\n              --i;\n              --il;\n              continue;\n            }\n\n            errors.push(error('array.includes', {\n              pos: i,\n              value: item\n            }, state.localize(path)));\n\n            if (prefs.abortEarly) {\n              return errors;\n            }\n          }\n        }\n\n        if (requireds.length) {\n          internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);\n        }\n\n        if (ordereds.length) {\n          internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);\n        }\n\n        return errors.length ? errors : value;\n      },\n\n      priority: true,\n      manifest: false\n    },\n    length: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'length',\n          args: {\n            limit\n          },\n          operator: '='\n        });\n      },\n\n      validate(value, helpers, _ref6, _ref7) {\n        let {\n          limit\n        } = _ref6;\n        let {\n          name,\n          operator,\n          args\n        } = _ref7;\n\n        if (Common.compare(value.length, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('array.' + name, {\n          limit: args.limit,\n          value\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.limit,\n        message: 'must be a positive integer'\n      }]\n    },\n    max: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'max',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '<='\n        });\n      }\n\n    },\n    min: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'min',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '>='\n        });\n      }\n\n    },\n    ordered: {\n      method() {\n        for (var _len2 = arguments.length, schemas = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          schemas[_key2] = arguments[_key2];\n        }\n\n        Common.verifyFlat(schemas, 'ordered');\n        const obj = this.$_addRule('items');\n\n        for (let i = 0; i < schemas.length; ++i) {\n          const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, {\n            append: true\n          });\n          internals.validateSingle(type, obj);\n          obj.$_mutateRegister(type);\n          obj.$_terms.ordered.push(type);\n        }\n\n        return obj.$_mutateRebuild();\n      }\n\n    },\n    single: {\n      method(enabled) {\n        const value = enabled === undefined ? true : !!enabled;\n        Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');\n        return this.$_setFlag('single', value);\n      }\n\n    },\n    sort: {\n      method() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        Common.assertOptions(options, ['by', 'order']);\n        const settings = {\n          order: options.order || 'ascending'\n        };\n\n        if (options.by) {\n          settings.by = Compile.ref(options.by, {\n            ancestor: 0\n          });\n          Assert(!settings.by.ancestor, 'Cannot sort by ancestor');\n        }\n\n        return this.$_addRule({\n          name: 'sort',\n          args: {\n            options: settings\n          }\n        });\n      },\n\n      validate(value, _ref8, _ref9) {\n        let {\n          error,\n          state,\n          prefs,\n          schema\n        } = _ref8;\n        let {\n          options\n        } = _ref9;\n        const {\n          value: sorted,\n          errors\n        } = internals.sort(schema, value, options, state, prefs);\n\n        if (errors) {\n          return errors;\n        }\n\n        for (let i = 0; i < value.length; ++i) {\n          if (value[i] !== sorted[i]) {\n            return error('array.sort', {\n              order: options.order,\n              by: options.by ? options.by.key : 'value'\n            });\n          }\n        }\n\n        return value;\n      },\n\n      convert: true\n    },\n    sparse: {\n      method(enabled) {\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.sparse === value) {\n          return this;\n        }\n\n        const obj = value ? this.clone() : this.$_addRule('items');\n        return obj.$_setFlag('sparse', value, {\n          clone: false\n        });\n      }\n\n    },\n    unique: {\n      method(comparator) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n        Common.assertOptions(options, ['ignoreUndefined', 'separator']);\n        const rule = {\n          name: 'unique',\n          args: {\n            options,\n            comparator\n          }\n        };\n\n        if (comparator) {\n          if (typeof comparator === 'string') {\n            const separator = Common.default(options.separator, '.');\n            rule.path = separator ? comparator.split(separator) : [comparator];\n          } else {\n            rule.comparator = comparator;\n          }\n        }\n\n        return this.$_addRule(rule);\n      },\n\n      validate(value, _ref10, _ref11, _ref12) {\n        let {\n          state,\n          error,\n          schema\n        } = _ref10;\n        let {\n          comparator: raw,\n          options\n        } = _ref11;\n        let {\n          comparator,\n          path\n        } = _ref12;\n        const found = {\n          string: Object.create(null),\n          number: Object.create(null),\n          undefined: Object.create(null),\n          boolean: Object.create(null),\n          object: new Map(),\n          function: new Map(),\n          custom: new Map()\n        };\n        const compare = comparator || DeepEqual;\n        const ignoreUndefined = options.ignoreUndefined;\n\n        for (let i = 0; i < value.length; ++i) {\n          const item = path ? Reach(value[i], path) : value[i];\n          const records = comparator ? found.custom : found[typeof item];\n          Assert(records, 'Failed to find unique map container for type', typeof item);\n\n          if (records instanceof Map) {\n            const entries = records.entries();\n            let current;\n\n            while (!(current = entries.next()).done) {\n              if (compare(current.value[0], item)) {\n                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                const context = {\n                  pos: i,\n                  value: value[i],\n                  dupePos: current.value[1],\n                  dupeValue: value[current.value[1]]\n                };\n\n                if (path) {\n                  context.path = raw;\n                }\n\n                return error('array.unique', context, localState);\n              }\n            }\n\n            records.set(item, i);\n          } else {\n            if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n              const context = {\n                pos: i,\n                value: value[i],\n                dupePos: records[item],\n                dupeValue: value[records[item]]\n              };\n\n              if (path) {\n                context.path = raw;\n              }\n\n              const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n              return error('array.unique', context, localState);\n            }\n\n            records[item] = i;\n          }\n        }\n\n        return value;\n      },\n\n      args: ['comparator', 'options'],\n      multi: true\n    }\n  },\n  cast: {\n    set: {\n      from: Array.isArray,\n\n      to(value, helpers) {\n        return new Set(value);\n      }\n\n    }\n  },\n\n  rebuild(schema) {\n    schema.$_terms._inclusions = [];\n    schema.$_terms._exclusions = [];\n    schema.$_terms._requireds = [];\n\n    for (const type of schema.$_terms.items) {\n      internals.validateSingle(type, schema);\n\n      if (type._flags.presence === 'required') {\n        schema.$_terms._requireds.push(type);\n      } else if (type._flags.presence === 'forbidden') {\n        schema.$_terms._exclusions.push(type);\n      } else {\n        schema.$_terms._inclusions.push(type);\n      }\n    }\n\n    for (const type of schema.$_terms.ordered) {\n      internals.validateSingle(type, schema);\n    }\n  },\n\n  manifest: {\n    build(obj, desc) {\n      if (desc.items) {\n        obj = obj.items(...desc.items);\n      }\n\n      if (desc.ordered) {\n        obj = obj.ordered(...desc.ordered);\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'array.base': '{{#label}} must be an array',\n    'array.excludes': '{{#label}} contains an excluded value',\n    'array.hasKnown': '{{#label}} does not contain at least one required match for type \"{#patternLabel}\"',\n    'array.hasUnknown': '{{#label}} does not contain at least one required match',\n    'array.includes': '{{#label}} does not match any of the allowed types',\n    'array.includesRequiredBoth': '{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',\n    'array.includesRequiredKnowns': '{{#label}} does not contain {{#knownMisses}}',\n    'array.includesRequiredUnknowns': '{{#label}} does not contain {{#unknownMisses}} required value(s)',\n    'array.length': '{{#label}} must contain {{#limit}} items',\n    'array.max': '{{#label}} must contain less than or equal to {{#limit}} items',\n    'array.min': '{{#label}} must contain at least {{#limit}} items',\n    'array.orderedLength': '{{#label}} must contain at most {{#limit}} items',\n    'array.sort': '{{#label}} must be sorted in {#order} order by {{#by}}',\n    'array.sort.mismatching': '{{#label}} cannot be sorted due to mismatching types',\n    'array.sort.unsupported': '{{#label}} cannot be sorted due to unsupported type {#type}',\n    'array.sparse': '{{#label}} must not be a sparse array item',\n    'array.unique': '{{#label}} contains a duplicate value'\n  }\n}); // Helpers\n\ninternals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {\n  const knownMisses = [];\n  let unknownMisses = 0;\n\n  for (const required of requireds) {\n    const label = required._flags.label;\n\n    if (label) {\n      knownMisses.push(label);\n    } else {\n      ++unknownMisses;\n    }\n  }\n\n  if (knownMisses.length) {\n    if (unknownMisses) {\n      errors.push(schema.$_createError('array.includesRequiredBoth', value, {\n        knownMisses,\n        unknownMisses\n      }, state, prefs));\n    } else {\n      errors.push(schema.$_createError('array.includesRequiredKnowns', value, {\n        knownMisses\n      }, state, prefs));\n    }\n  } else {\n    errors.push(schema.$_createError('array.includesRequiredUnknowns', value, {\n      unknownMisses\n    }, state, prefs));\n  }\n};\n\ninternals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {\n  const requiredOrdereds = [];\n\n  for (const ordered of ordereds) {\n    if (ordered._flags.presence === 'required') {\n      requiredOrdereds.push(ordered);\n    }\n  }\n\n  if (requiredOrdereds.length) {\n    internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);\n  }\n};\n\ninternals.fastSplice = function (arr, i) {\n  let pos = i;\n\n  while (pos < arr.length) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.validateSingle = function (type, obj) {\n  if (type.type === 'array' || type._flags._arrayItems) {\n    Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');\n    obj.$_setFlag('_arrayItems', true, {\n      clone: false\n    });\n  }\n};\n\ninternals.sort = function (schema, value, settings, state, prefs) {\n  const order = settings.order === 'ascending' ? 1 : -1;\n  const aFirst = -1 * order;\n  const bFirst = order;\n\n  const sort = (a, b) => {\n    let compare = internals.compare(a, b, aFirst, bFirst);\n\n    if (compare !== null) {\n      return compare;\n    }\n\n    if (settings.by) {\n      a = settings.by.resolve(a, state, prefs);\n      b = settings.by.resolve(b, state, prefs);\n    }\n\n    compare = internals.compare(a, b, aFirst, bFirst);\n\n    if (compare !== null) {\n      return compare;\n    }\n\n    const type = typeof a;\n\n    if (type !== typeof b) {\n      throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);\n    }\n\n    if (type !== 'number' && type !== 'string') {\n      throw schema.$_createError('array.sort.unsupported', value, {\n        type\n      }, state, prefs);\n    }\n\n    if (type === 'number') {\n      return (a - b) * order;\n    }\n\n    return a < b ? aFirst : bFirst;\n  };\n\n  try {\n    return {\n      value: value.slice().sort(sort)\n    };\n  } catch (err) {\n    return {\n      errors: err\n    };\n  }\n};\n\ninternals.compare = function (a, b, aFirst, bFirst) {\n  if (a === b) {\n    return 0;\n  }\n\n  if (a === undefined) {\n    return 1; // Always last regardless of sort order\n  }\n\n  if (b === undefined) {\n    return -1; // Always last regardless of sort order\n  }\n\n  if (a === null) {\n    return bFirst;\n  }\n\n  if (b === null) {\n    return aFirst;\n  }\n\n  return null;\n};","map":{"version":3,"names":["Assert","require","DeepEqual","Reach","Any","Common","Compile","internals","module","exports","extend","type","flags","single","default","sparse","terms","items","init","manifest","ordered","_exclusions","_inclusions","_requireds","coerce","from","method","value","schema","state","prefs","Array","isArray","sort","$_getRule","args","options","validate","error","_flags","symbols","arraySingle","errors","$_terms","externals","slice","rules","has","$_compile","appendPath","obj","$_addRule","name","$_mutateRegister","ancestors","i","length","localState","localize","path","$_match","patternLabel","label","multi","schemas","verifyFlat","tryWithPath","append","push","$_mutateRebuild","requireds","ordereds","inclusions","wasArray","il","item","errored","isValid","key","Number","undefined","pos","abortEarly","shift","exclusion","presence","res","$_validate","result","fastSplice","limit","requiredChecks","jl","j","snapshot","restore","stripUnknown","arrays","inclusion","previousCheck","indexOf","fillMissedErrors","fillOrderedErrors","priority","operator","helpers","compare","ref","assert","message","max","min","validateSingle","enabled","_arrayItems","$_setFlag","assertOptions","settings","order","by","ancestor","sorted","convert","clone","unique","comparator","rule","separator","split","raw","found","string","Object","create","number","boolean","object","Map","function","custom","ignoreUndefined","records","entries","current","next","done","context","dupePos","dupeValue","set","cast","to","Set","rebuild","build","desc","messages","knownMisses","unknownMisses","required","$_createError","requiredOrdereds","arr","aFirst","bFirst","a","b","resolve","err"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/types/array.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Compile = require('../compile');\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'array',\n\n    flags: {\n\n        single: { default: false },\n        sparse: { default: false }\n    },\n\n    terms: {\n\n        items: { init: [], manifest: 'schema' },\n        ordered: { init: [], manifest: 'schema' },\n\n        _exclusions: { init: [] },\n        _inclusions: { init: [] },\n        _requireds: { init: [] }\n    },\n\n    coerce: {\n        from: 'object',\n        method(value, { schema, state, prefs }) {\n\n            if (!Array.isArray(value)) {\n                return;\n            }\n\n            const sort = schema.$_getRule('sort');\n            if (!sort) {\n                return;\n            }\n\n            return internals.sort(schema, value, sort.args.options, state, prefs);\n        }\n    },\n\n    validate(value, { schema, error }) {\n\n        if (!Array.isArray(value)) {\n            if (schema._flags.single) {\n                const single = [value];\n                single[Common.symbols.arraySingle] = true;\n                return { value: single };\n            }\n\n            return { errors: error('array.base') };\n        }\n\n        if (!schema.$_getRule('items') &&\n            !schema.$_terms.externals) {\n\n            return;\n        }\n\n        return { value: value.slice() };        // Clone the array so that we don't modify the original\n    },\n\n    rules: {\n\n        has: {\n            method(schema) {\n\n                schema = this.$_compile(schema, { appendPath: true });\n                const obj = this.$_addRule({ name: 'has', args: { schema } });\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate(value, { state, prefs, error }, { schema: has }) {\n\n                const ancestors = [value, ...state.ancestors];\n                for (let i = 0; i < value.length; ++i) {\n                    const localState = state.localize([...state.path, i], ancestors, has);\n                    if (has.$_match(value[i], localState, prefs)) {\n                        return value;\n                    }\n                }\n\n                const patternLabel = has._flags.label;\n                if (patternLabel) {\n                    return error('array.hasKnown', { patternLabel });\n                }\n\n                return error('array.hasUnknown', null);\n            },\n            multi: true\n        },\n\n        items: {\n            method(...schemas) {\n\n                Common.verifyFlat(schemas, 'items');\n\n                const obj = this.$_addRule('items');\n\n                for (let i = 0; i < schemas.length; ++i) {\n                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });\n                    obj.$_terms.items.push(type);\n                }\n\n                return obj.$_mutateRebuild();\n            },\n            validate(value, { schema, error, state, prefs }) {\n\n                const requireds = schema.$_terms._requireds.slice();\n                const ordereds = schema.$_terms.ordered.slice();\n                const inclusions = [...schema.$_terms._inclusions, ...requireds];\n\n                const wasArray = !value[Common.symbols.arraySingle];\n                delete value[Common.symbols.arraySingle];\n\n                const errors = [];\n                let il = value.length;\n                for (let i = 0; i < il; ++i) {\n                    const item = value[i];\n\n                    let errored = false;\n                    let isValid = false;\n\n                    const key = wasArray ? i : new Number(i);       // eslint-disable-line no-new-wrappers\n                    const path = [...state.path, key];\n\n                    // Sparse\n\n                    if (!schema._flags.sparse &&\n                        item === undefined) {\n\n                        errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n\n                        ordereds.shift();\n                        continue;\n                    }\n\n                    // Exclusions\n\n                    const ancestors = [value, ...state.ancestors];\n\n                    for (const exclusion of schema.$_terms._exclusions) {\n                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: 'ignore' })) {\n                            continue;\n                        }\n\n                        errors.push(error('array.excludes', { pos: i, value: item }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n\n                        errored = true;\n                        ordereds.shift();\n                        break;\n                    }\n\n                    if (errored) {\n                        continue;\n                    }\n\n                    // Ordered\n\n                    if (schema.$_terms.ordered.length) {\n                        if (ordereds.length) {\n                            const ordered = ordereds.shift();\n                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);\n                            if (!res.errors) {\n                                if (ordered._flags.result === 'strip') {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                }\n                                else if (!schema._flags.sparse && res.value === undefined) {\n                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                    if (prefs.abortEarly) {\n                                        return errors;\n                                    }\n\n                                    continue;\n                                }\n                                else {\n                                    value[i] = res.value;\n                                }\n                            }\n                            else {\n                                errors.push(...res.errors);\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n\n                            continue;\n                        }\n                        else if (!schema.$_terms.items.length) {\n                            errors.push(error('array.orderedLength', { pos: i, limit: schema.$_terms.ordered.length }));\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n\n                            break;      // No reason to continue since there are no other rules to validate other than array.orderedLength\n                        }\n                    }\n\n                    // Requireds\n\n                    const requiredChecks = [];\n                    let jl = requireds.length;\n                    for (let j = 0; j < jl; ++j) {\n                        const localState = state.localize(path, ancestors, requireds[j]);\n                        localState.snapshot();\n\n                        const res = requireds[j].$_validate(item, localState, prefs);\n                        requiredChecks[j] = res;\n\n                        if (!res.errors) {\n                            value[i] = res.value;\n                            isValid = true;\n                            internals.fastSplice(requireds, j);\n                            --j;\n                            --jl;\n\n                            if (!schema._flags.sparse &&\n                                res.value === undefined) {\n\n                                errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n\n                            break;\n                        }\n\n                        localState.restore();\n                    }\n\n                    if (isValid) {\n                        continue;\n                    }\n\n                    // Inclusions\n\n                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;\n\n                    jl = inclusions.length;\n                    for (const inclusion of inclusions) {\n\n                        // Avoid re-running requireds that already didn't match in the previous loop\n\n                        let res;\n                        const previousCheck = requireds.indexOf(inclusion);\n                        if (previousCheck !== -1) {\n                            res = requiredChecks[previousCheck];\n                        }\n                        else {\n                            const localState = state.localize(path, ancestors, inclusion);\n                            localState.snapshot();\n\n                            res = inclusion.$_validate(item, localState, prefs);\n                            if (!res.errors) {\n                                if (inclusion._flags.result === 'strip') {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                }\n                                else if (!schema._flags.sparse &&\n                                    res.value === undefined) {\n\n                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                    errored = true;\n                                }\n                                else {\n                                    value[i] = res.value;\n                                }\n\n                                isValid = true;\n                                break;\n                            }\n\n                            localState.restore();\n                        }\n\n                        // Return the actual error if only one inclusion defined\n\n                        if (jl === 1) {\n                            if (stripUnknown) {\n                                internals.fastSplice(value, i);\n                                --i;\n                                --il;\n                                isValid = true;\n                                break;\n                            }\n\n                            errors.push(...res.errors);\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n\n                            errored = true;\n                            break;\n                        }\n                    }\n\n                    if (errored) {\n                        continue;\n                    }\n\n                    if (schema.$_terms._inclusions.length &&\n                        !isValid) {\n\n                        if (stripUnknown) {\n                            internals.fastSplice(value, i);\n                            --i;\n                            --il;\n                            continue;\n                        }\n\n                        errors.push(error('array.includes', { pos: i, value: item }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n                    }\n                }\n\n                if (requireds.length) {\n                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);\n                }\n\n                if (ordereds.length) {\n                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);\n                }\n\n                return errors.length ? errors : value;\n            },\n\n            priority: true,\n            manifest: false\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('array.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        },\n\n        ordered: {\n            method(...schemas) {\n\n                Common.verifyFlat(schemas, 'ordered');\n\n                const obj = this.$_addRule('items');\n\n                for (let i = 0; i < schemas.length; ++i) {\n                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });\n                    internals.validateSingle(type, obj);\n\n                    obj.$_mutateRegister(type);\n                    obj.$_terms.ordered.push(type);\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        single: {\n            method(enabled) {\n\n                const value = enabled === undefined ? true : !!enabled;\n                Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');\n\n                return this.$_setFlag('single', value);\n            }\n        },\n\n        sort: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['by', 'order']);\n\n                const settings = {\n                    order: options.order || 'ascending'\n                };\n\n                if (options.by) {\n                    settings.by = Compile.ref(options.by, { ancestor: 0 });\n                    Assert(!settings.by.ancestor, 'Cannot sort by ancestor');\n                }\n\n                return this.$_addRule({ name: 'sort', args: { options: settings } });\n            },\n            validate(value, { error, state, prefs, schema }, { options }) {\n\n                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);\n                if (errors) {\n                    return errors;\n                }\n\n                for (let i = 0; i < value.length; ++i) {\n                    if (value[i] !== sorted[i]) {\n                        return error('array.sort', { order: options.order, by: options.by ? options.by.key : 'value' });\n                    }\n                }\n\n                return value;\n            },\n            convert: true\n        },\n\n        sparse: {\n            method(enabled) {\n\n                const value = enabled === undefined ? true : !!enabled;\n\n                if (this._flags.sparse === value) {\n                    return this;\n                }\n\n                const obj = value ? this.clone() : this.$_addRule('items');\n                return obj.$_setFlag('sparse', value, { clone: false });\n            }\n        },\n\n        unique: {\n            method(comparator, options = {}) {\n\n                Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n                Common.assertOptions(options, ['ignoreUndefined', 'separator']);\n\n                const rule = { name: 'unique', args: { options, comparator } };\n\n                if (comparator) {\n                    if (typeof comparator === 'string') {\n                        const separator = Common.default(options.separator, '.');\n                        rule.path = separator ? comparator.split(separator) : [comparator];\n                    }\n                    else {\n                        rule.comparator = comparator;\n                    }\n                }\n\n                return this.$_addRule(rule);\n            },\n            validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {\n\n                const found = {\n                    string: Object.create(null),\n                    number: Object.create(null),\n                    undefined: Object.create(null),\n                    boolean: Object.create(null),\n                    object: new Map(),\n                    function: new Map(),\n                    custom: new Map()\n                };\n\n                const compare = comparator || DeepEqual;\n                const ignoreUndefined = options.ignoreUndefined;\n\n                for (let i = 0; i < value.length; ++i) {\n                    const item = path ? Reach(value[i], path) : value[i];\n                    const records = comparator ? found.custom : found[typeof item];\n                    Assert(records, 'Failed to find unique map container for type', typeof item);\n\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (path) {\n                                    context.path = raw;\n                                }\n\n                                return error('array.unique', context, localState);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if ((!ignoreUndefined || item !== undefined) &&\n                            records[item] !== undefined) {\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (path) {\n                                context.path = raw;\n                            }\n\n                            const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                            return error('array.unique', context, localState);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n\n                return value;\n            },\n            args: ['comparator', 'options'],\n            multi: true\n        }\n    },\n\n    cast: {\n        set: {\n            from: Array.isArray,\n            to(value, helpers) {\n\n                return new Set(value);\n            }\n        }\n    },\n\n    rebuild(schema) {\n\n        schema.$_terms._inclusions = [];\n        schema.$_terms._exclusions = [];\n        schema.$_terms._requireds = [];\n\n        for (const type of schema.$_terms.items) {\n            internals.validateSingle(type, schema);\n\n            if (type._flags.presence === 'required') {\n                schema.$_terms._requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                schema.$_terms._exclusions.push(type);\n            }\n            else {\n                schema.$_terms._inclusions.push(type);\n            }\n        }\n\n        for (const type of schema.$_terms.ordered) {\n            internals.validateSingle(type, schema);\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.items) {\n                obj = obj.items(...desc.items);\n            }\n\n            if (desc.ordered) {\n                obj = obj.ordered(...desc.ordered);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'array.base': '{{#label}} must be an array',\n        'array.excludes': '{{#label}} contains an excluded value',\n        'array.hasKnown': '{{#label}} does not contain at least one required match for type \"{#patternLabel}\"',\n        'array.hasUnknown': '{{#label}} does not contain at least one required match',\n        'array.includes': '{{#label}} does not match any of the allowed types',\n        'array.includesRequiredBoth': '{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',\n        'array.includesRequiredKnowns': '{{#label}} does not contain {{#knownMisses}}',\n        'array.includesRequiredUnknowns': '{{#label}} does not contain {{#unknownMisses}} required value(s)',\n        'array.length': '{{#label}} must contain {{#limit}} items',\n        'array.max': '{{#label}} must contain less than or equal to {{#limit}} items',\n        'array.min': '{{#label}} must contain at least {{#limit}} items',\n        'array.orderedLength': '{{#label}} must contain at most {{#limit}} items',\n        'array.sort': '{{#label}} must be sorted in {#order} order by {{#by}}',\n        'array.sort.mismatching': '{{#label}} cannot be sorted due to mismatching types',\n        'array.sort.unsupported': '{{#label}} cannot be sorted due to unsupported type {#type}',\n        'array.sparse': '{{#label}} must not be a sparse array item',\n        'array.unique': '{{#label}} contains a duplicate value'\n    }\n});\n\n\n// Helpers\n\ninternals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {\n\n    const knownMisses = [];\n    let unknownMisses = 0;\n    for (const required of requireds) {\n        const label = required._flags.label;\n        if (label) {\n            knownMisses.push(label);\n        }\n        else {\n            ++unknownMisses;\n        }\n    }\n\n    if (knownMisses.length) {\n        if (unknownMisses) {\n            errors.push(schema.$_createError('array.includesRequiredBoth', value, { knownMisses, unknownMisses }, state, prefs));\n        }\n        else {\n            errors.push(schema.$_createError('array.includesRequiredKnowns', value, { knownMisses }, state, prefs));\n        }\n    }\n    else {\n        errors.push(schema.$_createError('array.includesRequiredUnknowns', value, { unknownMisses }, state, prefs));\n    }\n};\n\n\ninternals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {\n\n    const requiredOrdereds = [];\n\n    for (const ordered of ordereds) {\n        if (ordered._flags.presence === 'required') {\n            requiredOrdereds.push(ordered);\n        }\n    }\n\n    if (requiredOrdereds.length) {\n        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);\n    }\n};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.validateSingle = function (type, obj) {\n\n    if (type.type === 'array' ||\n        type._flags._arrayItems) {\n\n        Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');\n        obj.$_setFlag('_arrayItems', true, { clone: false });\n    }\n};\n\n\ninternals.sort = function (schema, value, settings, state, prefs) {\n\n    const order = settings.order === 'ascending' ? 1 : -1;\n    const aFirst = -1 * order;\n    const bFirst = order;\n\n    const sort = (a, b) => {\n\n        let compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n\n        if (settings.by) {\n            a = settings.by.resolve(a, state, prefs);\n            b = settings.by.resolve(b, state, prefs);\n        }\n\n        compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n\n        const type = typeof a;\n        if (type !== typeof b) {\n            throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);\n        }\n\n        if (type !== 'number' &&\n            type !== 'string') {\n\n            throw schema.$_createError('array.sort.unsupported', value, { type }, state, prefs);\n        }\n\n        if (type === 'number') {\n            return (a - b) * order;\n        }\n\n        return a < b ? aFirst : bFirst;\n    };\n\n    try {\n        return { value: value.slice().sort(sort) };\n    }\n    catch (err) {\n        return { errors: err };\n    }\n};\n\n\ninternals.compare = function (a, b, aFirst, bFirst) {\n\n    if (a === b) {\n        return 0;\n    }\n\n    if (a === undefined) {\n        return 1;           // Always last regardless of sort order\n    }\n\n    if (b === undefined) {\n        return -1;           // Always last regardless of sort order\n    }\n\n    if (a === null) {\n        return bFirst;\n    }\n\n    if (b === null) {\n        return aFirst;\n    }\n\n    return null;\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,0BAAD,CAAzB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,sBAAD,CAArB;;AAEA,MAAMG,GAAG,GAAGH,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,YAAD,CAAvB;;AAGA,MAAMM,SAAS,GAAG,EAAlB;AAGAC,MAAM,CAACC,OAAP,GAAiBL,GAAG,CAACM,MAAJ,CAAW;EAExBC,IAAI,EAAE,OAFkB;EAIxBC,KAAK,EAAE;IAEHC,MAAM,EAAE;MAAEC,OAAO,EAAE;IAAX,CAFL;IAGHC,MAAM,EAAE;MAAED,OAAO,EAAE;IAAX;EAHL,CAJiB;EAUxBE,KAAK,EAAE;IAEHC,KAAK,EAAE;MAAEC,IAAI,EAAE,EAAR;MAAYC,QAAQ,EAAE;IAAtB,CAFJ;IAGHC,OAAO,EAAE;MAAEF,IAAI,EAAE,EAAR;MAAYC,QAAQ,EAAE;IAAtB,CAHN;IAKHE,WAAW,EAAE;MAAEH,IAAI,EAAE;IAAR,CALV;IAMHI,WAAW,EAAE;MAAEJ,IAAI,EAAE;IAAR,CANV;IAOHK,UAAU,EAAE;MAAEL,IAAI,EAAE;IAAR;EAPT,CAViB;EAoBxBM,MAAM,EAAE;IACJC,IAAI,EAAE,QADF;;IAEJC,MAAM,CAACC,KAAD,QAAkC;MAAA,IAA1B;QAAEC,MAAF;QAAUC,KAAV;QAAiBC;MAAjB,CAA0B;;MAEpC,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAL,EAA2B;QACvB;MACH;;MAED,MAAMM,IAAI,GAAGL,MAAM,CAACM,SAAP,CAAiB,MAAjB,CAAb;;MACA,IAAI,CAACD,IAAL,EAAW;QACP;MACH;;MAED,OAAO1B,SAAS,CAAC0B,IAAV,CAAeL,MAAf,EAAuBD,KAAvB,EAA8BM,IAAI,CAACE,IAAL,CAAUC,OAAxC,EAAiDP,KAAjD,EAAwDC,KAAxD,CAAP;IACH;;EAdG,CApBgB;;EAqCxBO,QAAQ,CAACV,KAAD,SAA2B;IAAA,IAAnB;MAAEC,MAAF;MAAUU;IAAV,CAAmB;;IAE/B,IAAI,CAACP,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAL,EAA2B;MACvB,IAAIC,MAAM,CAACW,MAAP,CAAc1B,MAAlB,EAA0B;QACtB,MAAMA,MAAM,GAAG,CAACc,KAAD,CAAf;QACAd,MAAM,CAACR,MAAM,CAACmC,OAAP,CAAeC,WAAhB,CAAN,GAAqC,IAArC;QACA,OAAO;UAAEd,KAAK,EAAEd;QAAT,CAAP;MACH;;MAED,OAAO;QAAE6B,MAAM,EAAEJ,KAAK,CAAC,YAAD;MAAf,CAAP;IACH;;IAED,IAAI,CAACV,MAAM,CAACM,SAAP,CAAiB,OAAjB,CAAD,IACA,CAACN,MAAM,CAACe,OAAP,CAAeC,SADpB,EAC+B;MAE3B;IACH;;IAED,OAAO;MAAEjB,KAAK,EAAEA,KAAK,CAACkB,KAAN;IAAT,CAAP,CAlB+B,CAkBS;EAC3C,CAxDuB;;EA0DxBC,KAAK,EAAE;IAEHC,GAAG,EAAE;MACDrB,MAAM,CAACE,MAAD,EAAS;QAEXA,MAAM,GAAG,KAAKoB,SAAL,CAAepB,MAAf,EAAuB;UAAEqB,UAAU,EAAE;QAAd,CAAvB,CAAT;QACA,MAAMC,GAAG,GAAG,KAAKC,SAAL,CAAe;UAAEC,IAAI,EAAE,KAAR;UAAejB,IAAI,EAAE;YAAEP;UAAF;QAArB,CAAf,CAAZ;QACAsB,GAAG,CAACG,gBAAJ,CAAqBzB,MAArB;QACA,OAAOsB,GAAP;MACH,CAPA;;MAQDb,QAAQ,CAACV,KAAD,gBAAkD;QAAA,IAA1C;UAAEE,KAAF;UAASC,KAAT;UAAgBQ;QAAhB,CAA0C;QAAA,IAAjB;UAAEV,MAAM,EAAEmB;QAAV,CAAiB;QAEtD,MAAMO,SAAS,GAAG,CAAC3B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAlB;;QACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,KAAK,CAAC6B,MAA1B,EAAkC,EAAED,CAApC,EAAuC;UACnC,MAAME,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAe,CAAC,GAAG7B,KAAK,CAAC8B,IAAV,EAAgBJ,CAAhB,CAAf,EAAmCD,SAAnC,EAA8CP,GAA9C,CAAnB;;UACA,IAAIA,GAAG,CAACa,OAAJ,CAAYjC,KAAK,CAAC4B,CAAD,CAAjB,EAAsBE,UAAtB,EAAkC3B,KAAlC,CAAJ,EAA8C;YAC1C,OAAOH,KAAP;UACH;QACJ;;QAED,MAAMkC,YAAY,GAAGd,GAAG,CAACR,MAAJ,CAAWuB,KAAhC;;QACA,IAAID,YAAJ,EAAkB;UACd,OAAOvB,KAAK,CAAC,gBAAD,EAAmB;YAAEuB;UAAF,CAAnB,CAAZ;QACH;;QAED,OAAOvB,KAAK,CAAC,kBAAD,EAAqB,IAArB,CAAZ;MACH,CAxBA;;MAyBDyB,KAAK,EAAE;IAzBN,CAFF;IA8BH9C,KAAK,EAAE;MACHS,MAAM,GAAa;QAAA,kCAATsC,OAAS;UAATA,OAAS;QAAA;;QAEf3D,MAAM,CAAC4D,UAAP,CAAkBD,OAAlB,EAA2B,OAA3B;QAEA,MAAMd,GAAG,GAAG,KAAKC,SAAL,CAAe,OAAf,CAAZ;;QAEA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,OAAO,CAACR,MAA5B,EAAoC,EAAED,CAAtC,EAAyC;UACrC,MAAM5C,IAAI,GAAGN,MAAM,CAAC6D,WAAP,CAAmB,MAAM,KAAKlB,SAAL,CAAegB,OAAO,CAACT,CAAD,CAAtB,CAAzB,EAAqDA,CAArD,EAAwD;YAAEY,MAAM,EAAE;UAAV,CAAxD,CAAb;UACAjB,GAAG,CAACP,OAAJ,CAAY1B,KAAZ,CAAkBmD,IAAlB,CAAuBzD,IAAvB;QACH;;QAED,OAAOuC,GAAG,CAACmB,eAAJ,EAAP;MACH,CAbE;;MAcHhC,QAAQ,CAACV,KAAD,SAAyC;QAAA,IAAjC;UAAEC,MAAF;UAAUU,KAAV;UAAiBT,KAAjB;UAAwBC;QAAxB,CAAiC;;QAE7C,MAAMwC,SAAS,GAAG1C,MAAM,CAACe,OAAP,CAAepB,UAAf,CAA0BsB,KAA1B,EAAlB;;QACA,MAAM0B,QAAQ,GAAG3C,MAAM,CAACe,OAAP,CAAevB,OAAf,CAAuByB,KAAvB,EAAjB;QACA,MAAM2B,UAAU,GAAG,CAAC,GAAG5C,MAAM,CAACe,OAAP,CAAerB,WAAnB,EAAgC,GAAGgD,SAAnC,CAAnB;QAEA,MAAMG,QAAQ,GAAG,CAAC9C,KAAK,CAACtB,MAAM,CAACmC,OAAP,CAAeC,WAAhB,CAAvB;QACA,OAAOd,KAAK,CAACtB,MAAM,CAACmC,OAAP,CAAeC,WAAhB,CAAZ;QAEA,MAAMC,MAAM,GAAG,EAAf;QACA,IAAIgC,EAAE,GAAG/C,KAAK,CAAC6B,MAAf;;QACA,KAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmB,EAApB,EAAwB,EAAEnB,CAA1B,EAA6B;UACzB,MAAMoB,IAAI,GAAGhD,KAAK,CAAC4B,CAAD,CAAlB;UAEA,IAAIqB,OAAO,GAAG,KAAd;UACA,IAAIC,OAAO,GAAG,KAAd;UAEA,MAAMC,GAAG,GAAGL,QAAQ,GAAGlB,CAAH,GAAO,IAAIwB,MAAJ,CAAWxB,CAAX,CAA3B,CANyB,CAMuB;;UAChD,MAAMI,IAAI,GAAG,CAAC,GAAG9B,KAAK,CAAC8B,IAAV,EAAgBmB,GAAhB,CAAb,CAPyB,CASzB;;UAEA,IAAI,CAAClD,MAAM,CAACW,MAAP,CAAcxB,MAAf,IACA4D,IAAI,KAAKK,SADb,EACwB;YAEpBtC,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,cAAD,EAAiB;cAAEwC,GAAF;cAAOnB,IAAP;cAAasB,GAAG,EAAE1B,CAAlB;cAAqB5B,KAAK,EAAEqD;YAA5B,CAAjB,EAA0DnD,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA1D,CAAjB;;YACA,IAAI7B,KAAK,CAACoD,UAAV,EAAsB;cAClB,OAAOxC,MAAP;YACH;;YAED6B,QAAQ,CAACY,KAAT;YACA;UACH,CArBwB,CAuBzB;;;UAEA,MAAM7B,SAAS,GAAG,CAAC3B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAlB;;UAEA,KAAK,MAAM8B,SAAX,IAAwBxD,MAAM,CAACe,OAAP,CAAetB,WAAvC,EAAoD;YAChD,IAAI,CAAC+D,SAAS,CAACxB,OAAV,CAAkBe,IAAlB,EAAwB9C,KAAK,CAAC6B,QAAN,CAAeC,IAAf,EAAqBL,SAArB,EAAgC8B,SAAhC,CAAxB,EAAoEtD,KAApE,EAA2E;cAAEuD,QAAQ,EAAE;YAAZ,CAA3E,CAAL,EAAyG;cACrG;YACH;;YAED3C,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,gBAAD,EAAmB;cAAE2C,GAAG,EAAE1B,CAAP;cAAU5B,KAAK,EAAEgD;YAAjB,CAAnB,EAA4C9C,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA5C,CAAjB;;YACA,IAAI7B,KAAK,CAACoD,UAAV,EAAsB;cAClB,OAAOxC,MAAP;YACH;;YAEDkC,OAAO,GAAG,IAAV;YACAL,QAAQ,CAACY,KAAT;YACA;UACH;;UAED,IAAIP,OAAJ,EAAa;YACT;UACH,CA5CwB,CA8CzB;;;UAEA,IAAIhD,MAAM,CAACe,OAAP,CAAevB,OAAf,CAAuBoC,MAA3B,EAAmC;YAC/B,IAAIe,QAAQ,CAACf,MAAb,EAAqB;cACjB,MAAMpC,OAAO,GAAGmD,QAAQ,CAACY,KAAT,EAAhB;cACA,MAAMG,GAAG,GAAGlE,OAAO,CAACmE,UAAR,CAAmBZ,IAAnB,EAAyB9C,KAAK,CAAC6B,QAAN,CAAeC,IAAf,EAAqBL,SAArB,EAAgClC,OAAhC,CAAzB,EAAmEU,KAAnE,CAAZ;;cACA,IAAI,CAACwD,GAAG,CAAC5C,MAAT,EAAiB;gBACb,IAAItB,OAAO,CAACmB,MAAR,CAAeiD,MAAf,KAA0B,OAA9B,EAAuC;kBACnCjF,SAAS,CAACkF,UAAV,CAAqB9D,KAArB,EAA4B4B,CAA5B;kBACA,EAAEA,CAAF;kBACA,EAAEmB,EAAF;gBACH,CAJD,MAKK,IAAI,CAAC9C,MAAM,CAACW,MAAP,CAAcxB,MAAf,IAAyBuE,GAAG,CAAC3D,KAAJ,KAAcqD,SAA3C,EAAsD;kBACvDtC,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,cAAD,EAAiB;oBAAEwC,GAAF;oBAAOnB,IAAP;oBAAasB,GAAG,EAAE1B,CAAlB;oBAAqB5B,KAAK,EAAEqD;kBAA5B,CAAjB,EAA0DnD,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA1D,CAAjB;;kBACA,IAAI7B,KAAK,CAACoD,UAAV,EAAsB;oBAClB,OAAOxC,MAAP;kBACH;;kBAED;gBACH,CAPI,MAQA;kBACDf,KAAK,CAAC4B,CAAD,CAAL,GAAW+B,GAAG,CAAC3D,KAAf;gBACH;cACJ,CAjBD,MAkBK;gBACDe,MAAM,CAAC0B,IAAP,CAAY,GAAGkB,GAAG,CAAC5C,MAAnB;;gBACA,IAAIZ,KAAK,CAACoD,UAAV,EAAsB;kBAClB,OAAOxC,MAAP;gBACH;cACJ;;cAED;YACH,CA7BD,MA8BK,IAAI,CAACd,MAAM,CAACe,OAAP,CAAe1B,KAAf,CAAqBuC,MAA1B,EAAkC;cACnCd,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,qBAAD,EAAwB;gBAAE2C,GAAG,EAAE1B,CAAP;gBAAUmC,KAAK,EAAE9D,MAAM,CAACe,OAAP,CAAevB,OAAf,CAAuBoC;cAAxC,CAAxB,CAAjB;;cACA,IAAI1B,KAAK,CAACoD,UAAV,EAAsB;gBAClB,OAAOxC,MAAP;cACH;;cAED,MANmC,CAMvB;YACf;UACJ,CAvFwB,CAyFzB;;;UAEA,MAAMiD,cAAc,GAAG,EAAvB;UACA,IAAIC,EAAE,GAAGtB,SAAS,CAACd,MAAnB;;UACA,KAAK,IAAIqC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,EAApB,EAAwB,EAAEC,CAA1B,EAA6B;YACzB,MAAMpC,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAeC,IAAf,EAAqBL,SAArB,EAAgCgB,SAAS,CAACuB,CAAD,CAAzC,CAAnB;YACApC,UAAU,CAACqC,QAAX;YAEA,MAAMR,GAAG,GAAGhB,SAAS,CAACuB,CAAD,CAAT,CAAaN,UAAb,CAAwBZ,IAAxB,EAA8BlB,UAA9B,EAA0C3B,KAA1C,CAAZ;YACA6D,cAAc,CAACE,CAAD,CAAd,GAAoBP,GAApB;;YAEA,IAAI,CAACA,GAAG,CAAC5C,MAAT,EAAiB;cACbf,KAAK,CAAC4B,CAAD,CAAL,GAAW+B,GAAG,CAAC3D,KAAf;cACAkD,OAAO,GAAG,IAAV;cACAtE,SAAS,CAACkF,UAAV,CAAqBnB,SAArB,EAAgCuB,CAAhC;cACA,EAAEA,CAAF;cACA,EAAED,EAAF;;cAEA,IAAI,CAAChE,MAAM,CAACW,MAAP,CAAcxB,MAAf,IACAuE,GAAG,CAAC3D,KAAJ,KAAcqD,SADlB,EAC6B;gBAEzBtC,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,cAAD,EAAiB;kBAAEwC,GAAF;kBAAOnB,IAAP;kBAAasB,GAAG,EAAE1B,CAAlB;kBAAqB5B,KAAK,EAAEqD;gBAA5B,CAAjB,EAA0DnD,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA1D,CAAjB;;gBACA,IAAI7B,KAAK,CAACoD,UAAV,EAAsB;kBAClB,OAAOxC,MAAP;gBACH;cACJ;;cAED;YACH;;YAEDe,UAAU,CAACsC,OAAX;UACH;;UAED,IAAIlB,OAAJ,EAAa;YACT;UACH,CA5HwB,CA8HzB;;;UAEA,MAAMmB,YAAY,GAAGlE,KAAK,CAACkE,YAAN,IAAsB,CAAC,CAAClE,KAAK,CAACkE,YAAN,CAAmBC,MAA3C,IAAqD,KAA1E;UAEAL,EAAE,GAAGpB,UAAU,CAAChB,MAAhB;;UACA,KAAK,MAAM0C,SAAX,IAAwB1B,UAAxB,EAAoC;YAEhC;YAEA,IAAIc,GAAJ;YACA,MAAMa,aAAa,GAAG7B,SAAS,CAAC8B,OAAV,CAAkBF,SAAlB,CAAtB;;YACA,IAAIC,aAAa,KAAK,CAAC,CAAvB,EAA0B;cACtBb,GAAG,GAAGK,cAAc,CAACQ,aAAD,CAApB;YACH,CAFD,MAGK;cACD,MAAM1C,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAeC,IAAf,EAAqBL,SAArB,EAAgC4C,SAAhC,CAAnB;cACAzC,UAAU,CAACqC,QAAX;cAEAR,GAAG,GAAGY,SAAS,CAACX,UAAV,CAAqBZ,IAArB,EAA2BlB,UAA3B,EAAuC3B,KAAvC,CAAN;;cACA,IAAI,CAACwD,GAAG,CAAC5C,MAAT,EAAiB;gBACb,IAAIwD,SAAS,CAAC3D,MAAV,CAAiBiD,MAAjB,KAA4B,OAAhC,EAAyC;kBACrCjF,SAAS,CAACkF,UAAV,CAAqB9D,KAArB,EAA4B4B,CAA5B;kBACA,EAAEA,CAAF;kBACA,EAAEmB,EAAF;gBACH,CAJD,MAKK,IAAI,CAAC9C,MAAM,CAACW,MAAP,CAAcxB,MAAf,IACLuE,GAAG,CAAC3D,KAAJ,KAAcqD,SADb,EACwB;kBAEzBtC,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,cAAD,EAAiB;oBAAEwC,GAAF;oBAAOnB,IAAP;oBAAasB,GAAG,EAAE1B,CAAlB;oBAAqB5B,KAAK,EAAEqD;kBAA5B,CAAjB,EAA0DnD,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA1D,CAAjB;kBACAiB,OAAO,GAAG,IAAV;gBACH,CALI,MAMA;kBACDjD,KAAK,CAAC4B,CAAD,CAAL,GAAW+B,GAAG,CAAC3D,KAAf;gBACH;;gBAEDkD,OAAO,GAAG,IAAV;gBACA;cACH;;cAEDpB,UAAU,CAACsC,OAAX;YACH,CAnC+B,CAqChC;;;YAEA,IAAIH,EAAE,KAAK,CAAX,EAAc;cACV,IAAII,YAAJ,EAAkB;gBACdzF,SAAS,CAACkF,UAAV,CAAqB9D,KAArB,EAA4B4B,CAA5B;gBACA,EAAEA,CAAF;gBACA,EAAEmB,EAAF;gBACAG,OAAO,GAAG,IAAV;gBACA;cACH;;cAEDnC,MAAM,CAAC0B,IAAP,CAAY,GAAGkB,GAAG,CAAC5C,MAAnB;;cACA,IAAIZ,KAAK,CAACoD,UAAV,EAAsB;gBAClB,OAAOxC,MAAP;cACH;;cAEDkC,OAAO,GAAG,IAAV;cACA;YACH;UACJ;;UAED,IAAIA,OAAJ,EAAa;YACT;UACH;;UAED,IAAIhD,MAAM,CAACe,OAAP,CAAerB,WAAf,CAA2BkC,MAA3B,IACA,CAACqB,OADL,EACc;YAEV,IAAImB,YAAJ,EAAkB;cACdzF,SAAS,CAACkF,UAAV,CAAqB9D,KAArB,EAA4B4B,CAA5B;cACA,EAAEA,CAAF;cACA,EAAEmB,EAAF;cACA;YACH;;YAEDhC,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,gBAAD,EAAmB;cAAE2C,GAAG,EAAE1B,CAAP;cAAU5B,KAAK,EAAEgD;YAAjB,CAAnB,EAA4C9C,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA5C,CAAjB;;YACA,IAAI7B,KAAK,CAACoD,UAAV,EAAsB;cAClB,OAAOxC,MAAP;YACH;UACJ;QACJ;;QAED,IAAI4B,SAAS,CAACd,MAAd,EAAsB;UAClBjD,SAAS,CAAC8F,gBAAV,CAA2BzE,MAA3B,EAAmCc,MAAnC,EAA2C4B,SAA3C,EAAsD3C,KAAtD,EAA6DE,KAA7D,EAAoEC,KAApE;QACH;;QAED,IAAIyC,QAAQ,CAACf,MAAb,EAAqB;UACjBjD,SAAS,CAAC+F,iBAAV,CAA4B1E,MAA5B,EAAoCc,MAApC,EAA4C6B,QAA5C,EAAsD5C,KAAtD,EAA6DE,KAA7D,EAAoEC,KAApE;QACH;;QAED,OAAOY,MAAM,CAACc,MAAP,GAAgBd,MAAhB,GAAyBf,KAAhC;MACH,CApPE;;MAsPH4E,QAAQ,EAAE,IAtPP;MAuPHpF,QAAQ,EAAE;IAvPP,CA9BJ;IAwRHqC,MAAM,EAAE;MACJ9B,MAAM,CAACgE,KAAD,EAAQ;QAEV,OAAO,KAAKvC,SAAL,CAAe;UAAEC,IAAI,EAAE,QAAR;UAAkBjB,IAAI,EAAE;YAAEuD;UAAF,CAAxB;UAAmCc,QAAQ,EAAE;QAA7C,CAAf,CAAP;MACH,CAJG;;MAKJnE,QAAQ,CAACV,KAAD,EAAQ8E,OAAR,gBAAsD;QAAA,IAArC;UAAEf;QAAF,CAAqC;QAAA,IAA1B;UAAEtC,IAAF;UAAQoD,QAAR;UAAkBrE;QAAlB,CAA0B;;QAE1D,IAAI9B,MAAM,CAACqG,OAAP,CAAe/E,KAAK,CAAC6B,MAArB,EAA6BkC,KAA7B,EAAoCc,QAApC,CAAJ,EAAmD;UAC/C,OAAO7E,KAAP;QACH;;QAED,OAAO8E,OAAO,CAACnE,KAAR,CAAc,WAAWc,IAAzB,EAA+B;UAAEsC,KAAK,EAAEvD,IAAI,CAACuD,KAAd;UAAqB/D;QAArB,CAA/B,CAAP;MACH,CAZG;;MAaJQ,IAAI,EAAE,CACF;QACIiB,IAAI,EAAE,OADV;QAEIuD,GAAG,EAAE,IAFT;QAGIC,MAAM,EAAEvG,MAAM,CAACqF,KAHnB;QAIImB,OAAO,EAAE;MAJb,CADE;IAbF,CAxRL;IA+SHC,GAAG,EAAE;MACDpF,MAAM,CAACgE,KAAD,EAAQ;QAEV,OAAO,KAAKvC,SAAL,CAAe;UAAEC,IAAI,EAAE,KAAR;UAAe1B,MAAM,EAAE,QAAvB;UAAiCS,IAAI,EAAE;YAAEuD;UAAF,CAAvC;UAAkDc,QAAQ,EAAE;QAA5D,CAAf,CAAP;MACH;;IAJA,CA/SF;IAsTHO,GAAG,EAAE;MACDrF,MAAM,CAACgE,KAAD,EAAQ;QAEV,OAAO,KAAKvC,SAAL,CAAe;UAAEC,IAAI,EAAE,KAAR;UAAe1B,MAAM,EAAE,QAAvB;UAAiCS,IAAI,EAAE;YAAEuD;UAAF,CAAvC;UAAkDc,QAAQ,EAAE;QAA5D,CAAf,CAAP;MACH;;IAJA,CAtTF;IA6THpF,OAAO,EAAE;MACLM,MAAM,GAAa;QAAA,mCAATsC,OAAS;UAATA,OAAS;QAAA;;QAEf3D,MAAM,CAAC4D,UAAP,CAAkBD,OAAlB,EAA2B,SAA3B;QAEA,MAAMd,GAAG,GAAG,KAAKC,SAAL,CAAe,OAAf,CAAZ;;QAEA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,OAAO,CAACR,MAA5B,EAAoC,EAAED,CAAtC,EAAyC;UACrC,MAAM5C,IAAI,GAAGN,MAAM,CAAC6D,WAAP,CAAmB,MAAM,KAAKlB,SAAL,CAAegB,OAAO,CAACT,CAAD,CAAtB,CAAzB,EAAqDA,CAArD,EAAwD;YAAEY,MAAM,EAAE;UAAV,CAAxD,CAAb;UACA5D,SAAS,CAACyG,cAAV,CAAyBrG,IAAzB,EAA+BuC,GAA/B;UAEAA,GAAG,CAACG,gBAAJ,CAAqB1C,IAArB;UACAuC,GAAG,CAACP,OAAJ,CAAYvB,OAAZ,CAAoBgD,IAApB,CAAyBzD,IAAzB;QACH;;QAED,OAAOuC,GAAG,CAACmB,eAAJ,EAAP;MACH;;IAhBI,CA7TN;IAgVHxD,MAAM,EAAE;MACJa,MAAM,CAACuF,OAAD,EAAU;QAEZ,MAAMtF,KAAK,GAAGsF,OAAO,KAAKjC,SAAZ,GAAwB,IAAxB,GAA+B,CAAC,CAACiC,OAA/C;QACAjH,MAAM,CAAC,CAAC2B,KAAD,IAAU,CAAC,KAAKY,MAAL,CAAY2E,WAAxB,EAAqC,uDAArC,CAAN;QAEA,OAAO,KAAKC,SAAL,CAAe,QAAf,EAAyBxF,KAAzB,CAAP;MACH;;IAPG,CAhVL;IA0VHM,IAAI,EAAE;MACFP,MAAM,GAAe;QAAA,IAAdU,OAAc,uEAAJ,EAAI;QAEjB/B,MAAM,CAAC+G,aAAP,CAAqBhF,OAArB,EAA8B,CAAC,IAAD,EAAO,OAAP,CAA9B;QAEA,MAAMiF,QAAQ,GAAG;UACbC,KAAK,EAAElF,OAAO,CAACkF,KAAR,IAAiB;QADX,CAAjB;;QAIA,IAAIlF,OAAO,CAACmF,EAAZ,EAAgB;UACZF,QAAQ,CAACE,EAAT,GAAcjH,OAAO,CAACqG,GAAR,CAAYvE,OAAO,CAACmF,EAApB,EAAwB;YAAEC,QAAQ,EAAE;UAAZ,CAAxB,CAAd;UACAxH,MAAM,CAAC,CAACqH,QAAQ,CAACE,EAAT,CAAYC,QAAd,EAAwB,yBAAxB,CAAN;QACH;;QAED,OAAO,KAAKrE,SAAL,CAAe;UAAEC,IAAI,EAAE,MAAR;UAAgBjB,IAAI,EAAE;YAAEC,OAAO,EAAEiF;UAAX;QAAtB,CAAf,CAAP;MACH,CAfC;;MAgBFhF,QAAQ,CAACV,KAAD,gBAAsD;QAAA,IAA9C;UAAEW,KAAF;UAAST,KAAT;UAAgBC,KAAhB;UAAuBF;QAAvB,CAA8C;QAAA,IAAb;UAAEQ;QAAF,CAAa;QAE1D,MAAM;UAAET,KAAK,EAAE8F,MAAT;UAAiB/E;QAAjB,IAA4BnC,SAAS,CAAC0B,IAAV,CAAeL,MAAf,EAAuBD,KAAvB,EAA8BS,OAA9B,EAAuCP,KAAvC,EAA8CC,KAA9C,CAAlC;;QACA,IAAIY,MAAJ,EAAY;UACR,OAAOA,MAAP;QACH;;QAED,KAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,KAAK,CAAC6B,MAA1B,EAAkC,EAAED,CAApC,EAAuC;UACnC,IAAI5B,KAAK,CAAC4B,CAAD,CAAL,KAAakE,MAAM,CAAClE,CAAD,CAAvB,EAA4B;YACxB,OAAOjB,KAAK,CAAC,YAAD,EAAe;cAAEgF,KAAK,EAAElF,OAAO,CAACkF,KAAjB;cAAwBC,EAAE,EAAEnF,OAAO,CAACmF,EAAR,GAAanF,OAAO,CAACmF,EAAR,CAAWzC,GAAxB,GAA8B;YAA1D,CAAf,CAAZ;UACH;QACJ;;QAED,OAAOnD,KAAP;MACH,CA9BC;;MA+BF+F,OAAO,EAAE;IA/BP,CA1VH;IA4XH3G,MAAM,EAAE;MACJW,MAAM,CAACuF,OAAD,EAAU;QAEZ,MAAMtF,KAAK,GAAGsF,OAAO,KAAKjC,SAAZ,GAAwB,IAAxB,GAA+B,CAAC,CAACiC,OAA/C;;QAEA,IAAI,KAAK1E,MAAL,CAAYxB,MAAZ,KAAuBY,KAA3B,EAAkC;UAC9B,OAAO,IAAP;QACH;;QAED,MAAMuB,GAAG,GAAGvB,KAAK,GAAG,KAAKgG,KAAL,EAAH,GAAkB,KAAKxE,SAAL,CAAe,OAAf,CAAnC;QACA,OAAOD,GAAG,CAACiE,SAAJ,CAAc,QAAd,EAAwBxF,KAAxB,EAA+B;UAAEgG,KAAK,EAAE;QAAT,CAA/B,CAAP;MACH;;IAXG,CA5XL;IA0YHC,MAAM,EAAE;MACJlG,MAAM,CAACmG,UAAD,EAA2B;QAAA,IAAdzF,OAAc,uEAAJ,EAAI;QAE7BpC,MAAM,CAAC,CAAC6H,UAAD,IAAe,OAAOA,UAAP,KAAsB,UAArC,IAAmD,OAAOA,UAAP,KAAsB,QAA1E,EAAoF,2CAApF,CAAN;QACAxH,MAAM,CAAC+G,aAAP,CAAqBhF,OAArB,EAA8B,CAAC,iBAAD,EAAoB,WAApB,CAA9B;QAEA,MAAM0F,IAAI,GAAG;UAAE1E,IAAI,EAAE,QAAR;UAAkBjB,IAAI,EAAE;YAAEC,OAAF;YAAWyF;UAAX;QAAxB,CAAb;;QAEA,IAAIA,UAAJ,EAAgB;UACZ,IAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;YAChC,MAAME,SAAS,GAAG1H,MAAM,CAACS,OAAP,CAAesB,OAAO,CAAC2F,SAAvB,EAAkC,GAAlC,CAAlB;YACAD,IAAI,CAACnE,IAAL,GAAYoE,SAAS,GAAGF,UAAU,CAACG,KAAX,CAAiBD,SAAjB,CAAH,GAAiC,CAACF,UAAD,CAAtD;UACH,CAHD,MAIK;YACDC,IAAI,CAACD,UAAL,GAAkBA,UAAlB;UACH;QACJ;;QAED,OAAO,KAAK1E,SAAL,CAAe2E,IAAf,CAAP;MACH,CAnBG;;MAoBJzF,QAAQ,CAACV,KAAD,0BAAsF;QAAA,IAA9E;UAAEE,KAAF;UAASS,KAAT;UAAgBV;QAAhB,CAA8E;QAAA,IAApD;UAAEiG,UAAU,EAAEI,GAAd;UAAmB7F;QAAnB,CAAoD;QAAA,IAAtB;UAAEyF,UAAF;UAAclE;QAAd,CAAsB;QAE1F,MAAMuE,KAAK,GAAG;UACVC,MAAM,EAAEC,MAAM,CAACC,MAAP,CAAc,IAAd,CADE;UAEVC,MAAM,EAAEF,MAAM,CAACC,MAAP,CAAc,IAAd,CAFE;UAGVrD,SAAS,EAAEoD,MAAM,CAACC,MAAP,CAAc,IAAd,CAHD;UAIVE,OAAO,EAAEH,MAAM,CAACC,MAAP,CAAc,IAAd,CAJC;UAKVG,MAAM,EAAE,IAAIC,GAAJ,EALE;UAMVC,QAAQ,EAAE,IAAID,GAAJ,EANA;UAOVE,MAAM,EAAE,IAAIF,GAAJ;QAPE,CAAd;QAUA,MAAM/B,OAAO,GAAGmB,UAAU,IAAI3H,SAA9B;QACA,MAAM0I,eAAe,GAAGxG,OAAO,CAACwG,eAAhC;;QAEA,KAAK,IAAIrF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,KAAK,CAAC6B,MAA1B,EAAkC,EAAED,CAApC,EAAuC;UACnC,MAAMoB,IAAI,GAAGhB,IAAI,GAAGxD,KAAK,CAACwB,KAAK,CAAC4B,CAAD,CAAN,EAAWI,IAAX,CAAR,GAA2BhC,KAAK,CAAC4B,CAAD,CAAjD;UACA,MAAMsF,OAAO,GAAGhB,UAAU,GAAGK,KAAK,CAACS,MAAT,GAAkBT,KAAK,CAAC,OAAOvD,IAAR,CAAjD;UACA3E,MAAM,CAAC6I,OAAD,EAAU,8CAAV,EAA0D,OAAOlE,IAAjE,CAAN;;UAEA,IAAIkE,OAAO,YAAYJ,GAAvB,EAA4B;YACxB,MAAMK,OAAO,GAAGD,OAAO,CAACC,OAAR,EAAhB;YACA,IAAIC,OAAJ;;YACA,OAAO,CAAC,CAACA,OAAO,GAAGD,OAAO,CAACE,IAAR,EAAX,EAA2BC,IAAnC,EAAyC;cACrC,IAAIvC,OAAO,CAACqC,OAAO,CAACpH,KAAR,CAAc,CAAd,CAAD,EAAmBgD,IAAnB,CAAX,EAAqC;gBACjC,MAAMlB,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAe,CAAC,GAAG7B,KAAK,CAAC8B,IAAV,EAAgBJ,CAAhB,CAAf,EAAmC,CAAC5B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAnC,CAAnB;gBACA,MAAM4F,OAAO,GAAG;kBACZjE,GAAG,EAAE1B,CADO;kBAEZ5B,KAAK,EAAEA,KAAK,CAAC4B,CAAD,CAFA;kBAGZ4F,OAAO,EAAEJ,OAAO,CAACpH,KAAR,CAAc,CAAd,CAHG;kBAIZyH,SAAS,EAAEzH,KAAK,CAACoH,OAAO,CAACpH,KAAR,CAAc,CAAd,CAAD;gBAJJ,CAAhB;;gBAOA,IAAIgC,IAAJ,EAAU;kBACNuF,OAAO,CAACvF,IAAR,GAAesE,GAAf;gBACH;;gBAED,OAAO3F,KAAK,CAAC,cAAD,EAAiB4G,OAAjB,EAA0BzF,UAA1B,CAAZ;cACH;YACJ;;YAEDoF,OAAO,CAACQ,GAAR,CAAY1E,IAAZ,EAAkBpB,CAAlB;UACH,CAtBD,MAuBK;YACD,IAAI,CAAC,CAACqF,eAAD,IAAoBjE,IAAI,KAAKK,SAA9B,KACA6D,OAAO,CAAClE,IAAD,CAAP,KAAkBK,SADtB,EACiC;cAE7B,MAAMkE,OAAO,GAAG;gBACZjE,GAAG,EAAE1B,CADO;gBAEZ5B,KAAK,EAAEA,KAAK,CAAC4B,CAAD,CAFA;gBAGZ4F,OAAO,EAAEN,OAAO,CAAClE,IAAD,CAHJ;gBAIZyE,SAAS,EAAEzH,KAAK,CAACkH,OAAO,CAAClE,IAAD,CAAR;cAJJ,CAAhB;;cAOA,IAAIhB,IAAJ,EAAU;gBACNuF,OAAO,CAACvF,IAAR,GAAesE,GAAf;cACH;;cAED,MAAMxE,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAe,CAAC,GAAG7B,KAAK,CAAC8B,IAAV,EAAgBJ,CAAhB,CAAf,EAAmC,CAAC5B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAnC,CAAnB;cACA,OAAOhB,KAAK,CAAC,cAAD,EAAiB4G,OAAjB,EAA0BzF,UAA1B,CAAZ;YACH;;YAEDoF,OAAO,CAAClE,IAAD,CAAP,GAAgBpB,CAAhB;UACH;QACJ;;QAED,OAAO5B,KAAP;MACH,CAvFG;;MAwFJQ,IAAI,EAAE,CAAC,YAAD,EAAe,SAAf,CAxFF;MAyFJ4B,KAAK,EAAE;IAzFH;EA1YL,CA1DiB;EAiiBxBuF,IAAI,EAAE;IACFD,GAAG,EAAE;MACD5H,IAAI,EAAEM,KAAK,CAACC,OADX;;MAEDuH,EAAE,CAAC5H,KAAD,EAAQ8E,OAAR,EAAiB;QAEf,OAAO,IAAI+C,GAAJ,CAAQ7H,KAAR,CAAP;MACH;;IALA;EADH,CAjiBkB;;EA2iBxB8H,OAAO,CAAC7H,MAAD,EAAS;IAEZA,MAAM,CAACe,OAAP,CAAerB,WAAf,GAA6B,EAA7B;IACAM,MAAM,CAACe,OAAP,CAAetB,WAAf,GAA6B,EAA7B;IACAO,MAAM,CAACe,OAAP,CAAepB,UAAf,GAA4B,EAA5B;;IAEA,KAAK,MAAMZ,IAAX,IAAmBiB,MAAM,CAACe,OAAP,CAAe1B,KAAlC,EAAyC;MACrCV,SAAS,CAACyG,cAAV,CAAyBrG,IAAzB,EAA+BiB,MAA/B;;MAEA,IAAIjB,IAAI,CAAC4B,MAAL,CAAY8C,QAAZ,KAAyB,UAA7B,EAAyC;QACrCzD,MAAM,CAACe,OAAP,CAAepB,UAAf,CAA0B6C,IAA1B,CAA+BzD,IAA/B;MACH,CAFD,MAGK,IAAIA,IAAI,CAAC4B,MAAL,CAAY8C,QAAZ,KAAyB,WAA7B,EAA0C;QAC3CzD,MAAM,CAACe,OAAP,CAAetB,WAAf,CAA2B+C,IAA3B,CAAgCzD,IAAhC;MACH,CAFI,MAGA;QACDiB,MAAM,CAACe,OAAP,CAAerB,WAAf,CAA2B8C,IAA3B,CAAgCzD,IAAhC;MACH;IACJ;;IAED,KAAK,MAAMA,IAAX,IAAmBiB,MAAM,CAACe,OAAP,CAAevB,OAAlC,EAA2C;MACvCb,SAAS,CAACyG,cAAV,CAAyBrG,IAAzB,EAA+BiB,MAA/B;IACH;EACJ,CAlkBuB;;EAokBxBT,QAAQ,EAAE;IAENuI,KAAK,CAACxG,GAAD,EAAMyG,IAAN,EAAY;MAEb,IAAIA,IAAI,CAAC1I,KAAT,EAAgB;QACZiC,GAAG,GAAGA,GAAG,CAACjC,KAAJ,CAAU,GAAG0I,IAAI,CAAC1I,KAAlB,CAAN;MACH;;MAED,IAAI0I,IAAI,CAACvI,OAAT,EAAkB;QACd8B,GAAG,GAAGA,GAAG,CAAC9B,OAAJ,CAAY,GAAGuI,IAAI,CAACvI,OAApB,CAAN;MACH;;MAED,OAAO8B,GAAP;IACH;;EAbK,CApkBc;EAolBxB0G,QAAQ,EAAE;IACN,cAAc,6BADR;IAEN,kBAAkB,uCAFZ;IAGN,kBAAkB,oFAHZ;IAIN,oBAAoB,yDAJd;IAKN,kBAAkB,oDALZ;IAMN,8BAA8B,6FANxB;IAON,gCAAgC,8CAP1B;IAQN,kCAAkC,kEAR5B;IASN,gBAAgB,0CATV;IAUN,aAAa,gEAVP;IAWN,aAAa,mDAXP;IAYN,uBAAuB,kDAZjB;IAaN,cAAc,wDAbR;IAcN,0BAA0B,sDAdpB;IAeN,0BAA0B,6DAfpB;IAgBN,gBAAgB,4CAhBV;IAiBN,gBAAgB;EAjBV;AAplBc,CAAX,CAAjB,C,CA0mBA;;AAEArJ,SAAS,CAAC8F,gBAAV,GAA6B,UAAUzE,MAAV,EAAkBc,MAAlB,EAA0B4B,SAA1B,EAAqC3C,KAArC,EAA4CE,KAA5C,EAAmDC,KAAnD,EAA0D;EAEnF,MAAM+H,WAAW,GAAG,EAApB;EACA,IAAIC,aAAa,GAAG,CAApB;;EACA,KAAK,MAAMC,QAAX,IAAuBzF,SAAvB,EAAkC;IAC9B,MAAMR,KAAK,GAAGiG,QAAQ,CAACxH,MAAT,CAAgBuB,KAA9B;;IACA,IAAIA,KAAJ,EAAW;MACP+F,WAAW,CAACzF,IAAZ,CAAiBN,KAAjB;IACH,CAFD,MAGK;MACD,EAAEgG,aAAF;IACH;EACJ;;EAED,IAAID,WAAW,CAACrG,MAAhB,EAAwB;IACpB,IAAIsG,aAAJ,EAAmB;MACfpH,MAAM,CAAC0B,IAAP,CAAYxC,MAAM,CAACoI,aAAP,CAAqB,4BAArB,EAAmDrI,KAAnD,EAA0D;QAAEkI,WAAF;QAAeC;MAAf,CAA1D,EAA0FjI,KAA1F,EAAiGC,KAAjG,CAAZ;IACH,CAFD,MAGK;MACDY,MAAM,CAAC0B,IAAP,CAAYxC,MAAM,CAACoI,aAAP,CAAqB,8BAArB,EAAqDrI,KAArD,EAA4D;QAAEkI;MAAF,CAA5D,EAA6EhI,KAA7E,EAAoFC,KAApF,CAAZ;IACH;EACJ,CAPD,MAQK;IACDY,MAAM,CAAC0B,IAAP,CAAYxC,MAAM,CAACoI,aAAP,CAAqB,gCAArB,EAAuDrI,KAAvD,EAA8D;MAAEmI;IAAF,CAA9D,EAAiFjI,KAAjF,EAAwFC,KAAxF,CAAZ;EACH;AACJ,CAzBD;;AA4BAvB,SAAS,CAAC+F,iBAAV,GAA8B,UAAU1E,MAAV,EAAkBc,MAAlB,EAA0B6B,QAA1B,EAAoC5C,KAApC,EAA2CE,KAA3C,EAAkDC,KAAlD,EAAyD;EAEnF,MAAMmI,gBAAgB,GAAG,EAAzB;;EAEA,KAAK,MAAM7I,OAAX,IAAsBmD,QAAtB,EAAgC;IAC5B,IAAInD,OAAO,CAACmB,MAAR,CAAe8C,QAAf,KAA4B,UAAhC,EAA4C;MACxC4E,gBAAgB,CAAC7F,IAAjB,CAAsBhD,OAAtB;IACH;EACJ;;EAED,IAAI6I,gBAAgB,CAACzG,MAArB,EAA6B;IACzBjD,SAAS,CAAC8F,gBAAV,CAA2BzE,MAA3B,EAAmCc,MAAnC,EAA2CuH,gBAA3C,EAA6DtI,KAA7D,EAAoEE,KAApE,EAA2EC,KAA3E;EACH;AACJ,CAbD;;AAgBAvB,SAAS,CAACkF,UAAV,GAAuB,UAAUyE,GAAV,EAAe3G,CAAf,EAAkB;EAErC,IAAI0B,GAAG,GAAG1B,CAAV;;EACA,OAAO0B,GAAG,GAAGiF,GAAG,CAAC1G,MAAjB,EAAyB;IACrB0G,GAAG,CAACjF,GAAG,EAAJ,CAAH,GAAaiF,GAAG,CAACjF,GAAD,CAAhB;EACH;;EAED,EAAEiF,GAAG,CAAC1G,MAAN;AACH,CARD;;AAWAjD,SAAS,CAACyG,cAAV,GAA2B,UAAUrG,IAAV,EAAgBuC,GAAhB,EAAqB;EAE5C,IAAIvC,IAAI,CAACA,IAAL,KAAc,OAAd,IACAA,IAAI,CAAC4B,MAAL,CAAY2E,WADhB,EAC6B;IAEzBlH,MAAM,CAAC,CAACkD,GAAG,CAACX,MAAJ,CAAW1B,MAAb,EAAqB,oDAArB,CAAN;IACAqC,GAAG,CAACiE,SAAJ,CAAc,aAAd,EAA6B,IAA7B,EAAmC;MAAEQ,KAAK,EAAE;IAAT,CAAnC;EACH;AACJ,CARD;;AAWApH,SAAS,CAAC0B,IAAV,GAAiB,UAAUL,MAAV,EAAkBD,KAAlB,EAAyB0F,QAAzB,EAAmCxF,KAAnC,EAA0CC,KAA1C,EAAiD;EAE9D,MAAMwF,KAAK,GAAGD,QAAQ,CAACC,KAAT,KAAmB,WAAnB,GAAiC,CAAjC,GAAqC,CAAC,CAApD;EACA,MAAM6C,MAAM,GAAG,CAAC,CAAD,GAAK7C,KAApB;EACA,MAAM8C,MAAM,GAAG9C,KAAf;;EAEA,MAAMrF,IAAI,GAAG,CAACoI,CAAD,EAAIC,CAAJ,KAAU;IAEnB,IAAI5D,OAAO,GAAGnG,SAAS,CAACmG,OAAV,CAAkB2D,CAAlB,EAAqBC,CAArB,EAAwBH,MAAxB,EAAgCC,MAAhC,CAAd;;IACA,IAAI1D,OAAO,KAAK,IAAhB,EAAsB;MAClB,OAAOA,OAAP;IACH;;IAED,IAAIW,QAAQ,CAACE,EAAb,EAAiB;MACb8C,CAAC,GAAGhD,QAAQ,CAACE,EAAT,CAAYgD,OAAZ,CAAoBF,CAApB,EAAuBxI,KAAvB,EAA8BC,KAA9B,CAAJ;MACAwI,CAAC,GAAGjD,QAAQ,CAACE,EAAT,CAAYgD,OAAZ,CAAoBD,CAApB,EAAuBzI,KAAvB,EAA8BC,KAA9B,CAAJ;IACH;;IAED4E,OAAO,GAAGnG,SAAS,CAACmG,OAAV,CAAkB2D,CAAlB,EAAqBC,CAArB,EAAwBH,MAAxB,EAAgCC,MAAhC,CAAV;;IACA,IAAI1D,OAAO,KAAK,IAAhB,EAAsB;MAClB,OAAOA,OAAP;IACH;;IAED,MAAM/F,IAAI,GAAG,OAAO0J,CAApB;;IACA,IAAI1J,IAAI,KAAK,OAAO2J,CAApB,EAAuB;MACnB,MAAM1I,MAAM,CAACoI,aAAP,CAAqB,wBAArB,EAA+CrI,KAA/C,EAAsD,IAAtD,EAA4DE,KAA5D,EAAmEC,KAAnE,CAAN;IACH;;IAED,IAAInB,IAAI,KAAK,QAAT,IACAA,IAAI,KAAK,QADb,EACuB;MAEnB,MAAMiB,MAAM,CAACoI,aAAP,CAAqB,wBAArB,EAA+CrI,KAA/C,EAAsD;QAAEhB;MAAF,CAAtD,EAAgEkB,KAAhE,EAAuEC,KAAvE,CAAN;IACH;;IAED,IAAInB,IAAI,KAAK,QAAb,EAAuB;MACnB,OAAO,CAAC0J,CAAC,GAAGC,CAAL,IAAUhD,KAAjB;IACH;;IAED,OAAO+C,CAAC,GAAGC,CAAJ,GAAQH,MAAR,GAAiBC,MAAxB;EACH,CAjCD;;EAmCA,IAAI;IACA,OAAO;MAAEzI,KAAK,EAAEA,KAAK,CAACkB,KAAN,GAAcZ,IAAd,CAAmBA,IAAnB;IAAT,CAAP;EACH,CAFD,CAGA,OAAOuI,GAAP,EAAY;IACR,OAAO;MAAE9H,MAAM,EAAE8H;IAAV,CAAP;EACH;AACJ,CA/CD;;AAkDAjK,SAAS,CAACmG,OAAV,GAAoB,UAAU2D,CAAV,EAAaC,CAAb,EAAgBH,MAAhB,EAAwBC,MAAxB,EAAgC;EAEhD,IAAIC,CAAC,KAAKC,CAAV,EAAa;IACT,OAAO,CAAP;EACH;;EAED,IAAID,CAAC,KAAKrF,SAAV,EAAqB;IACjB,OAAO,CAAP,CADiB,CACG;EACvB;;EAED,IAAIsF,CAAC,KAAKtF,SAAV,EAAqB;IACjB,OAAO,CAAC,CAAR,CADiB,CACI;EACxB;;EAED,IAAIqF,CAAC,KAAK,IAAV,EAAgB;IACZ,OAAOD,MAAP;EACH;;EAED,IAAIE,CAAC,KAAK,IAAV,EAAgB;IACZ,OAAOH,MAAP;EACH;;EAED,OAAO,IAAP;AACH,CAvBD"},"metadata":{},"sourceType":"script"}