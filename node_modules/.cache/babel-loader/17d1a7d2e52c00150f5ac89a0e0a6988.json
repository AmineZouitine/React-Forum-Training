{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst internals = {};\nexports.Sorter = class {\n  constructor() {\n    this._items = [];\n    this.nodes = [];\n  }\n\n  add(nodes, options) {\n    options = options || {}; // Validate rules\n\n    const before = [].concat(options.before || []);\n    const after = [].concat(options.after || []);\n    const group = options.group || '?';\n    const sort = options.sort || 0; // Used for merging only\n\n    Assert(!before.includes(group), `Item cannot come before itself: ${group}`);\n    Assert(!before.includes('?'), 'Item cannot come before unassociated items');\n    Assert(!after.includes(group), `Item cannot come after itself: ${group}`);\n    Assert(!after.includes('?'), 'Item cannot come after unassociated items');\n\n    if (!Array.isArray(nodes)) {\n      nodes = [nodes];\n    }\n\n    for (const node of nodes) {\n      const item = {\n        seq: this._items.length,\n        sort,\n        before,\n        after,\n        group,\n        node\n      };\n\n      this._items.push(item);\n    } // Insert event\n\n\n    if (!options.manual) {\n      const valid = this._sort();\n\n      Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');\n    }\n\n    return this.nodes;\n  }\n\n  merge(others) {\n    if (!Array.isArray(others)) {\n      others = [others];\n    }\n\n    for (const other of others) {\n      if (other) {\n        for (const item of other._items) {\n          this._items.push(Object.assign({}, item)); // Shallow cloned\n\n        }\n      }\n    } // Sort items\n\n\n    this._items.sort(internals.mergeSort);\n\n    for (let i = 0; i < this._items.length; ++i) {\n      this._items[i].seq = i;\n    }\n\n    const valid = this._sort();\n\n    Assert(valid, 'merge created a dependencies error');\n    return this.nodes;\n  }\n\n  sort() {\n    const valid = this._sort();\n\n    Assert(valid, 'sort created a dependencies error');\n    return this.nodes;\n  }\n\n  _sort() {\n    // Construct graph\n    const graph = {};\n    const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n    const groups = Object.create(null);\n\n    for (const item of this._items) {\n      const seq = item.seq; // Unique across all items\n\n      const group = item.group; // Determine Groups\n\n      groups[group] = groups[group] || [];\n      groups[group].push(seq); // Build intermediary graph using 'before'\n\n      graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n      for (const after of item.after) {\n        graphAfters[after] = graphAfters[after] || [];\n        graphAfters[after].push(seq);\n      }\n    } // Expand intermediary graph\n\n\n    for (const node in graph) {\n      const expandedGroups = [];\n\n      for (const graphNodeItem in graph[node]) {\n        const group = graph[node][graphNodeItem];\n        groups[group] = groups[group] || [];\n        expandedGroups.push(...groups[group]);\n      }\n\n      graph[node] = expandedGroups;\n    } // Merge intermediary graph using graphAfters into final graph\n\n\n    for (const group in graphAfters) {\n      if (groups[group]) {\n        for (const node of groups[group]) {\n          graph[node].push(...graphAfters[group]);\n        }\n      }\n    } // Compile ancestors\n\n\n    const ancestors = {};\n\n    for (const node in graph) {\n      const children = graph[node];\n\n      for (const child of children) {\n        ancestors[child] = ancestors[child] || [];\n        ancestors[child].push(node);\n      }\n    } // Topo sort\n\n\n    const visited = {};\n    const sorted = [];\n\n    for (let i = 0; i < this._items.length; ++i) {\n      // Looping through item.seq values out of order\n      let next = i;\n\n      if (ancestors[i]) {\n        next = null;\n\n        for (let j = 0; j < this._items.length; ++j) {\n          // As above, these are item.seq values\n          if (visited[j] === true) {\n            continue;\n          }\n\n          if (!ancestors[j]) {\n            ancestors[j] = [];\n          }\n\n          const shouldSeeCount = ancestors[j].length;\n          let seenCount = 0;\n\n          for (let k = 0; k < shouldSeeCount; ++k) {\n            if (visited[ancestors[j][k]]) {\n              ++seenCount;\n            }\n          }\n\n          if (seenCount === shouldSeeCount) {\n            next = j;\n            break;\n          }\n        }\n      }\n\n      if (next !== null) {\n        visited[next] = true;\n        sorted.push(next);\n      }\n    }\n\n    if (sorted.length !== this._items.length) {\n      return false;\n    }\n\n    const seqIndex = {};\n\n    for (const item of this._items) {\n      seqIndex[item.seq] = item;\n    }\n\n    this._items = [];\n    this.nodes = [];\n\n    for (const value of sorted) {\n      const sortedItem = seqIndex[value];\n      this.nodes.push(sortedItem.node);\n\n      this._items.push(sortedItem);\n    }\n\n    return true;\n  }\n\n};\n\ninternals.mergeSort = (a, b) => {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};","map":{"version":3,"names":["Assert","require","internals","exports","Sorter","constructor","_items","nodes","add","options","before","concat","after","group","sort","includes","Array","isArray","node","item","seq","length","push","manual","valid","_sort","merge","others","other","Object","assign","mergeSort","i","graph","graphAfters","create","groups","expandedGroups","graphNodeItem","ancestors","children","child","visited","sorted","next","j","shouldSeeCount","seenCount","k","seqIndex","value","sortedItem","a","b"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/topo/lib/index.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\n\nconst internals = {};\n\n\nexports.Sorter = class {\n\n    constructor() {\n\n        this._items = [];\n        this.nodes = [];\n    }\n\n    add(nodes, options) {\n\n        options = options || {};\n\n        // Validate rules\n\n        const before = [].concat(options.before || []);\n        const after = [].concat(options.after || []);\n        const group = options.group || '?';\n        const sort = options.sort || 0;                   // Used for merging only\n\n        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);\n        Assert(!before.includes('?'), 'Item cannot come before unassociated items');\n        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);\n        Assert(!after.includes('?'), 'Item cannot come after unassociated items');\n\n        if (!Array.isArray(nodes)) {\n            nodes = [nodes];\n        }\n\n        for (const node of nodes) {\n            const item = {\n                seq: this._items.length,\n                sort,\n                before,\n                after,\n                group,\n                node\n            };\n\n            this._items.push(item);\n        }\n\n        // Insert event\n\n        if (!options.manual) {\n            const valid = this._sort();\n            Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');\n        }\n\n        return this.nodes;\n    }\n\n    merge(others) {\n\n        if (!Array.isArray(others)) {\n            others = [others];\n        }\n\n        for (const other of others) {\n            if (other) {\n                for (const item of other._items) {\n                    this._items.push(Object.assign({}, item));      // Shallow cloned\n                }\n            }\n        }\n\n        // Sort items\n\n        this._items.sort(internals.mergeSort);\n        for (let i = 0; i < this._items.length; ++i) {\n            this._items[i].seq = i;\n        }\n\n        const valid = this._sort();\n        Assert(valid, 'merge created a dependencies error');\n\n        return this.nodes;\n    }\n\n    sort() {\n\n        const valid = this._sort();\n        Assert(valid, 'sort created a dependencies error');\n\n        return this.nodes;\n    }\n\n    _sort() {\n\n        // Construct graph\n\n        const graph = {};\n        const graphAfters = Object.create(null);            // A prototype can bungle lookups w/ false positives\n        const groups = Object.create(null);\n\n        for (const item of this._items) {\n            const seq = item.seq;                           // Unique across all items\n            const group = item.group;\n\n            // Determine Groups\n\n            groups[group] = groups[group] || [];\n            groups[group].push(seq);\n\n            // Build intermediary graph using 'before'\n\n            graph[seq] = item.before;\n\n            // Build second intermediary graph with 'after'\n\n            for (const after of item.after) {\n                graphAfters[after] = graphAfters[after] || [];\n                graphAfters[after].push(seq);\n            }\n        }\n\n        // Expand intermediary graph\n\n        for (const node in graph) {\n            const expandedGroups = [];\n\n            for (const graphNodeItem in graph[node]) {\n                const group = graph[node][graphNodeItem];\n                groups[group] = groups[group] || [];\n                expandedGroups.push(...groups[group]);\n            }\n\n            graph[node] = expandedGroups;\n        }\n\n        // Merge intermediary graph using graphAfters into final graph\n\n        for (const group in graphAfters) {\n            if (groups[group]) {\n                for (const node of groups[group]) {\n                    graph[node].push(...graphAfters[group]);\n                }\n            }\n        }\n\n        // Compile ancestors\n\n        const ancestors = {};\n        for (const node in graph) {\n            const children = graph[node];\n            for (const child of children) {\n                ancestors[child] = ancestors[child] || [];\n                ancestors[child].push(node);\n            }\n        }\n\n        // Topo sort\n\n        const visited = {};\n        const sorted = [];\n\n        for (let i = 0; i < this._items.length; ++i) {          // Looping through item.seq values out of order\n            let next = i;\n\n            if (ancestors[i]) {\n                next = null;\n                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values\n                    if (visited[j] === true) {\n                        continue;\n                    }\n\n                    if (!ancestors[j]) {\n                        ancestors[j] = [];\n                    }\n\n                    const shouldSeeCount = ancestors[j].length;\n                    let seenCount = 0;\n                    for (let k = 0; k < shouldSeeCount; ++k) {\n                        if (visited[ancestors[j][k]]) {\n                            ++seenCount;\n                        }\n                    }\n\n                    if (seenCount === shouldSeeCount) {\n                        next = j;\n                        break;\n                    }\n                }\n            }\n\n            if (next !== null) {\n                visited[next] = true;\n                sorted.push(next);\n            }\n        }\n\n        if (sorted.length !== this._items.length) {\n            return false;\n        }\n\n        const seqIndex = {};\n        for (const item of this._items) {\n            seqIndex[item.seq] = item;\n        }\n\n        this._items = [];\n        this.nodes = [];\n\n        for (const value of sorted) {\n            const sortedItem = seqIndex[value];\n            this.nodes.push(sortedItem.node);\n            this._items.push(sortedItem);\n        }\n\n        return true;\n    }\n};\n\n\ninternals.mergeSort = (a, b) => {\n\n    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}