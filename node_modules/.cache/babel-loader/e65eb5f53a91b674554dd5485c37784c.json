{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst internals = {};\ninternals.Map = class extends Map {\n  slice() {\n    return new internals.Map(this);\n  }\n\n};\nmodule.exports = Any.extend({\n  type: 'symbol',\n  terms: {\n    map: {\n      init: new internals.Map()\n    }\n  },\n  coerce: {\n    method(value, _ref) {\n      let {\n        schema,\n        error\n      } = _ref;\n      const lookup = schema.$_terms.map.get(value);\n\n      if (lookup) {\n        value = lookup;\n      }\n\n      if (!schema._flags.only || typeof value === 'symbol') {\n        return {\n          value\n        };\n      }\n\n      return {\n        value,\n        errors: error('symbol.map', {\n          map: schema.$_terms.map\n        })\n      };\n    }\n\n  },\n\n  validate(value, _ref2) {\n    let {\n      error\n    } = _ref2;\n\n    if (typeof value !== 'symbol') {\n      return {\n        value,\n        errors: error('symbol.base')\n      };\n    }\n  },\n\n  rules: {\n    map: {\n      method(iterable) {\n        if (iterable && !iterable[Symbol.iterator] && typeof iterable === 'object') {\n          iterable = Object.entries(iterable);\n        }\n\n        Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');\n        const obj = this.clone();\n        const symbols = [];\n\n        for (const entry of iterable) {\n          Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');\n          const [key, value] = entry;\n          Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');\n          Assert(typeof value === 'symbol', 'Value must be a Symbol');\n          obj.$_terms.map.set(key, value);\n          symbols.push(value);\n        }\n\n        return obj.valid(...symbols);\n      }\n\n    }\n  },\n  manifest: {\n    build(obj, desc) {\n      if (desc.map) {\n        obj = obj.map(desc.map);\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'symbol.base': '{{#label}} must be a symbol',\n    'symbol.map': '{{#label}} must be one of {{#map}}'\n  }\n});","map":{"version":3,"names":["Assert","require","Any","internals","Map","slice","module","exports","extend","type","terms","map","init","coerce","method","value","schema","error","lookup","$_terms","get","_flags","only","errors","validate","rules","iterable","Symbol","iterator","Object","entries","obj","clone","symbols","entry","key","set","push","valid","manifest","build","desc","messages"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/types/symbol.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\n\nconst internals = {};\n\n\ninternals.Map = class extends Map {\n\n    slice() {\n\n        return new internals.Map(this);\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'symbol',\n\n    terms: {\n\n        map: { init: new internals.Map() }\n    },\n\n    coerce: {\n        method(value, { schema, error }) {\n\n            const lookup = schema.$_terms.map.get(value);\n            if (lookup) {\n                value = lookup;\n            }\n\n            if (!schema._flags.only ||\n                typeof value === 'symbol') {\n\n                return { value };\n            }\n\n            return { value, errors: error('symbol.map', { map: schema.$_terms.map }) };\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'symbol') {\n            return { value, errors: error('symbol.base') };\n        }\n    },\n\n    rules: {\n        map: {\n            method(iterable) {\n\n                if (iterable &&\n                    !iterable[Symbol.iterator] &&\n                    typeof iterable === 'object') {\n\n                    iterable = Object.entries(iterable);\n                }\n\n                Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');\n\n                const obj = this.clone();\n\n                const symbols = [];\n                for (const entry of iterable) {\n                    Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');\n                    const [key, value] = entry;\n\n                    Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');\n                    Assert(typeof value === 'symbol', 'Value must be a Symbol');\n\n                    obj.$_terms.map.set(key, value);\n                    symbols.push(value);\n                }\n\n                return obj.valid(...symbols);\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.map) {\n                obj = obj.map(desc.map);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'symbol.base': '{{#label}} must be a symbol',\n        'symbol.map': '{{#label}} must be one of {{#map}}'\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}