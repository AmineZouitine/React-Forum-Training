{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Compile = require('../compile');\n\nconst Errors = require('../errors');\n\nconst Ref = require('../ref');\n\nconst internals = {};\nmodule.exports = Any.extend({\n  type: 'alternatives',\n  flags: {\n    match: {\n      default: 'any'\n    } // 'any', 'one', 'all'\n\n  },\n  terms: {\n    matches: {\n      init: [],\n      register: Ref.toSibling\n    }\n  },\n\n  args(schema) {\n    for (var _len = arguments.length, schemas = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      schemas[_key - 1] = arguments[_key];\n    }\n\n    if (schemas.length === 1) {\n      if (Array.isArray(schemas[0])) {\n        return schema.try(...schemas[0]);\n      }\n    }\n\n    return schema.try(...schemas);\n  },\n\n  validate(value, helpers) {\n    const {\n      schema,\n      error,\n      state,\n      prefs\n    } = helpers; // Match all or one\n\n    if (schema._flags.match) {\n      let hits = 0;\n      let matched;\n\n      for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n        const item = schema.$_terms.matches[i];\n        const localState = state.nest(item.schema, `match.${i}`);\n        localState.snapshot();\n        const result = item.schema.$_validate(value, localState, prefs);\n\n        if (!result.errors) {\n          ++hits;\n          matched = result.value;\n        } else {\n          localState.restore();\n        }\n      }\n\n      if (!hits) {\n        return {\n          errors: error('alternatives.any')\n        };\n      }\n\n      if (schema._flags.match === 'one') {\n        return hits === 1 ? {\n          value: matched\n        } : {\n          errors: error('alternatives.one')\n        };\n      }\n\n      return hits === schema.$_terms.matches.length ? {\n        value\n      } : {\n        errors: error('alternatives.all')\n      };\n    } // Match any\n\n\n    const errors = [];\n\n    for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n      const item = schema.$_terms.matches[i]; // Try\n\n      if (item.schema) {\n        const localState = state.nest(item.schema, `match.${i}`);\n        localState.snapshot();\n        const result = item.schema.$_validate(value, localState, prefs);\n\n        if (!result.errors) {\n          return result;\n        }\n\n        localState.restore();\n        errors.push({\n          schema: item.schema,\n          reports: result.errors\n        });\n        continue;\n      } // Conditional\n\n\n      const input = item.ref ? item.ref.resolve(value, state, prefs) : value;\n      const tests = item.is ? [item] : item.switch;\n\n      for (let j = 0; j < tests.length; ++j) {\n        const test = tests[j];\n        const {\n          is,\n          then,\n          otherwise\n        } = test;\n        const id = `match.${i}${item.switch ? '.' + j : ''}`;\n\n        if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {\n          if (otherwise) {\n            return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);\n          }\n        } else if (then) {\n          return then.$_validate(value, state.nest(then, `${id}.then`), prefs);\n        }\n      }\n    }\n\n    return internals.errors(errors, helpers);\n  },\n\n  rules: {\n    conditional: {\n      method(condition, options) {\n        Assert(!this._flags._endedSwitch, 'Unreachable condition');\n        Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');\n        Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');\n        const obj = this.clone();\n        const match = Compile.when(obj, condition, options);\n        const conditions = match.is ? [match] : match.switch;\n\n        for (const item of conditions) {\n          if (item.then && item.otherwise) {\n            obj.$_setFlag('_endedSwitch', true, {\n              clone: false\n            });\n            break;\n          }\n        }\n\n        obj.$_terms.matches.push(match);\n        return obj.$_mutateRebuild();\n      }\n\n    },\n    match: {\n      method(mode) {\n        Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);\n\n        if (mode !== 'any') {\n          for (const match of this.$_terms.matches) {\n            Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');\n          }\n        }\n\n        return this.$_setFlag('match', mode);\n      }\n\n    },\n    try: {\n      method() {\n        for (var _len2 = arguments.length, schemas = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          schemas[_key2] = arguments[_key2];\n        }\n\n        Assert(schemas.length, 'Missing alternative schemas');\n        Common.verifyFlat(schemas, 'try');\n        Assert(!this._flags._endedSwitch, 'Unreachable condition');\n        const obj = this.clone();\n\n        for (const schema of schemas) {\n          obj.$_terms.matches.push({\n            schema: obj.$_compile(schema)\n          });\n        }\n\n        return obj.$_mutateRebuild();\n      }\n\n    }\n  },\n  overrides: {\n    label(name) {\n      const obj = this.$_super.label(name);\n\n      const each = (item, source) => source.path[0] !== 'is' ? item.label(name) : undefined;\n\n      return obj.$_modify({\n        each,\n        ref: false\n      });\n    }\n\n  },\n\n  rebuild(schema) {\n    // Flag when an alternative type is an array\n    const each = item => {\n      if (Common.isSchema(item) && item.type === 'array') {\n        schema.$_setFlag('_arrayItems', true, {\n          clone: false\n        });\n      }\n    };\n\n    schema.$_modify({\n      each\n    });\n  },\n\n  manifest: {\n    build(obj, desc) {\n      if (desc.matches) {\n        for (const match of desc.matches) {\n          const {\n            schema,\n            ref,\n            is,\n            not,\n            then,\n            otherwise\n          } = match;\n\n          if (schema) {\n            obj = obj.try(schema);\n          } else if (ref) {\n            obj = obj.conditional(ref, {\n              is,\n              then,\n              not,\n              otherwise,\n              switch: match.switch\n            });\n          } else {\n            obj = obj.conditional(is, {\n              then,\n              otherwise\n            });\n          }\n        }\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'alternatives.all': '{{#label}} does not match all of the required types',\n    'alternatives.any': '{{#label}} does not match any of the allowed types',\n    'alternatives.match': '{{#label}} does not match any of the allowed types',\n    'alternatives.one': '{{#label}} matches more than one allowed type',\n    'alternatives.types': '{{#label}} must be one of {{#types}}'\n  }\n}); // Helpers\n\ninternals.errors = function (failures, _ref) {\n  let {\n    error,\n    state\n  } = _ref;\n\n  // Nothing matched due to type criteria rules\n  if (!failures.length) {\n    return {\n      errors: error('alternatives.any')\n    };\n  } // Single error\n\n\n  if (failures.length === 1) {\n    return {\n      errors: failures[0].reports\n    };\n  } // Analyze reasons\n\n\n  const valids = new Set();\n  const complex = [];\n\n  for (const {\n    reports,\n    schema\n  } of failures) {\n    // Multiple errors (!abortEarly)\n    if (reports.length > 1) {\n      return internals.unmatched(failures, error);\n    } // Custom error\n\n\n    const report = reports[0];\n\n    if (report instanceof Errors.Report === false) {\n      return internals.unmatched(failures, error);\n    } // Internal object or array error\n\n\n    if (report.state.path.length !== state.path.length) {\n      complex.push({\n        type: schema.type,\n        report\n      });\n      continue;\n    } // Valids\n\n\n    if (report.code === 'any.only') {\n      for (const valid of report.local.valids) {\n        valids.add(valid);\n      }\n\n      continue;\n    } // Base type\n\n\n    const [type, code] = report.code.split('.');\n\n    if (code !== 'base') {\n      complex.push({\n        type: schema.type,\n        report\n      });\n      continue;\n    }\n\n    valids.add(type);\n  } // All errors are base types or valids\n\n\n  if (!complex.length) {\n    return {\n      errors: error('alternatives.types', {\n        types: [...valids]\n      })\n    };\n  } // Single complex error\n\n\n  if (complex.length === 1) {\n    return {\n      errors: complex[0].report\n    };\n  }\n\n  return internals.unmatched(failures, error);\n};\n\ninternals.unmatched = function (failures, error) {\n  const errors = [];\n\n  for (const failure of failures) {\n    errors.push(...failure.reports);\n  }\n\n  return {\n    errors: error('alternatives.match', Errors.details(errors, {\n      override: false\n    }))\n  };\n};","map":{"version":3,"names":["Assert","require","Any","Common","Compile","Errors","Ref","internals","module","exports","extend","type","flags","match","default","terms","matches","init","register","toSibling","args","schema","schemas","length","Array","isArray","try","validate","value","helpers","error","state","prefs","_flags","hits","matched","i","$_terms","item","localState","nest","snapshot","result","$_validate","errors","restore","push","reports","input","ref","resolve","tests","is","switch","j","test","then","otherwise","id","$_match","rules","conditional","method","condition","options","_endedSwitch","break","undefined","obj","clone","when","conditions","$_setFlag","$_mutateRebuild","mode","includes","verifyFlat","$_compile","overrides","label","name","$_super","each","source","path","$_modify","rebuild","isSchema","manifest","build","desc","not","messages","failures","valids","Set","complex","unmatched","report","Report","code","valid","local","add","split","types","failure","details","override"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/types/alternatives.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Compile = require('../compile');\nconst Errors = require('../errors');\nconst Ref = require('../ref');\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'alternatives',\n\n    flags: {\n\n        match: { default: 'any' }                 // 'any', 'one', 'all'\n    },\n\n    terms: {\n\n        matches: { init: [], register: Ref.toSibling }\n    },\n\n    args(schema, ...schemas) {\n\n        if (schemas.length === 1) {\n            if (Array.isArray(schemas[0])) {\n                return schema.try(...schemas[0]);\n            }\n        }\n\n        return schema.try(...schemas);\n    },\n\n    validate(value, helpers) {\n\n        const { schema, error, state, prefs } = helpers;\n\n        // Match all or one\n\n        if (schema._flags.match) {\n            let hits = 0;\n            let matched;\n\n            for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n                const item = schema.$_terms.matches[i];\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    ++hits;\n                    matched = result.value;\n                }\n                else {\n                    localState.restore();\n                }\n            }\n\n            if (!hits) {\n                return { errors: error('alternatives.any') };\n            }\n\n            if (schema._flags.match === 'one') {\n                return hits === 1 ? { value: matched } : { errors: error('alternatives.one') };\n            }\n\n            return hits === schema.$_terms.matches.length ? { value } : { errors: error('alternatives.all') };\n        }\n\n        // Match any\n\n        const errors = [];\n        for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n            const item = schema.$_terms.matches[i];\n\n            // Try\n\n            if (item.schema) {\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    return result;\n                }\n\n                localState.restore();\n                errors.push({ schema: item.schema, reports: result.errors });\n                continue;\n            }\n\n            // Conditional\n\n            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;\n            const tests = item.is ? [item] : item.switch;\n\n            for (let j = 0; j < tests.length; ++j) {\n                const test = tests[j];\n                const { is, then, otherwise } = test;\n\n                const id = `match.${i}${item.switch ? '.' + j : ''}`;\n                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {\n                    if (otherwise) {\n                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);\n                    }\n                }\n                else if (then) {\n                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);\n                }\n            }\n        }\n\n        return internals.errors(errors, helpers);\n    },\n\n    rules: {\n\n        conditional: {\n            method(condition, options) {\n\n                Assert(!this._flags._endedSwitch, 'Unreachable condition');\n                Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');\n                Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');\n\n                const obj = this.clone();\n\n                const match = Compile.when(obj, condition, options);\n                const conditions = match.is ? [match] : match.switch;\n                for (const item of conditions) {\n                    if (item.then &&\n                        item.otherwise) {\n\n                        obj.$_setFlag('_endedSwitch', true, { clone: false });\n                        break;\n                    }\n                }\n\n                obj.$_terms.matches.push(match);\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        match: {\n            method(mode) {\n\n                Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);\n\n                if (mode !== 'any') {\n                    for (const match of this.$_terms.matches) {\n                        Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');\n                    }\n                }\n\n                return this.$_setFlag('match', mode);\n            }\n        },\n\n        try: {\n            method(...schemas) {\n\n                Assert(schemas.length, 'Missing alternative schemas');\n                Common.verifyFlat(schemas, 'try');\n\n                Assert(!this._flags._endedSwitch, 'Unreachable condition');\n\n                const obj = this.clone();\n                for (const schema of schemas) {\n                    obj.$_terms.matches.push({ schema: obj.$_compile(schema) });\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        }\n    },\n\n    overrides: {\n\n        label(name) {\n\n            const obj = this.$_super.label(name);\n            const each = (item, source) => (source.path[0] !== 'is' ? item.label(name) : undefined);\n            return obj.$_modify({ each, ref: false });\n        }\n    },\n\n    rebuild(schema) {\n\n        // Flag when an alternative type is an array\n\n        const each = (item) => {\n\n            if (Common.isSchema(item) &&\n                item.type === 'array') {\n\n                schema.$_setFlag('_arrayItems', true, { clone: false });\n            }\n        };\n\n        schema.$_modify({ each });\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.matches) {\n                for (const match of desc.matches) {\n                    const { schema, ref, is, not, then, otherwise } = match;\n                    if (schema) {\n                        obj = obj.try(schema);\n                    }\n                    else if (ref) {\n                        obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });\n                    }\n                    else {\n                        obj = obj.conditional(is, { then, otherwise });\n                    }\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'alternatives.all': '{{#label}} does not match all of the required types',\n        'alternatives.any': '{{#label}} does not match any of the allowed types',\n        'alternatives.match': '{{#label}} does not match any of the allowed types',\n        'alternatives.one': '{{#label}} matches more than one allowed type',\n        'alternatives.types': '{{#label}} must be one of {{#types}}'\n    }\n});\n\n\n// Helpers\n\ninternals.errors = function (failures, { error, state }) {\n\n    // Nothing matched due to type criteria rules\n\n    if (!failures.length) {\n        return { errors: error('alternatives.any') };\n    }\n\n    // Single error\n\n    if (failures.length === 1) {\n        return { errors: failures[0].reports };\n    }\n\n    // Analyze reasons\n\n    const valids = new Set();\n    const complex = [];\n\n    for (const { reports, schema } of failures) {\n\n        // Multiple errors (!abortEarly)\n\n        if (reports.length > 1) {\n            return internals.unmatched(failures, error);\n        }\n\n        // Custom error\n\n        const report = reports[0];\n        if (report instanceof Errors.Report === false) {\n            return internals.unmatched(failures, error);\n        }\n\n        // Internal object or array error\n\n        if (report.state.path.length !== state.path.length) {\n            complex.push({ type: schema.type, report });\n            continue;\n        }\n\n        // Valids\n\n        if (report.code === 'any.only') {\n            for (const valid of report.local.valids) {\n                valids.add(valid);\n            }\n\n            continue;\n        }\n\n        // Base type\n\n        const [type, code] = report.code.split('.');\n        if (code !== 'base') {\n            complex.push({ type: schema.type, report });\n            continue;\n        }\n\n        valids.add(type);\n    }\n\n    // All errors are base types or valids\n\n    if (!complex.length) {\n        return { errors: error('alternatives.types', { types: [...valids] }) };\n    }\n\n    // Single complex error\n\n    if (complex.length === 1) {\n        return { errors: complex[0].report };\n    }\n\n    return internals.unmatched(failures, error);\n};\n\n\ninternals.unmatched = function (failures, error) {\n\n    const errors = [];\n    for (const failure of failures) {\n        errors.push(...failure.reports);\n    }\n\n    return { errors: error('alternatives.match', Errors.details(errors, { override: false })) };\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AAEA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMK,GAAG,GAAGL,OAAO,CAAC,QAAD,CAAnB;;AAGA,MAAMM,SAAS,GAAG,EAAlB;AAGAC,MAAM,CAACC,OAAP,GAAiBP,GAAG,CAACQ,MAAJ,CAAW;EAExBC,IAAI,EAAE,cAFkB;EAIxBC,KAAK,EAAE;IAEHC,KAAK,EAAE;MAAEC,OAAO,EAAE;IAAX,CAFJ,CAEuC;;EAFvC,CAJiB;EASxBC,KAAK,EAAE;IAEHC,OAAO,EAAE;MAAEC,IAAI,EAAE,EAAR;MAAYC,QAAQ,EAAEZ,GAAG,CAACa;IAA1B;EAFN,CATiB;;EAcxBC,IAAI,CAACC,MAAD,EAAqB;IAAA,kCAATC,OAAS;MAATA,OAAS;IAAA;;IAErB,IAAIA,OAAO,CAACC,MAAR,KAAmB,CAAvB,EAA0B;MACtB,IAAIC,KAAK,CAACC,OAAN,CAAcH,OAAO,CAAC,CAAD,CAArB,CAAJ,EAA+B;QAC3B,OAAOD,MAAM,CAACK,GAAP,CAAW,GAAGJ,OAAO,CAAC,CAAD,CAArB,CAAP;MACH;IACJ;;IAED,OAAOD,MAAM,CAACK,GAAP,CAAW,GAAGJ,OAAd,CAAP;EACH,CAvBuB;;EAyBxBK,QAAQ,CAACC,KAAD,EAAQC,OAAR,EAAiB;IAErB,MAAM;MAAER,MAAF;MAAUS,KAAV;MAAiBC,KAAjB;MAAwBC;IAAxB,IAAkCH,OAAxC,CAFqB,CAIrB;;IAEA,IAAIR,MAAM,CAACY,MAAP,CAAcpB,KAAlB,EAAyB;MACrB,IAAIqB,IAAI,GAAG,CAAX;MACA,IAAIC,OAAJ;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,MAAM,CAACgB,OAAP,CAAerB,OAAf,CAAuBO,MAA3C,EAAmD,EAAEa,CAArD,EAAwD;QACpD,MAAME,IAAI,GAAGjB,MAAM,CAACgB,OAAP,CAAerB,OAAf,CAAuBoB,CAAvB,CAAb;QACA,MAAMG,UAAU,GAAGR,KAAK,CAACS,IAAN,CAAWF,IAAI,CAACjB,MAAhB,EAAyB,SAAQe,CAAE,EAAnC,CAAnB;QACAG,UAAU,CAACE,QAAX;QAEA,MAAMC,MAAM,GAAGJ,IAAI,CAACjB,MAAL,CAAYsB,UAAZ,CAAuBf,KAAvB,EAA8BW,UAA9B,EAA0CP,KAA1C,CAAf;;QACA,IAAI,CAACU,MAAM,CAACE,MAAZ,EAAoB;UAChB,EAAEV,IAAF;UACAC,OAAO,GAAGO,MAAM,CAACd,KAAjB;QACH,CAHD,MAIK;UACDW,UAAU,CAACM,OAAX;QACH;MACJ;;MAED,IAAI,CAACX,IAAL,EAAW;QACP,OAAO;UAAEU,MAAM,EAAEd,KAAK,CAAC,kBAAD;QAAf,CAAP;MACH;;MAED,IAAIT,MAAM,CAACY,MAAP,CAAcpB,KAAd,KAAwB,KAA5B,EAAmC;QAC/B,OAAOqB,IAAI,KAAK,CAAT,GAAa;UAAEN,KAAK,EAAEO;QAAT,CAAb,GAAkC;UAAES,MAAM,EAAEd,KAAK,CAAC,kBAAD;QAAf,CAAzC;MACH;;MAED,OAAOI,IAAI,KAAKb,MAAM,CAACgB,OAAP,CAAerB,OAAf,CAAuBO,MAAhC,GAAyC;QAAEK;MAAF,CAAzC,GAAqD;QAAEgB,MAAM,EAAEd,KAAK,CAAC,kBAAD;MAAf,CAA5D;IACH,CAlCoB,CAoCrB;;;IAEA,MAAMc,MAAM,GAAG,EAAf;;IACA,KAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,MAAM,CAACgB,OAAP,CAAerB,OAAf,CAAuBO,MAA3C,EAAmD,EAAEa,CAArD,EAAwD;MACpD,MAAME,IAAI,GAAGjB,MAAM,CAACgB,OAAP,CAAerB,OAAf,CAAuBoB,CAAvB,CAAb,CADoD,CAGpD;;MAEA,IAAIE,IAAI,CAACjB,MAAT,EAAiB;QACb,MAAMkB,UAAU,GAAGR,KAAK,CAACS,IAAN,CAAWF,IAAI,CAACjB,MAAhB,EAAyB,SAAQe,CAAE,EAAnC,CAAnB;QACAG,UAAU,CAACE,QAAX;QAEA,MAAMC,MAAM,GAAGJ,IAAI,CAACjB,MAAL,CAAYsB,UAAZ,CAAuBf,KAAvB,EAA8BW,UAA9B,EAA0CP,KAA1C,CAAf;;QACA,IAAI,CAACU,MAAM,CAACE,MAAZ,EAAoB;UAChB,OAAOF,MAAP;QACH;;QAEDH,UAAU,CAACM,OAAX;QACAD,MAAM,CAACE,IAAP,CAAY;UAAEzB,MAAM,EAAEiB,IAAI,CAACjB,MAAf;UAAuB0B,OAAO,EAAEL,MAAM,CAACE;QAAvC,CAAZ;QACA;MACH,CAjBmD,CAmBpD;;;MAEA,MAAMI,KAAK,GAAGV,IAAI,CAACW,GAAL,GAAWX,IAAI,CAACW,GAAL,CAASC,OAAT,CAAiBtB,KAAjB,EAAwBG,KAAxB,EAA+BC,KAA/B,CAAX,GAAmDJ,KAAjE;MACA,MAAMuB,KAAK,GAAGb,IAAI,CAACc,EAAL,GAAU,CAACd,IAAD,CAAV,GAAmBA,IAAI,CAACe,MAAtC;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAAC5B,MAA1B,EAAkC,EAAE+B,CAApC,EAAuC;QACnC,MAAMC,IAAI,GAAGJ,KAAK,CAACG,CAAD,CAAlB;QACA,MAAM;UAAEF,EAAF;UAAMI,IAAN;UAAYC;QAAZ,IAA0BF,IAAhC;QAEA,MAAMG,EAAE,GAAI,SAAQtB,CAAE,GAAEE,IAAI,CAACe,MAAL,GAAc,MAAMC,CAApB,GAAwB,EAAG,EAAnD;;QACA,IAAI,CAACF,EAAE,CAACO,OAAH,CAAWX,KAAX,EAAkBjB,KAAK,CAACS,IAAN,CAAWY,EAAX,EAAgB,GAAEM,EAAG,KAArB,CAAlB,EAA8C1B,KAA9C,CAAL,EAA2D;UACvD,IAAIyB,SAAJ,EAAe;YACX,OAAOA,SAAS,CAACd,UAAV,CAAqBf,KAArB,EAA4BG,KAAK,CAACS,IAAN,CAAWiB,SAAX,EAAuB,GAAEC,EAAG,YAA5B,CAA5B,EAAsE1B,KAAtE,CAAP;UACH;QACJ,CAJD,MAKK,IAAIwB,IAAJ,EAAU;UACX,OAAOA,IAAI,CAACb,UAAL,CAAgBf,KAAhB,EAAuBG,KAAK,CAACS,IAAN,CAAWgB,IAAX,EAAkB,GAAEE,EAAG,OAAvB,CAAvB,EAAuD1B,KAAvD,CAAP;QACH;MACJ;IACJ;;IAED,OAAOzB,SAAS,CAACqC,MAAV,CAAiBA,MAAjB,EAAyBf,OAAzB,CAAP;EACH,CAzGuB;;EA2GxB+B,KAAK,EAAE;IAEHC,WAAW,EAAE;MACTC,MAAM,CAACC,SAAD,EAAYC,OAAZ,EAAqB;QAEvBhE,MAAM,CAAC,CAAC,KAAKiC,MAAL,CAAYgC,YAAd,EAA4B,uBAA5B,CAAN;QACAjE,MAAM,CAAC,CAAC,KAAKiC,MAAL,CAAYpB,KAAd,EAAqB,2BAArB,EAAkD,KAAKoB,MAAL,CAAYpB,KAA9D,EAAqE,uBAArE,CAAN;QACAb,MAAM,CAACgE,OAAO,CAACE,KAAR,KAAkBC,SAAnB,EAA8B,uDAA9B,CAAN;QAEA,MAAMC,GAAG,GAAG,KAAKC,KAAL,EAAZ;QAEA,MAAMxD,KAAK,GAAGT,OAAO,CAACkE,IAAR,CAAaF,GAAb,EAAkBL,SAAlB,EAA6BC,OAA7B,CAAd;QACA,MAAMO,UAAU,GAAG1D,KAAK,CAACuC,EAAN,GAAW,CAACvC,KAAD,CAAX,GAAqBA,KAAK,CAACwC,MAA9C;;QACA,KAAK,MAAMf,IAAX,IAAmBiC,UAAnB,EAA+B;UAC3B,IAAIjC,IAAI,CAACkB,IAAL,IACAlB,IAAI,CAACmB,SADT,EACoB;YAEhBW,GAAG,CAACI,SAAJ,CAAc,cAAd,EAA8B,IAA9B,EAAoC;cAAEH,KAAK,EAAE;YAAT,CAApC;YACA;UACH;QACJ;;QAEDD,GAAG,CAAC/B,OAAJ,CAAYrB,OAAZ,CAAoB8B,IAApB,CAAyBjC,KAAzB;QACA,OAAOuD,GAAG,CAACK,eAAJ,EAAP;MACH;;IAtBQ,CAFV;IA2BH5D,KAAK,EAAE;MACHiD,MAAM,CAACY,IAAD,EAAO;QAET1E,MAAM,CAAC,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB2E,QAAtB,CAA+BD,IAA/B,CAAD,EAAuC,iCAAvC,EAA0EA,IAA1E,CAAN;;QAEA,IAAIA,IAAI,KAAK,KAAb,EAAoB;UAChB,KAAK,MAAM7D,KAAX,IAAoB,KAAKwB,OAAL,CAAarB,OAAjC,EAA0C;YACtChB,MAAM,CAACa,KAAK,CAACQ,MAAP,EAAe,2BAAf,EAA4CqD,IAA5C,EAAkD,wBAAlD,CAAN;UACH;QACJ;;QAED,OAAO,KAAKF,SAAL,CAAe,OAAf,EAAwBE,IAAxB,CAAP;MACH;;IAZE,CA3BJ;IA0CHhD,GAAG,EAAE;MACDoC,MAAM,GAAa;QAAA,mCAATxC,OAAS;UAATA,OAAS;QAAA;;QAEftB,MAAM,CAACsB,OAAO,CAACC,MAAT,EAAiB,6BAAjB,CAAN;QACApB,MAAM,CAACyE,UAAP,CAAkBtD,OAAlB,EAA2B,KAA3B;QAEAtB,MAAM,CAAC,CAAC,KAAKiC,MAAL,CAAYgC,YAAd,EAA4B,uBAA5B,CAAN;QAEA,MAAMG,GAAG,GAAG,KAAKC,KAAL,EAAZ;;QACA,KAAK,MAAMhD,MAAX,IAAqBC,OAArB,EAA8B;UAC1B8C,GAAG,CAAC/B,OAAJ,CAAYrB,OAAZ,CAAoB8B,IAApB,CAAyB;YAAEzB,MAAM,EAAE+C,GAAG,CAACS,SAAJ,CAAcxD,MAAd;UAAV,CAAzB;QACH;;QAED,OAAO+C,GAAG,CAACK,eAAJ,EAAP;MACH;;IAdA;EA1CF,CA3GiB;EAuKxBK,SAAS,EAAE;IAEPC,KAAK,CAACC,IAAD,EAAO;MAER,MAAMZ,GAAG,GAAG,KAAKa,OAAL,CAAaF,KAAb,CAAmBC,IAAnB,CAAZ;;MACA,MAAME,IAAI,GAAG,CAAC5C,IAAD,EAAO6C,MAAP,KAAmBA,MAAM,CAACC,IAAP,CAAY,CAAZ,MAAmB,IAAnB,GAA0B9C,IAAI,CAACyC,KAAL,CAAWC,IAAX,CAA1B,GAA6Cb,SAA7E;;MACA,OAAOC,GAAG,CAACiB,QAAJ,CAAa;QAAEH,IAAF;QAAQjC,GAAG,EAAE;MAAb,CAAb,CAAP;IACH;;EAPM,CAvKa;;EAiLxBqC,OAAO,CAACjE,MAAD,EAAS;IAEZ;IAEA,MAAM6D,IAAI,GAAI5C,IAAD,IAAU;MAEnB,IAAInC,MAAM,CAACoF,QAAP,CAAgBjD,IAAhB,KACAA,IAAI,CAAC3B,IAAL,KAAc,OADlB,EAC2B;QAEvBU,MAAM,CAACmD,SAAP,CAAiB,aAAjB,EAAgC,IAAhC,EAAsC;UAAEH,KAAK,EAAE;QAAT,CAAtC;MACH;IACJ,CAPD;;IASAhD,MAAM,CAACgE,QAAP,CAAgB;MAAEH;IAAF,CAAhB;EACH,CA/LuB;;EAiMxBM,QAAQ,EAAE;IAENC,KAAK,CAACrB,GAAD,EAAMsB,IAAN,EAAY;MAEb,IAAIA,IAAI,CAAC1E,OAAT,EAAkB;QACd,KAAK,MAAMH,KAAX,IAAoB6E,IAAI,CAAC1E,OAAzB,EAAkC;UAC9B,MAAM;YAAEK,MAAF;YAAU4B,GAAV;YAAeG,EAAf;YAAmBuC,GAAnB;YAAwBnC,IAAxB;YAA8BC;UAA9B,IAA4C5C,KAAlD;;UACA,IAAIQ,MAAJ,EAAY;YACR+C,GAAG,GAAGA,GAAG,CAAC1C,GAAJ,CAAQL,MAAR,CAAN;UACH,CAFD,MAGK,IAAI4B,GAAJ,EAAS;YACVmB,GAAG,GAAGA,GAAG,CAACP,WAAJ,CAAgBZ,GAAhB,EAAqB;cAAEG,EAAF;cAAMI,IAAN;cAAYmC,GAAZ;cAAiBlC,SAAjB;cAA4BJ,MAAM,EAAExC,KAAK,CAACwC;YAA1C,CAArB,CAAN;UACH,CAFI,MAGA;YACDe,GAAG,GAAGA,GAAG,CAACP,WAAJ,CAAgBT,EAAhB,EAAoB;cAAEI,IAAF;cAAQC;YAAR,CAApB,CAAN;UACH;QACJ;MACJ;;MAED,OAAOW,GAAP;IACH;;EApBK,CAjMc;EAwNxBwB,QAAQ,EAAE;IACN,oBAAoB,qDADd;IAEN,oBAAoB,oDAFd;IAGN,sBAAsB,oDAHhB;IAIN,oBAAoB,+CAJd;IAKN,sBAAsB;EALhB;AAxNc,CAAX,CAAjB,C,CAkOA;;AAEArF,SAAS,CAACqC,MAAV,GAAmB,UAAUiD,QAAV,QAAsC;EAAA,IAAlB;IAAE/D,KAAF;IAASC;EAAT,CAAkB;;EAErD;EAEA,IAAI,CAAC8D,QAAQ,CAACtE,MAAd,EAAsB;IAClB,OAAO;MAAEqB,MAAM,EAAEd,KAAK,CAAC,kBAAD;IAAf,CAAP;EACH,CANoD,CAQrD;;;EAEA,IAAI+D,QAAQ,CAACtE,MAAT,KAAoB,CAAxB,EAA2B;IACvB,OAAO;MAAEqB,MAAM,EAAEiD,QAAQ,CAAC,CAAD,CAAR,CAAY9C;IAAtB,CAAP;EACH,CAZoD,CAcrD;;;EAEA,MAAM+C,MAAM,GAAG,IAAIC,GAAJ,EAAf;EACA,MAAMC,OAAO,GAAG,EAAhB;;EAEA,KAAK,MAAM;IAAEjD,OAAF;IAAW1B;EAAX,CAAX,IAAkCwE,QAAlC,EAA4C;IAExC;IAEA,IAAI9C,OAAO,CAACxB,MAAR,GAAiB,CAArB,EAAwB;MACpB,OAAOhB,SAAS,CAAC0F,SAAV,CAAoBJ,QAApB,EAA8B/D,KAA9B,CAAP;IACH,CANuC,CAQxC;;;IAEA,MAAMoE,MAAM,GAAGnD,OAAO,CAAC,CAAD,CAAtB;;IACA,IAAImD,MAAM,YAAY7F,MAAM,CAAC8F,MAAzB,KAAoC,KAAxC,EAA+C;MAC3C,OAAO5F,SAAS,CAAC0F,SAAV,CAAoBJ,QAApB,EAA8B/D,KAA9B,CAAP;IACH,CAbuC,CAexC;;;IAEA,IAAIoE,MAAM,CAACnE,KAAP,CAAaqD,IAAb,CAAkB7D,MAAlB,KAA6BQ,KAAK,CAACqD,IAAN,CAAW7D,MAA5C,EAAoD;MAChDyE,OAAO,CAAClD,IAAR,CAAa;QAAEnC,IAAI,EAAEU,MAAM,CAACV,IAAf;QAAqBuF;MAArB,CAAb;MACA;IACH,CApBuC,CAsBxC;;;IAEA,IAAIA,MAAM,CAACE,IAAP,KAAgB,UAApB,EAAgC;MAC5B,KAAK,MAAMC,KAAX,IAAoBH,MAAM,CAACI,KAAP,CAAaR,MAAjC,EAAyC;QACrCA,MAAM,CAACS,GAAP,CAAWF,KAAX;MACH;;MAED;IACH,CA9BuC,CAgCxC;;;IAEA,MAAM,CAAC1F,IAAD,EAAOyF,IAAP,IAAeF,MAAM,CAACE,IAAP,CAAYI,KAAZ,CAAkB,GAAlB,CAArB;;IACA,IAAIJ,IAAI,KAAK,MAAb,EAAqB;MACjBJ,OAAO,CAAClD,IAAR,CAAa;QAAEnC,IAAI,EAAEU,MAAM,CAACV,IAAf;QAAqBuF;MAArB,CAAb;MACA;IACH;;IAEDJ,MAAM,CAACS,GAAP,CAAW5F,IAAX;EACH,CA5DoD,CA8DrD;;;EAEA,IAAI,CAACqF,OAAO,CAACzE,MAAb,EAAqB;IACjB,OAAO;MAAEqB,MAAM,EAAEd,KAAK,CAAC,oBAAD,EAAuB;QAAE2E,KAAK,EAAE,CAAC,GAAGX,MAAJ;MAAT,CAAvB;IAAf,CAAP;EACH,CAlEoD,CAoErD;;;EAEA,IAAIE,OAAO,CAACzE,MAAR,KAAmB,CAAvB,EAA0B;IACtB,OAAO;MAAEqB,MAAM,EAAEoD,OAAO,CAAC,CAAD,CAAP,CAAWE;IAArB,CAAP;EACH;;EAED,OAAO3F,SAAS,CAAC0F,SAAV,CAAoBJ,QAApB,EAA8B/D,KAA9B,CAAP;AACH,CA3ED;;AA8EAvB,SAAS,CAAC0F,SAAV,GAAsB,UAAUJ,QAAV,EAAoB/D,KAApB,EAA2B;EAE7C,MAAMc,MAAM,GAAG,EAAf;;EACA,KAAK,MAAM8D,OAAX,IAAsBb,QAAtB,EAAgC;IAC5BjD,MAAM,CAACE,IAAP,CAAY,GAAG4D,OAAO,CAAC3D,OAAvB;EACH;;EAED,OAAO;IAAEH,MAAM,EAAEd,KAAK,CAAC,oBAAD,EAAuBzB,MAAM,CAACsG,OAAP,CAAe/D,MAAf,EAAuB;MAAEgE,QAAQ,EAAE;IAAZ,CAAvB,CAAvB;EAAf,CAAP;AACH,CARD"},"metadata":{},"sourceType":"script"}