{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst EscapeHtml = require('@hapi/hoek/lib/escapeHtml');\n\nconst Formula = require('@hapi/formula');\n\nconst Common = require('./common');\n\nconst Errors = require('./errors');\n\nconst Ref = require('./ref');\n\nconst internals = {\n  symbol: Symbol('template'),\n  opens: new Array(1000).join('\\u0000'),\n  closes: new Array(1000).join('\\u0001'),\n  dateFormat: {\n    date: Date.prototype.toDateString,\n    iso: Date.prototype.toISOString,\n    string: Date.prototype.toString,\n    time: Date.prototype.toTimeString,\n    utc: Date.prototype.toUTCString\n  }\n};\nmodule.exports = exports = internals.Template = class {\n  constructor(source, options) {\n    Assert(typeof source === 'string', 'Template source must be a string');\n    Assert(!source.includes('\\u0000') && !source.includes('\\u0001'), 'Template source cannot contain reserved control characters');\n    this.source = source;\n    this.rendered = source;\n    this._template = null;\n    this._settings = Clone(options);\n\n    this._parse();\n  }\n\n  _parse() {\n    // 'text {raw} {{ref}} \\\\{{ignore}} {{ignore\\\\}} {{ignore {{ignore}'\n    if (!this.source.includes('{')) {\n      return;\n    } // Encode escaped \\\\{{{{{\n\n\n    const encoded = internals.encode(this.source); // Split on first { in each set\n\n    const parts = internals.split(encoded); // Process parts\n\n    let refs = false;\n    const processed = [];\n    const head = parts.shift();\n\n    if (head) {\n      processed.push(head);\n    }\n\n    for (const part of parts) {\n      const raw = part[0] !== '{';\n      const ender = raw ? '}' : '}}';\n      const end = part.indexOf(ender);\n\n      if (end === -1 || // Ignore non-matching closing\n      part[1] === '{') {\n        // Ignore more than two {\n        processed.push(`{${internals.decode(part)}`);\n        continue;\n      }\n\n      const variable = part.slice(raw ? 0 : 1, end);\n\n      const dynamic = this._ref(internals.decode(variable), raw);\n\n      processed.push(dynamic);\n\n      if (typeof dynamic !== 'string') {\n        refs = true;\n      }\n\n      const rest = part.slice(end + ender.length);\n\n      if (rest) {\n        processed.push(internals.decode(rest));\n      }\n    }\n\n    if (!refs) {\n      this.rendered = processed.join('');\n      return;\n    }\n\n    this._template = processed;\n  }\n\n  static date(date, prefs) {\n    return internals.dateFormat[prefs.dateFormat].call(date);\n  }\n\n  describe() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this._settings && options.compact) {\n      return this.source;\n    }\n\n    const desc = {\n      template: this.source\n    };\n\n    if (this._settings) {\n      desc.options = this._settings;\n    }\n\n    return desc;\n  }\n\n  static build(desc) {\n    return new internals.Template(desc.template, desc.options);\n  }\n\n  isDynamic() {\n    return !!this._template;\n  }\n\n  static isTemplate(template) {\n    return template ? !!template[Common.symbols.template] : false;\n  }\n\n  refs() {\n    if (!this._template) {\n      return;\n    }\n\n    const refs = [];\n\n    for (const part of this._template) {\n      if (typeof part !== 'string') {\n        refs.push(...part.refs);\n      }\n    }\n\n    return refs;\n  }\n\n  resolve(value, state, prefs, local) {\n    if (this._template && this._template.length === 1) {\n      return this._part(this._template[0],\n      /* context -> [*/\n      value, state, prefs, local, {}\n      /*] */\n      );\n    }\n\n    return this.render(value, state, prefs, local);\n  }\n\n  _part(part) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (part.ref) {\n      return part.ref.resolve(...args);\n    }\n\n    return part.formula.evaluate(args);\n  }\n\n  render(value, state, prefs, local) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    if (!this.isDynamic()) {\n      return this.rendered;\n    }\n\n    const parts = [];\n\n    for (const part of this._template) {\n      if (typeof part === 'string') {\n        parts.push(part);\n      } else {\n        const rendered = this._part(part,\n        /* context -> [*/\n        value, state, prefs, local, options\n        /*] */\n        );\n\n        const string = internals.stringify(rendered, prefs, options.errors);\n\n        if (string !== undefined) {\n          const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);\n          const ends = part.ref && part.ref.type === 'local' && part.ref.key === 'label' && prefs.errors.wrap.label;\n          parts.push(internals.wrap(result, ends));\n        }\n      }\n    }\n\n    return parts.join('');\n  }\n\n  _ref(content, raw) {\n    const refs = [];\n\n    const reference = variable => {\n      const ref = Ref.create(variable, this._settings);\n      refs.push(ref);\n      return context => ref.resolve(...context);\n    };\n\n    try {\n      var formula = new Formula.Parser(content, {\n        reference,\n        functions: internals.functions,\n        constants: internals.constants\n      });\n    } catch (err) {\n      err.message = `Invalid template variable \"${content}\" fails due to: ${err.message}`;\n      throw err;\n    }\n\n    if (formula.single) {\n      if (formula.single.type === 'reference') {\n        return {\n          ref: refs[0],\n          raw,\n          refs\n        };\n      }\n\n      return internals.stringify(formula.single.value);\n    }\n\n    return {\n      formula,\n      raw,\n      refs\n    };\n  }\n\n  toString() {\n    return this.source;\n  }\n\n};\ninternals.Template.prototype[Common.symbols.template] = true;\ninternals.Template.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n\ninternals.encode = function (string) {\n  return string.replace(/\\\\(\\{+)/g, ($0, $1) => {\n    return internals.opens.slice(0, $1.length);\n  }).replace(/\\\\(\\}+)/g, ($0, $1) => {\n    return internals.closes.slice(0, $1.length);\n  });\n};\n\ninternals.decode = function (string) {\n  return string.replace(/\\u0000/g, '{').replace(/\\u0001/g, '}');\n};\n\ninternals.split = function (string) {\n  const parts = [];\n  let current = '';\n\n  for (let i = 0; i < string.length; ++i) {\n    const char = string[i];\n\n    if (char === '{') {\n      let next = '';\n\n      while (i + 1 < string.length && string[i + 1] === '{') {\n        next += '{';\n        ++i;\n      }\n\n      parts.push(current);\n      current = next;\n    } else {\n      current += char;\n    }\n  }\n\n  parts.push(current);\n  return parts;\n};\n\ninternals.wrap = function (value, ends) {\n  if (!ends) {\n    return value;\n  }\n\n  if (ends.length === 1) {\n    return `${ends}${value}${ends}`;\n  }\n\n  return `${ends[0]}${value}${ends[1]}`;\n};\n\ninternals.stringify = function (value, prefs, options) {\n  const type = typeof value;\n\n  if (value === null) {\n    return 'null';\n  }\n\n  if (type === 'string') {\n    return value;\n  }\n\n  if (type === 'number' || type === 'function' || type === 'symbol') {\n    return value.toString();\n  }\n\n  if (type !== 'object') {\n    return JSON.stringify(value);\n  }\n\n  if (value instanceof Date) {\n    return internals.Template.date(value, prefs);\n  }\n\n  if (value instanceof Map) {\n    const pairs = [];\n\n    for (const [key, sym] of value.entries()) {\n      pairs.push(`${key.toString()} -> ${sym.toString()}`);\n    }\n\n    value = pairs;\n  }\n\n  if (!Array.isArray(value)) {\n    return value.toString();\n  }\n\n  let partial = '';\n\n  for (const item of value) {\n    partial = partial + (partial.length ? ', ' : '') + internals.stringify(item, prefs, options);\n  }\n\n  return internals.wrap(partial, prefs.errors.wrap.array);\n};\n\ninternals.constants = {\n  true: true,\n  false: false,\n  null: null,\n  second: 1000,\n  minute: 60 * 1000,\n  hour: 60 * 60 * 1000,\n  day: 24 * 60 * 60 * 1000\n};\ninternals.functions = {\n  if(condition, then, otherwise) {\n    return condition ? then : otherwise;\n  },\n\n  msg(code) {\n    const [value, state, prefs, local, options] = this;\n    const messages = options.messages;\n\n    if (!messages) {\n      return '';\n    }\n\n    const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);\n\n    if (!template) {\n      return '';\n    }\n\n    return template.render(value, state, prefs, local, options);\n  },\n\n  number(value) {\n    if (typeof value === 'number') {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return parseFloat(value);\n    }\n\n    if (typeof value === 'boolean') {\n      return value ? 1 : 0;\n    }\n\n    if (value instanceof Date) {\n      return value.getTime();\n    }\n\n    return null;\n  }\n\n};","map":{"version":3,"names":["Assert","require","Clone","EscapeHtml","Formula","Common","Errors","Ref","internals","symbol","Symbol","opens","Array","join","closes","dateFormat","date","Date","prototype","toDateString","iso","toISOString","string","toString","time","toTimeString","utc","toUTCString","module","exports","Template","constructor","source","options","includes","rendered","_template","_settings","_parse","encoded","encode","parts","split","refs","processed","head","shift","push","part","raw","ender","end","indexOf","decode","variable","slice","dynamic","_ref","rest","length","prefs","call","describe","compact","desc","template","build","isDynamic","isTemplate","symbols","resolve","value","state","local","_part","render","args","ref","formula","evaluate","stringify","errors","undefined","result","escapeHtml","ends","type","key","wrap","label","content","reference","create","context","Parser","functions","constants","err","message","single","isImmutable","replace","$0","$1","current","i","char","next","JSON","Map","pairs","sym","entries","isArray","partial","item","array","true","false","null","second","minute","hour","day","if","condition","then","otherwise","msg","code","messages","number","parseFloat","getTime"],"sources":["/home/aminou/React/mon-coter-somber/node_modules/@hapi/joi/lib/template.js"],"sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst EscapeHtml = require('@hapi/hoek/lib/escapeHtml');\nconst Formula = require('@hapi/formula');\n\nconst Common = require('./common');\nconst Errors = require('./errors');\nconst Ref = require('./ref');\n\n\nconst internals = {\n    symbol: Symbol('template'),\n\n    opens: new Array(1000).join('\\u0000'),\n    closes: new Array(1000).join('\\u0001'),\n\n    dateFormat: {\n        date: Date.prototype.toDateString,\n        iso: Date.prototype.toISOString,\n        string: Date.prototype.toString,\n        time: Date.prototype.toTimeString,\n        utc: Date.prototype.toUTCString\n    }\n};\n\n\nmodule.exports = exports = internals.Template = class {\n\n    constructor(source, options) {\n\n        Assert(typeof source === 'string', 'Template source must be a string');\n        Assert(!source.includes('\\u0000') && !source.includes('\\u0001'), 'Template source cannot contain reserved control characters');\n\n        this.source = source;\n        this.rendered = source;\n\n        this._template = null;\n        this._settings = Clone(options);\n\n        this._parse();\n    }\n\n    _parse() {\n\n        // 'text {raw} {{ref}} \\\\{{ignore}} {{ignore\\\\}} {{ignore {{ignore}'\n\n        if (!this.source.includes('{')) {\n            return;\n        }\n\n        // Encode escaped \\\\{{{{{\n\n        const encoded = internals.encode(this.source);\n\n        // Split on first { in each set\n\n        const parts = internals.split(encoded);\n\n        // Process parts\n\n        let refs = false;\n        const processed = [];\n        const head = parts.shift();\n        if (head) {\n            processed.push(head);\n        }\n\n        for (const part of parts) {\n            const raw = part[0] !== '{';\n            const ender = raw ? '}' : '}}';\n            const end = part.indexOf(ender);\n            if (end === -1 ||                               // Ignore non-matching closing\n                part[1] === '{') {                          // Ignore more than two {\n\n                processed.push(`{${internals.decode(part)}`);\n                continue;\n            }\n\n            const variable = part.slice(raw ? 0 : 1, end);\n            const dynamic = this._ref(internals.decode(variable), raw);\n            processed.push(dynamic);\n            if (typeof dynamic !== 'string') {\n                refs = true;\n            }\n\n            const rest = part.slice(end + ender.length);\n            if (rest) {\n                processed.push(internals.decode(rest));\n            }\n        }\n\n        if (!refs) {\n            this.rendered = processed.join('');\n            return;\n        }\n\n        this._template = processed;\n    }\n\n    static date(date, prefs) {\n\n        return internals.dateFormat[prefs.dateFormat].call(date);\n    }\n\n    describe(options = {}) {\n\n        if (!this._settings &&\n            options.compact) {\n\n            return this.source;\n        }\n\n        const desc = { template: this.source };\n        if (this._settings) {\n            desc.options = this._settings;\n        }\n\n        return desc;\n    }\n\n    static build(desc) {\n\n        return new internals.Template(desc.template, desc.options);\n    }\n\n    isDynamic() {\n\n        return !!this._template;\n    }\n\n    static isTemplate(template) {\n\n        return template ? !!template[Common.symbols.template] : false;\n    }\n\n    refs() {\n\n        if (!this._template) {\n            return;\n        }\n\n        const refs = [];\n        for (const part of this._template) {\n            if (typeof part !== 'string') {\n                refs.push(...part.refs);\n            }\n        }\n\n        return refs;\n    }\n\n    resolve(value, state, prefs, local) {\n\n        if (this._template &&\n            this._template.length === 1) {\n\n            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */);\n        }\n\n        return this.render(value, state, prefs, local);\n    }\n\n    _part(part, ...args) {\n\n        if (part.ref) {\n            return part.ref.resolve(...args);\n        }\n\n        return part.formula.evaluate(args);\n    }\n\n    render(value, state, prefs, local, options = {}) {\n\n        if (!this.isDynamic()) {\n            return this.rendered;\n        }\n\n        const parts = [];\n        for (const part of this._template) {\n            if (typeof part === 'string') {\n                parts.push(part);\n            }\n            else {\n                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */);\n                const string = internals.stringify(rendered, prefs, options.errors);\n                if (string !== undefined) {\n                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);\n                    const ends = part.ref && part.ref.type === 'local' && part.ref.key === 'label' && prefs.errors.wrap.label;\n                    parts.push(internals.wrap(result, ends));\n                }\n            }\n        }\n\n        return parts.join('');\n    }\n\n    _ref(content, raw) {\n\n        const refs = [];\n        const reference = (variable) => {\n\n            const ref = Ref.create(variable, this._settings);\n            refs.push(ref);\n            return (context) => ref.resolve(...context);\n        };\n\n        try {\n            var formula = new Formula.Parser(content, { reference, functions: internals.functions, constants: internals.constants });\n        }\n        catch (err) {\n            err.message = `Invalid template variable \"${content}\" fails due to: ${err.message}`;\n            throw err;\n        }\n\n        if (formula.single) {\n            if (formula.single.type === 'reference') {\n                return { ref: refs[0], raw, refs };\n            }\n\n            return internals.stringify(formula.single.value);\n        }\n\n        return { formula, raw, refs };\n    }\n\n    toString() {\n\n        return this.source;\n    }\n};\n\n\ninternals.Template.prototype[Common.symbols.template] = true;\ninternals.Template.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects\n\n\ninternals.encode = function (string) {\n\n    return string\n        .replace(/\\\\(\\{+)/g, ($0, $1) => {\n\n            return internals.opens.slice(0, $1.length);\n        })\n        .replace(/\\\\(\\}+)/g, ($0, $1) => {\n\n            return internals.closes.slice(0, $1.length);\n        });\n};\n\n\ninternals.decode = function (string) {\n\n    return string\n        .replace(/\\u0000/g, '{')\n        .replace(/\\u0001/g, '}');\n};\n\n\ninternals.split = function (string) {\n\n    const parts = [];\n    let current = '';\n\n    for (let i = 0; i < string.length; ++i) {\n        const char = string[i];\n\n        if (char === '{') {\n            let next = '';\n            while (i + 1 < string.length &&\n                string[i + 1] === '{') {\n\n                next += '{';\n                ++i;\n            }\n\n            parts.push(current);\n            current = next;\n        }\n        else {\n            current += char;\n        }\n    }\n\n    parts.push(current);\n    return parts;\n};\n\n\ninternals.wrap = function (value, ends) {\n\n    if (!ends) {\n        return value;\n    }\n\n    if (ends.length === 1) {\n        return `${ends}${value}${ends}`;\n    }\n\n    return `${ends[0]}${value}${ends[1]}`;\n};\n\n\ninternals.stringify = function (value, prefs, options) {\n\n    const type = typeof value;\n\n    if (value === null) {\n        return 'null';\n    }\n\n    if (type === 'string') {\n        return value;\n    }\n\n    if (type === 'number' ||\n        type === 'function' ||\n        type === 'symbol') {\n\n        return value.toString();\n    }\n\n    if (type !== 'object') {\n        return JSON.stringify(value);\n    }\n\n    if (value instanceof Date) {\n        return internals.Template.date(value, prefs);\n    }\n\n    if (value instanceof Map) {\n        const pairs = [];\n        for (const [key, sym] of value.entries()) {\n            pairs.push(`${key.toString()} -> ${sym.toString()}`);\n        }\n\n        value = pairs;\n    }\n\n    if (!Array.isArray(value)) {\n        return value.toString();\n    }\n\n    let partial = '';\n    for (const item of value) {\n        partial = partial + (partial.length ? ', ' : '') + internals.stringify(item, prefs, options);\n    }\n\n    return internals.wrap(partial, prefs.errors.wrap.array);\n};\n\n\ninternals.constants = {\n\n    true: true,\n    false: false,\n    null: null,\n\n    second: 1000,\n    minute: 60 * 1000,\n    hour: 60 * 60 * 1000,\n    day: 24 * 60 * 60 * 1000\n};\n\n\ninternals.functions = {\n\n    if(condition, then, otherwise) {\n\n        return condition ? then : otherwise;\n    },\n\n    msg(code) {\n\n        const [value, state, prefs, local, options] = this;\n        const messages = options.messages;\n        if (!messages) {\n            return '';\n        }\n\n        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);\n        if (!template) {\n            return '';\n        }\n\n        return template.render(value, state, prefs, local, options);\n    },\n\n    number(value) {\n\n        if (typeof value === 'number') {\n            return value;\n        }\n\n        if (typeof value === 'string') {\n            return parseFloat(value);\n        }\n\n        if (typeof value === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (value instanceof Date) {\n            return value.getTime();\n        }\n\n        return null;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}